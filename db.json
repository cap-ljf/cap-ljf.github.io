{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/google4fd4ec061c03d6c6.html","path":"google4fd4ec061c03d6c6.html","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/微信.jpg","path":"img/微信.jpg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/支付宝.jpg","path":"img/支付宝.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"6603339d7f6f87cb61ecc47a337a8d42ddf4beb0","modified":1534170507533},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1534170507875},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1534170507877},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1534170507878},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1534170507879},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1534170507881},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1534170507882},{"_id":"themes/yilia/_config.yml","hash":"f0efae3648313ee703a97d23fade8ce3dcb903ee","modified":1534170507885},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1534170507884},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1534170507952},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1534170508079},{"_id":"source/_posts/2017个人报告.md","hash":"76e50e4942e991cc98e247d255b9dcc06a7374d0","modified":1534170507535},{"_id":"source/_posts/Hexo博客提交百度和谷歌收录.md","hash":"04bd9b0b193a1d92ed40c4d5dc4c4c7d6a55b096","modified":1534170507538},{"_id":"source/_posts/AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别.md","hash":"5fb2f5ecf456f22c6b35811f2ba180d442e27a6d","modified":1534170507537},{"_id":"source/_posts/JDBC.md","hash":"1dab7e4d04698a9e44cb1d2ad3f1615af10199a4","modified":1534170507540},{"_id":"source/_posts/JSON.md","hash":"52b56533dd46b27e81fe702a14199f76dfaeae39","modified":1534170507542},{"_id":"source/_posts/JVM.md","hash":"f16af15352983833391e1b74f16d4d08b52a62d7","modified":1534170507544},{"_id":"source/_posts/Java并发系列.md","hash":"f3f4a6db76f374a876069fd18dd6fc045c0da0b4","modified":1534170507545},{"_id":"source/_posts/Java泛型.md","hash":"5d9a4acb63cf6f49268d7c81972bb032c6e2ad56","modified":1534170507547},{"_id":"source/_posts/Java注解.md","hash":"df5cd7505742ecca0b289bb79cab6db47f0c594f","modified":1534170507548},{"_id":"source/_posts/Java流与文件.md","hash":"69dea99de15fe0e3187e53b809e29446320fa9dc","modified":1534170507550},{"_id":"source/_posts/Java网络编程.md","hash":"0b60e41411e64ff202634e26f0af8ea8faadb0e4","modified":1534170507551},{"_id":"source/_posts/Maven初探.md","hash":"0758aaa5c75d8ea5c43d9a5f09b905a2f73a7e14","modified":1534170507553},{"_id":"source/_posts/Spring-Data-Redis.md","hash":"91824f7e35b120d9f7b0bf990838a6b03561bcc7","modified":1534170507554},{"_id":"source/_posts/java 序列化(serialization).md","hash":"42e309839151cad48a7225efea3cba1e9c4c7b57","modified":1534170507556},{"_id":"source/_posts/javaIO流.md","hash":"0307ca85db1a53794ddc742b94bcd4056f81411a","modified":1534170507557},{"_id":"source/_posts/java网络IO.md","hash":"836fd61094f24cce9e057120719c8839ed7fc4ee","modified":1534170507559},{"_id":"source/_posts/python爬虫之新浪微博评论.md","hash":"357223b55b4a28d1aab7038fb1fb21db30e6e69e","modified":1534170507560},{"_id":"source/_posts/《Spring实战》Spring中使用JDBC.md","hash":"6cba6d2afcccdf4a5c3d97840e671dc005e21670","modified":1534170507562},{"_id":"source/_posts/《Spring实战》Web中的Spring.md","hash":"572079cbc32fb65c7a4bffec1dac35c348e2d8a6","modified":1534170507564},{"_id":"source/_posts/《Spring实战》搭建Spring-MVC.md","hash":"cfef2b6f747d48d33685b1408590961b9050ef41","modified":1534170507565},{"_id":"source/_posts/《Spring实战》装配bean.md","hash":"5768b6f5fb1fa1f1de28a00351ff5cfc57daaf3c","modified":1534170507567},{"_id":"source/_posts/《Spring实战》面向切面的Spring.md","hash":"b5654fb1bf222693107103608c163129cd526535","modified":1534170507568},{"_id":"source/_posts/《Spring实战》高级装配.md","hash":"0e278570908bca83dad499738f41d062ae9be71c","modified":1534170507569},{"_id":"source/_posts/《三个火枪手》噗噗噗.md","hash":"34b84485beaa0ab2bfc37a74447b75b954a8b346","modified":1534170507571},{"_id":"source/_posts/《提问的智慧》笔记.md","hash":"efbd1a97ca4f058aaa41d1f005aeeede19d4719d","modified":1534170507573},{"_id":"source/_posts/事务.md","hash":"00d7451c4e64b8ddce0be3dc16827e7d62867321","modified":1534170507574},{"_id":"source/_posts/京东面经.md","hash":"6f32012c3b9aaf767cf7729d442af2ddbde01a8d","modified":1534170507576},{"_id":"source/_posts/健身训练计划.md","hash":"c18c0c8e8dbc03257db9e5ab62acbdb5ff16f75d","modified":1534170507577},{"_id":"source/_posts/动态规划.md","hash":"bc0adf7960c6754a79c7e65c9ecc2c849958e544","modified":1534170507579},{"_id":"source/_posts/华为面经.md","hash":"4b44b8f03759685e40ce2125a6b02d7d48d2aa63","modified":1534170507580},{"_id":"source/_posts/单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）.md","hash":"8a03615001146fb63bd32f7af6d43d27f1a0298a","modified":1536111514984},{"_id":"source/_posts/去哪儿面经.md","hash":"a650c5b66be586255d7af4ed118ee35bff5a7a17","modified":1534170507581},{"_id":"source/_posts/基于scrapy分布式新闻评论爬虫.md","hash":"f47927da7d2f2a24d761aa16e5bcb4a1dcf3f7f2","modified":1534170507583},{"_id":"source/_posts/字符集-字符编码.md","hash":"513e83f7ffae1195986295f8316d764407a05aff","modified":1534170507584},{"_id":"source/_posts/指路人，还是引路人.md","hash":"02b2efb9725ebbd48b0d79dfca1da963a041e304","modified":1534170507586},{"_id":"source/_posts/译-Linux包管理基础：apt-yum-dnf-pkg.md","hash":"2524589f31b5241ad991288e595817ba5684f587","modified":1534170507589},{"_id":"source/_posts/正则表达式.md","hash":"a48ae1dc1f65b568ae4cea79b89b3be6f5f508ad","modified":1534170507587},{"_id":"source/_posts/起风了.md","hash":"455e5c10944ce4c3e83c5b1b766bd93fee951add","modified":1534170507591},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1534170507887},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1534170507889},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1534170507890},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1534170507892},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1534170507893},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1534170507894},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1534170507896},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1534170507941},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1534170507943},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1534170507947},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1534170507944},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1534170507946},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1534170507949},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1534170507950},{"_id":"themes/yilia/source/google4fd4ec061c03d6c6.html","hash":"65582bbcc41b6987f73a0ac118862cf302cbf80c","modified":1534170508053},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"a96a01e5eceb40bfb3db6c3d7a6e2efec9016d26","modified":1534170508069},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1534170508077},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1534170507954},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1534170508038},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534170507936},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1534170508071},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1534170508074},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1534170507899},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1534170507900},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1534170507901},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1534170507904},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"d6cb2db4295096bc34201675b3de7f7fba31fe6c","modified":1534170507903},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1534170507906},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1534170507907},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1534170507909},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1534170507910},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1534170507912},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1534170507913},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1534170507915},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1534170507916},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1534170507918},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1534170507938},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1534170507939},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1534170508041},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1534170508043},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1534170508045},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1534170508047},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1534170508049},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1534170508051},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1534170508058},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1534170508060},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1534170508062},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1534170507956},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1534170507957},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1534170507959},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1534170507960},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1534170507961},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1534170507963},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1534170507965},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1534170507968},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1534170507966},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1534170507977},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1534170507986},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1534170507987},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1534170507988},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1534170507990},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1534170507996},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1534170507998},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1534170507999},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1534170508001},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1534170508002},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1534170508003},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1534170508005},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1534170508006},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1534170508008},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1534170508009},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1534170508011},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1534170508012},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1534170508014},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1534170508016},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1534170508018},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1534170508019},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1534170508021},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1534170508022},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1534170508024},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1534170508029},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1534170508026},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1534170508031},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1534170508032},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1534170508034},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1534170508036},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1534170507935},{"_id":"themes/yilia/source/img/avatar.jpeg","hash":"f8e8aa88cda7b08f672a0a0169c941b3fe631e84","modified":1534170508056},{"_id":"themes/yilia/source/img/微信.jpg","hash":"dc7a23407344e711b0350373eb407f1f8a510141","modified":1534170508064},{"_id":"themes/yilia/source/img/支付宝.jpg","hash":"c0200bad748139d71b529b300b9a55e109048374","modified":1534170508067},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1534170507920},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1534170507921},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1534170507923},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1534170507924},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1534170507926},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1534170507927},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1534170507930},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1534170507929},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1534170507932},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1534170507933},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1534170507970},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1534170507971},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1534170507973},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1534170507974},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1534170507976},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1534170507979},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1534170507981},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1534170507983},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1534170507984},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1534170507992},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1534170507995},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1534170507993},{"_id":"public/baidu_urls.txt","hash":"38434979a77fa3a8a8428fa535e56bea0b639238","modified":1536111448177},{"_id":"public/baidusitemap.xml","hash":"32696528ba1da4a250455b9ec40f48cc02c9b44e","modified":1536111527238},{"_id":"public/content.json","hash":"2f1ce6f42cfe72f206d75a73fed32205960968c5","modified":1536111448805},{"_id":"public/sitemap.xml","hash":"e56a2a42ff425fb3fb91f7afae1fe8ce720a0fc9","modified":1536111528045},{"_id":"public/2018/09/05/单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）/index.html","hash":"405129d434e6161d54f97b5659bc1d7c41188a42","modified":1536111528290},{"_id":"public/2018/05/23/Java并发系列/index.html","hash":"3913c2b50b59df424dfa08e856585fda91abebf8","modified":1536111448824},{"_id":"public/2018/05/18/Java泛型/index.html","hash":"bb38a17f5dfa7fb2895139c1f69eba106d6ed218","modified":1536111448824},{"_id":"public/2018/05/05/译-Linux包管理基础：apt-yum-dnf-pkg/index.html","hash":"2c43a441a5e24d6bea637c10bb2d1cff5d428e14","modified":1536111448824},{"_id":"public/2018/04/11/Spring-Data-Redis/index.html","hash":"9f99699122b7f12d3092e610aaf8165a4068fbdc","modified":1536111448824},{"_id":"public/2018/04/11/《Spring实战》Spring中使用JDBC/index.html","hash":"3d1661f84e6e24ba0b78a778dd73d340b58e85ec","modified":1536111448825},{"_id":"public/2018/04/10/Hexo博客提交百度和谷歌收录/index.html","hash":"46a2aaf0c36343e63bba21f45dbd4b11df4ff9a4","modified":1536111448825},{"_id":"public/2018/04/10/指路人，还是引路人/index.html","hash":"1fee6a2541191ee3dd7e26c3d5012bf511e063b1","modified":1536111448825},{"_id":"public/2018/04/10/《Spring实战》Web中的Spring/index.html","hash":"8996d8f6a808c9dac6749d995d9b0076cafbd408","modified":1536111448825},{"_id":"public/2018/04/08/AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别/index.html","hash":"583b80b304a52cbdef8906fb35999e48cf966231","modified":1536111448826},{"_id":"public/2018/04/08/《Spring实战》搭建Spring-MVC/index.html","hash":"4d7dab65ebc1b424085466a1d863f1289db352c9","modified":1536111448826},{"_id":"public/2018/04/05/《Spring实战》面向切面的Spring/index.html","hash":"448ed1ea6294942a8beeb8bf99ead5cb00553b53","modified":1536111448826},{"_id":"public/2018/04/04/《Spring实战》高级装配/index.html","hash":"d50dfbac5057f02f5b4640e0388c43e2ae99369b","modified":1536111448826},{"_id":"public/2018/04/03/《Spring实战》装配bean/index.html","hash":"d8b75fdb7c5e41d8af014cfbdfdce167837a2b85","modified":1536111448827},{"_id":"public/2018/04/02/Java注解/index.html","hash":"4cf0f361a92d2cd103ac1ca7a77992a273cf7212","modified":1536111448827},{"_id":"public/2018/03/30/起风了/index.html","hash":"459c51372e6d4394bed85d7950f0a5780347607a","modified":1536111448827},{"_id":"public/2018/03/30/《三个火枪手》噗噗噗/index.html","hash":"4015db6b8f1a5695350e5734be7d17309e001992","modified":1536111448828},{"_id":"public/2018/03/29/事务/index.html","hash":"5d7e0cefd9f38b50ab80df86013b31bbd816893c","modified":1536111448828},{"_id":"public/2018/03/29/JDBC/index.html","hash":"c8b5dcd7e678e6603ea9acd7468385eaf997e489","modified":1536111448828},{"_id":"public/2018/03/28/基于scrapy分布式新闻评论爬虫/index.html","hash":"1fb34da38e1117116e26b9be8e33ab6577db1283","modified":1536111448828},{"_id":"public/2018/03/27/健身训练计划/index.html","hash":"6d1b26ed69beceb32f0b95f86e5807e7062d097a","modified":1536111448828},{"_id":"public/2018/03/26/Java网络编程/index.html","hash":"02f710b9cf84cefda1dd1f96818f290560f0d496","modified":1536111448829},{"_id":"public/2018/03/26/JSON/index.html","hash":"6814c8aa2103b3c20aeae5acc948e656c4cca711","modified":1536111448829},{"_id":"public/2018/03/23/正则表达式/index.html","hash":"827684a6f9a29cdcb5c68c07be2b5ded4588ac92","modified":1536111448830},{"_id":"public/2018/03/21/java 序列化(serialization)/index.html","hash":"43c543f365e8f12dcea03d242176c2a5b4f20915","modified":1536111448831},{"_id":"public/2018/03/21/字符集-字符编码/index.html","hash":"10e821d28697f7ef93e782f1e5dc9c0dbf284d21","modified":1536111448832},{"_id":"public/2018/03/21/javaIO流/index.html","hash":"1e1cc1f08484afd8afe1345992b8558f9750b8ec","modified":1536111448832},{"_id":"public/2018/03/20/Java流与文件/index.html","hash":"1826d7b62a25572c7141e0ebe1f69f4fd316e06f","modified":1536111448833},{"_id":"public/2018/03/19/python爬虫之新浪微博评论/index.html","hash":"f75b747160a3a7a159db77bb45a99e42f5c754a4","modified":1536111448833},{"_id":"public/2018/01/18/《提问的智慧》笔记/index.html","hash":"bb18b321e42aece5cab83152d5e4164b8d46c572","modified":1536111448833},{"_id":"public/2017/10/23/Maven初探/index.html","hash":"5b6b54879a5e546e169c795d5b6012de97e5603a","modified":1536111448834},{"_id":"public/2017/12/31/2017个人报告/index.html","hash":"160fab6c8037566a43cbbedd2b9326d5e82580f9","modified":1536111448834},{"_id":"public/2017/10/18/JVM/index.html","hash":"d8e47a939ad92915bbb669c137e0dfd7dc5bcceb","modified":1536111448834},{"_id":"public/2017/09/18/京东面经/index.html","hash":"0b0a4af916f71140f34dadd7a4afedbcd39c1183","modified":1536111448834},{"_id":"public/2017/09/18/华为面经/index.html","hash":"8156c0ac8d356548d9b007a88d9ea458cc61da93","modified":1536111448835},{"_id":"public/2017/09/16/去哪儿面经/index.html","hash":"75b4578e125dd8a71cf08532c232e14ef39e108d","modified":1536111448835},{"_id":"public/2017/08/10/java网络IO/index.html","hash":"8350576e346d063e7713895e7892b88bc5533406","modified":1536111448835},{"_id":"public/2017/07/18/动态规划/index.html","hash":"87ca68bc84f584f611d92f4f96558344549d2626","modified":1536111448835},{"_id":"public/archives/index.html","hash":"7331f23ef417e09a0d512b52ef54085e3db61cdc","modified":1536111448835},{"_id":"public/archives/page/2/index.html","hash":"8b89ea129850d0b74254a3f427f0666610a2d435","modified":1536111448835},{"_id":"public/archives/page/3/index.html","hash":"261f3e706f7cb95cd19bb9a4908eb281b6b67abe","modified":1536111448835},{"_id":"public/archives/page/4/index.html","hash":"f1b14394f2146bdd8ff196e7b8143cbf9775f8bc","modified":1536111448836},{"_id":"public/archives/2017/index.html","hash":"eec07ad585df230afe327445074b2ba613cec6c4","modified":1536111448836},{"_id":"public/archives/2017/07/index.html","hash":"295c97c50d70c694f66b263e708aa774cc2ddb22","modified":1536111448836},{"_id":"public/archives/2017/08/index.html","hash":"87412086d1bfa3ac9e8ed86498663e4a91619afb","modified":1536111448836},{"_id":"public/archives/2017/09/index.html","hash":"05f63ce2903c3eed95b72ea7d05ab24a325d1051","modified":1536111448836},{"_id":"public/archives/2017/12/index.html","hash":"c208b7aa52e821ac9b35c2b8b26f3985930e2b80","modified":1536111448837},{"_id":"public/archives/2017/10/index.html","hash":"1058440eca88dfbabddac4c9aaa54641e7dde6c8","modified":1536111448838},{"_id":"public/archives/2018/index.html","hash":"626cdaf7497af8ecb870b9c7efc81824c038ad84","modified":1536111448838},{"_id":"public/archives/2018/page/2/index.html","hash":"0952e1295026f7f6229e5de1aaf4a7a16564e4b2","modified":1536111448838},{"_id":"public/archives/2018/page/3/index.html","hash":"97680c89e79e94b146f16972e46bc85c226d522a","modified":1536111448838},{"_id":"public/archives/2018/01/index.html","hash":"6ecdaa7b70bb1976b5fcd684a9045f58cf6a6801","modified":1536111448839},{"_id":"public/archives/2018/03/index.html","hash":"db6d45d1d99ba815169a71fdfa474ccc90a718ef","modified":1536111448839},{"_id":"public/archives/2018/03/page/2/index.html","hash":"b4e0a2c78a26fc6f774acfe2d7ae7cd368490046","modified":1536111448839},{"_id":"public/archives/2018/04/index.html","hash":"fab19e4098e7d17fc7c5b1b26925972097f7a856","modified":1536111448840},{"_id":"public/archives/2018/04/page/2/index.html","hash":"cabdda56a502763e0abedb2dc7f7a98f9158991e","modified":1536111448840},{"_id":"public/archives/2018/05/index.html","hash":"397aec3ecc130e440ee935d8cdb8544be0452fa2","modified":1536111448840},{"_id":"public/archives/2018/09/index.html","hash":"c300d1ecb4578526a15716d9ab07fc09b2fcee2d","modified":1536111448840},{"_id":"public/index.html","hash":"dd8de4232b9a0f6f6513bd11ffb89832801f424d","modified":1536111528290},{"_id":"public/page/2/index.html","hash":"b75b6fad0a11b1d4ee3ae4ba2714b6cc09d63f18","modified":1536111448840},{"_id":"public/page/3/index.html","hash":"4d58ea76dba01bc38038f012da1a212c73974e36","modified":1536111448841},{"_id":"public/page/4/index.html","hash":"92ce88c37c13710211c151dc2c9fb155b8fd2cdf","modified":1536111448842},{"_id":"public/tags/2017/index.html","hash":"aa2ea4615d43572808bf0cbd1ce12bde1cc319c3","modified":1536111448842},{"_id":"public/tags/总结/index.html","hash":"961994c69ace259588db4b13383e490bfc1dda50","modified":1536111448842},{"_id":"public/tags/Hexo/index.html","hash":"06de17ed791bc002cfb073079afc223f37455f80","modified":1536111448842},{"_id":"public/tags/seo/index.html","hash":"9566a4a29b9e65a530b6cb3aa70ab8c23e3ffdf3","modified":1536111448843},{"_id":"public/tags/并发/index.html","hash":"7541ff25e67f47adfb64879e77db69419ecef8c3","modified":1536111448843},{"_id":"public/tags/jvm/index.html","hash":"b05854fc073da1220d6641e5aba261f90af35fce","modified":1536111448843},{"_id":"public/tags/java虚拟机/index.html","hash":"26ddea225e589f8eb99544424304fe0a13cffd00","modified":1536111448843},{"_id":"public/tags/泛型/index.html","hash":"033c38b60b6e84a1e1475117cf65e1ee2b764ef6","modified":1536111448844},{"_id":"public/tags/redis/index.html","hash":"3525f11aeb66f0bed58331ad531e19486f0fadc6","modified":1536111448845},{"_id":"public/tags/spring-data-redis/index.html","hash":"d34ae2f1fc34357311a5149b3c3286345731e3be","modified":1536111448845},{"_id":"public/tags/java/index.html","hash":"72cf04d741268319deb0113b704b0af6ddb0a02b","modified":1536111448846},{"_id":"public/tags/I-O/index.html","hash":"37082b510051a622b541f1e617d0307ae83f9392","modified":1536111448846},{"_id":"public/tags/流/index.html","hash":"db8d4df69c9d1115d77276807942d5b9bca4495e","modified":1536111448847},{"_id":"public/tags/爬虫/index.html","hash":"d9ebf34a21db4cc3e808ac3e795c4bdc830e5477","modified":1536111448847},{"_id":"public/tags/新浪微博/index.html","hash":"f52a134578cb28c2fd5574008560ed6bbb9e5836","modified":1536111448848},{"_id":"public/tags/Spring/index.html","hash":"0ba61b3530c10a1154217fc6b8e754114fd66a14","modified":1536111448848},{"_id":"public/tags/web/index.html","hash":"c47a6300d81b39b14ad9e0441a8e581af3736780","modified":1536111448848},{"_id":"public/tags/Spring-MVC/index.html","hash":"01d83fac47b1f6542e5023a194ddbaf0a49c466d","modified":1536111448848},{"_id":"public/tags/DI/index.html","hash":"ed98e8bbfe61b584c081c15e6b53352ccadc7960","modified":1536111448848},{"_id":"public/tags/随笔/index.html","hash":"b980060eb9bea3e90190bb70b0b581d104d29820","modified":1536111448849},{"_id":"public/tags/读书/index.html","hash":"ef232831f38c90405f6b218292ecc2cd6ec5d415","modified":1536111448849},{"_id":"public/tags/面经/index.html","hash":"595f28ae41a1c03805e385146a292414e757fa89","modified":1536111448850},{"_id":"public/tags/京东/index.html","hash":"c2f2ae045081775cff53623fc392241ec6c39fc3","modified":1536111448850},{"_id":"public/tags/健身/index.html","hash":"382815aeeccd8c79cd1126cf7454d5ce593354be","modified":1536111448850},{"_id":"public/tags/华为/index.html","hash":"ae096ca0e1931db2988721d6bebaef721a786f22","modified":1536111448850},{"_id":"public/tags/qunar/index.html","hash":"b7306f390fa6b885204db1df34a59f9383da123b","modified":1536111448850},{"_id":"public/tags/杂谈/index.html","hash":"fefdfe3cf323b871940d95d52c047f27e1643c64","modified":1536111448850},{"_id":"public/tags/music/index.html","hash":"d063d40e42d1d88b87629fdbf169336e6148a8d7","modified":1536111448851},{"_id":"public/tags/JSON/index.html","hash":"ef4220874614f1db23b1acb3c59d0680e86f6964","modified":1536111448851},{"_id":"public/tags/JDBC/index.html","hash":"b80cc79687214202305cc4ece73fc66d5e2d08c7","modified":1536111448851},{"_id":"public/tags/事务/index.html","hash":"d416f2ae0a742c5290fbe4efd59e23e2b3c51d71","modified":1536111448851},{"_id":"public/tags/注解/index.html","hash":"5bdced495fde6b30f504deef39fd4f41fd549858","modified":1536111448851},{"_id":"public/tags/transient/index.html","hash":"8317bc45bdb9d6bb22c22e60a223501d23d0d808","modified":1536111448852},{"_id":"public/tags/序列化/index.html","hash":"b3695672ca7878fb389d88974e02c0a61ebbc526","modified":1536111448852},{"_id":"public/tags/DataSource/index.html","hash":"24d57c0b213d3da117957dae920795425938cb39","modified":1536111448852},{"_id":"public/tags/aop/index.html","hash":"ef2317239bd95bae06fec94d7b95194e76fd6ed3","modified":1536111448852},{"_id":"public/tags/提问的智慧/index.html","hash":"479e4182b35a0bd3a087ca73f105619c177cf6ec","modified":1536111448852},{"_id":"public/tags/算法/index.html","hash":"9ac92b4cc35b2b89b7a41f821c4a960850a731e2","modified":1536111448852},{"_id":"public/tags/动态规划/index.html","hash":"b256525bb30af9391423be95af27c3bee3db20f4","modified":1536111448853},{"_id":"public/tags/字符编码/index.html","hash":"c95264fb1eb208bc70733d4b65f82ea30abda5c2","modified":1536111448853},{"_id":"public/tags/字符集/index.html","hash":"0c49fa711bccf943d86b603ab08c1b40323e3871","modified":1536111448853},{"_id":"public/tags/UTF-8/index.html","hash":"0d9e4c853bec5dc6db5d27deb41da863b6857144","modified":1536111448853},{"_id":"public/tags/UTF-16/index.html","hash":"eb56df35fc21db7f585d7999e2be0628edeaae63","modified":1536111448853},{"_id":"public/tags/Unicode/index.html","hash":"819c6b6d6b533cba74dc49cfab76daaf88feb523","modified":1536111448853},{"_id":"public/tags/linux/index.html","hash":"35946f33fded77f267eec6419e03e93083f87c54","modified":1536111448854},{"_id":"public/tags/yum/index.html","hash":"6fb8e62c24bc3ba5728067db9a8ef3319085ee8e","modified":1536111448854},{"_id":"public/tags/apt/index.html","hash":"b3d1ea4f21a9e8efd43c2560d82617f4effeb4c7","modified":1536111448854},{"_id":"public/tags/正则表达式/index.html","hash":"dfc938a24bb03444a2908504d6bd0c9b0c20e82a","modified":1536111448854},{"_id":"public/tags/Java网络编程/index.html","hash":"35bc6553d47cb5af5a75c56a1d65aa2480c73e50","modified":1536111448854},{"_id":"public/tags/socket/index.html","hash":"e6ecdd2c78000979f8a7e78771ebb5de0ef4b5b5","modified":1536111448854},{"_id":"public/tags/JavaMail/index.html","hash":"db7c70df4748aadaeaa98d33d46c56ab1c68d8d3","modified":1536111448854},{"_id":"public/tags/maven/index.html","hash":"211367d7ef729eca1e200001ae5d5d32634c2b52","modified":1536111448854},{"_id":"public/tags/Singleton/index.html","hash":"e0c92c5e9d9239c3540f2eb17680681e79787a21","modified":1536111448855},{"_id":"public/tags/scrapy/index.html","hash":"322b65ec3fe90009c0b0fcf152e1673ac3bc84a9","modified":1536111448855},{"_id":"public/tags/weibo/index.html","hash":"0bacca19b96f8a0c1dabd9184cd4a399fc031f61","modified":1536111448855},{"_id":"public/tags/news163/index.html","hash":"981e0c8c1ea5e0686cc6a5f2620bcc8e6774c65c","modified":1536111448855},{"_id":"public/tags/ifeng/index.html","hash":"5d9d718c2ca31a2dd3e77d9ca2bc7615c5c0c9a4","modified":1536111448856},{"_id":"public/tags/toutiao/index.html","hash":"a9273081f827d6d1aff248a93d70cee5cd98a217","modified":1536111448856},{"_id":"public/CNAME","hash":"6603339d7f6f87cb61ecc47a337a8d42ddf4beb0","modified":1536111448888},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1536111448888},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1536111448888},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1536111448888},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1536111448888},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1536111448889},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1536111448889},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1536111448889},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1536111448889},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1536111448889},{"_id":"public/img/avatar.jpeg","hash":"f8e8aa88cda7b08f672a0a0169c941b3fe631e84","modified":1536111448889},{"_id":"public/img/微信.jpg","hash":"dc7a23407344e711b0350373eb407f1f8a510141","modified":1536111448892},{"_id":"public/img/支付宝.jpg","hash":"c0200bad748139d71b529b300b9a55e109048374","modified":1536111448893},{"_id":"public/google4fd4ec061c03d6c6.html","hash":"65582bbcc41b6987f73a0ac118862cf302cbf80c","modified":1536111448893},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1536111449015},{"_id":"public/main.0cf68a.css","hash":"a96a01e5eceb40bfb3db6c3d7a6e2efec9016d26","modified":1536111449031},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1536111449042},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1536111449072}],"Category":[],"Data":[],"Page":[],"Post":[{"toc":true,"title":"2017 工作报告","date":"2017-12-31T06:08:14.000Z","_content":"\n一年又过去了，现在总结一下，看看有哪些计划完成，哪些未完成，以此来计划新的一年，达到更高的目标。\n\n<!--more-->\n**上一年计划：**\n- 上半学期\n![Alt text](blob:https://maxiang.io/b3ad9004-884c-40a1-a85e-17a6b209df88)\n计划：\n- [ ] 健身\n- [ ] 英语四级和6级\n- [ ] 数学建模\n- [ ] 课业\n- [ ] 学习声乐\n- [ ] 读书20本\n完成情况：\n- [ ] 体重62kg，相较上一年基本没有变化。\n- [ ] 英语6级 457分，及格\n- [ ] 2016吉林省数学建模2等奖\n- [ ] 2016-2017年 励志奖学金\n- [ ] 还是不会唱歌\n- [ ] 2017年已读书单：《史蒂夫乔布斯传》、《明朝那些事儿》、《群山回唱》、《和时间做朋友》、《白夜行》、《解忧杂货店》。在读：《教父》\n\n**不足：**\n1. 计划制定不好。只有上半年，下半年计划无。计划不具体，读什么书，健身成果未明确。\n2. 完成情况不及格\n\n## 2017回顾\n**时间线：**\n1. 春节回家火车上：在上一个寒假回家的火车上确定不考研，转而找工作。到目前为止这个决定是正确，在这一年准备工作以及实习的收获颇多。\n2. 寒假：在家里学习前端知识，回想当时为什么学习前端，一个是微信小程序刚出，了解到技术原理是html5，而当时觉得html5就是前端，于是去学习相关的知识。在慕课网上顺便找了几个课程学习了一下就算学了，可笑。浪费了一个寒假。\n3. 开学大概一个月：开始准备春招实习，首先是投华为，笔试没过。为什么没过，当时考完就问小薇感觉怎么样，小薇用了半个小时左右就写完了全部AC，自己前两个AC，最后一个只有0.7AC。然后就提交了。还有就是简历提交错误，没有按要求在自我介绍部分写上备注：实习。没有全身心投入春招，这种状态真的很像是安慰自己，麻痹自己说我努力了，能不能成都无怨无悔。这是狗屁，因为我真的没有重视，只是一味地学习，为了学而学。没有效率。然后海投各种公司被拒，每个都是笔试未通过。最后幸运的进入“借贷宝”实习。\n4. 期末考试：整个学期在课程上挺上心，最后结果也还好，都在八十以上，一些九十以上。最后能拿到励志也是对自己的一种肯定。\n5. 暑期实习：孤身一人来到北京实习，没有太多恐惧和孤单，倒是此时遇见了一些人对自己有了很大的帮助。一个是吴平平，平哥，我的直接领导及实习导师。川大研究生毕业，之前在阿里和去哪儿工作过。他作为一个小组的负责人的日常工作给了我很多启发，学习很多内容。**对事不对人**、**不管是谁的方案，好的就是对的，我的理解有问题就承认，没有不好意思**、**加班很正常，工作应该投入**。第二个是陶文祥，很有意思的一个人，重庆四川的人都确实比较独立，有自己的思想，独立，执行力强。在我身边的四川重庆人基本都有这些有点。陶文祥情商很高，跟他说话他都能对上话，一是知道得多，一个下大雨晚上和一位借贷宝同事拼车回家他跟那个人对重庆房价聊得很多，两人的交谈也很愉快，还有就是跟平哥一起回家的时候在各个点都能理解并交流。但最让我受益的还是他比较有执行力，他在哪儿都是学习，我们在吃饭走路坐公交回家都会在技术上进行交流。如果在学校和其他同学我是不会这么直率的。\n6.  回校秋招：这是我真正转折的时间，本来已经快心灰的我重新拾起信心，找到了工作。在大四开学后我几乎决定不再秋招，但我不死心。于是在借贷宝请假两周，回校进入就业服务队，接待企业。从外面实习回来的我更加珍惜在学校的时光，每天都充实的学习工作。就在要回借贷宝的前两天拿到了去那儿的offer。接着便是华为，京东的offer。于是辞去借贷宝的实习，回校专心学习准备入职去哪儿。\n7.  国庆回家：在拿到offer之后回家休息了两周，一周在老家，一周在厦门爸妈的身边。\n7.  去哪儿培训：在这儿学习了很多，这次的培训确实很值。进步很快，也学习很多东西和方法。一是看得技术书多了，不再盲目学习；二是实践多了，不是走马观花；最后是日常工作的交流和执行力得到提升，对很多事儿不再拖拉。\n\n总的来说今年的工作完成的比较及格，重要的工作都已完成。也找到了理想的工作。**但真正不好的点是家庭，这一年与家庭的交流更加的少。每周的电话只是例行公事的问问有没有吃饭，家里天气怎么样，身体好不好。能感觉得到每次电话的尴尬。**\n\n## 2018年——计划\n补足2017不好的地方，为3年后的出路做铺垫。\n**计划：**\n- [ ] 健身，体重增加到66kg。卧推45kg，深蹲90kg，引体一次20个，平板5分钟，硬拉60kg。腹肌6块。\n- [ ] 英语，能听说读，交两个以上美国朋友。看《生活大爆炸》全部\n- [ ] 毕业旅行，一次国外旅行或者国内自驾游，最少15天。\n- [ ] 毕业设计。达到优秀\n- [ ] 理财，完全自给自足，不再找家里要钱。年底给家里三万。\n- [ ] 交女朋友。\n- [ ] 平日书单：\n- 《教父》\n- 《三个火枪手》\n- 《不能承受生命之轻》\n- 《马丁伊登》\n- 《曾国藩家书》\n- 《雅致生活》\n- 《重新认识你自己》\n- 《影响力》\n- 《谈话的力量》\n- 《穷爸爸富爸爸》\n- 《别闹了，费曼先生》\n- 《阿加西自传》\n- [ ] 技术书单：\n- 《图解HTTP》\n- 《java 网络编程》\n- 《java核心技术 下》\n- 《effective Java》\n- 《python核心编程》\n- 待更新。。。\n\n","source":"_posts/2017个人报告.md","raw":"---\ntoc: true\ntitle: 2017 工作报告\ndate: 2017-12-31 14:08:14\ntags: [2017,总结]\n---\n\n一年又过去了，现在总结一下，看看有哪些计划完成，哪些未完成，以此来计划新的一年，达到更高的目标。\n\n<!--more-->\n**上一年计划：**\n- 上半学期\n![Alt text](blob:https://maxiang.io/b3ad9004-884c-40a1-a85e-17a6b209df88)\n计划：\n- [ ] 健身\n- [ ] 英语四级和6级\n- [ ] 数学建模\n- [ ] 课业\n- [ ] 学习声乐\n- [ ] 读书20本\n完成情况：\n- [ ] 体重62kg，相较上一年基本没有变化。\n- [ ] 英语6级 457分，及格\n- [ ] 2016吉林省数学建模2等奖\n- [ ] 2016-2017年 励志奖学金\n- [ ] 还是不会唱歌\n- [ ] 2017年已读书单：《史蒂夫乔布斯传》、《明朝那些事儿》、《群山回唱》、《和时间做朋友》、《白夜行》、《解忧杂货店》。在读：《教父》\n\n**不足：**\n1. 计划制定不好。只有上半年，下半年计划无。计划不具体，读什么书，健身成果未明确。\n2. 完成情况不及格\n\n## 2017回顾\n**时间线：**\n1. 春节回家火车上：在上一个寒假回家的火车上确定不考研，转而找工作。到目前为止这个决定是正确，在这一年准备工作以及实习的收获颇多。\n2. 寒假：在家里学习前端知识，回想当时为什么学习前端，一个是微信小程序刚出，了解到技术原理是html5，而当时觉得html5就是前端，于是去学习相关的知识。在慕课网上顺便找了几个课程学习了一下就算学了，可笑。浪费了一个寒假。\n3. 开学大概一个月：开始准备春招实习，首先是投华为，笔试没过。为什么没过，当时考完就问小薇感觉怎么样，小薇用了半个小时左右就写完了全部AC，自己前两个AC，最后一个只有0.7AC。然后就提交了。还有就是简历提交错误，没有按要求在自我介绍部分写上备注：实习。没有全身心投入春招，这种状态真的很像是安慰自己，麻痹自己说我努力了，能不能成都无怨无悔。这是狗屁，因为我真的没有重视，只是一味地学习，为了学而学。没有效率。然后海投各种公司被拒，每个都是笔试未通过。最后幸运的进入“借贷宝”实习。\n4. 期末考试：整个学期在课程上挺上心，最后结果也还好，都在八十以上，一些九十以上。最后能拿到励志也是对自己的一种肯定。\n5. 暑期实习：孤身一人来到北京实习，没有太多恐惧和孤单，倒是此时遇见了一些人对自己有了很大的帮助。一个是吴平平，平哥，我的直接领导及实习导师。川大研究生毕业，之前在阿里和去哪儿工作过。他作为一个小组的负责人的日常工作给了我很多启发，学习很多内容。**对事不对人**、**不管是谁的方案，好的就是对的，我的理解有问题就承认，没有不好意思**、**加班很正常，工作应该投入**。第二个是陶文祥，很有意思的一个人，重庆四川的人都确实比较独立，有自己的思想，独立，执行力强。在我身边的四川重庆人基本都有这些有点。陶文祥情商很高，跟他说话他都能对上话，一是知道得多，一个下大雨晚上和一位借贷宝同事拼车回家他跟那个人对重庆房价聊得很多，两人的交谈也很愉快，还有就是跟平哥一起回家的时候在各个点都能理解并交流。但最让我受益的还是他比较有执行力，他在哪儿都是学习，我们在吃饭走路坐公交回家都会在技术上进行交流。如果在学校和其他同学我是不会这么直率的。\n6.  回校秋招：这是我真正转折的时间，本来已经快心灰的我重新拾起信心，找到了工作。在大四开学后我几乎决定不再秋招，但我不死心。于是在借贷宝请假两周，回校进入就业服务队，接待企业。从外面实习回来的我更加珍惜在学校的时光，每天都充实的学习工作。就在要回借贷宝的前两天拿到了去那儿的offer。接着便是华为，京东的offer。于是辞去借贷宝的实习，回校专心学习准备入职去哪儿。\n7.  国庆回家：在拿到offer之后回家休息了两周，一周在老家，一周在厦门爸妈的身边。\n7.  去哪儿培训：在这儿学习了很多，这次的培训确实很值。进步很快，也学习很多东西和方法。一是看得技术书多了，不再盲目学习；二是实践多了，不是走马观花；最后是日常工作的交流和执行力得到提升，对很多事儿不再拖拉。\n\n总的来说今年的工作完成的比较及格，重要的工作都已完成。也找到了理想的工作。**但真正不好的点是家庭，这一年与家庭的交流更加的少。每周的电话只是例行公事的问问有没有吃饭，家里天气怎么样，身体好不好。能感觉得到每次电话的尴尬。**\n\n## 2018年——计划\n补足2017不好的地方，为3年后的出路做铺垫。\n**计划：**\n- [ ] 健身，体重增加到66kg。卧推45kg，深蹲90kg，引体一次20个，平板5分钟，硬拉60kg。腹肌6块。\n- [ ] 英语，能听说读，交两个以上美国朋友。看《生活大爆炸》全部\n- [ ] 毕业旅行，一次国外旅行或者国内自驾游，最少15天。\n- [ ] 毕业设计。达到优秀\n- [ ] 理财，完全自给自足，不再找家里要钱。年底给家里三万。\n- [ ] 交女朋友。\n- [ ] 平日书单：\n- 《教父》\n- 《三个火枪手》\n- 《不能承受生命之轻》\n- 《马丁伊登》\n- 《曾国藩家书》\n- 《雅致生活》\n- 《重新认识你自己》\n- 《影响力》\n- 《谈话的力量》\n- 《穷爸爸富爸爸》\n- 《别闹了，费曼先生》\n- 《阿加西自传》\n- [ ] 技术书单：\n- 《图解HTTP》\n- 《java 网络编程》\n- 《java核心技术 下》\n- 《effective Java》\n- 《python核心编程》\n- 待更新。。。\n\n","slug":"2017个人报告","published":1,"updated":"2018-08-13T14:28:27.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e3m00006k15vmpbmexx","content":"<p>一年又过去了，现在总结一下，看看有哪些计划完成，哪些未完成，以此来计划新的一年，达到更高的目标。</p>\n<a id=\"more\"></a>\n<p><strong>上一年计划：</strong></p>\n<ul>\n<li>上半学期<br><img src=\"blob:https://maxiang.io/b3ad9004-884c-40a1-a85e-17a6b209df88\" alt=\"Alt text\"><br>计划：</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 健身</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语四级和6级</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 数学建模</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 课业</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习声乐</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读书20本<br>完成情况：</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 体重62kg，相较上一年基本没有变化。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语6级 457分，及格</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2016吉林省数学建模2等奖</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2016-2017年 励志奖学金</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 还是不会唱歌</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2017年已读书单：《史蒂夫乔布斯传》、《明朝那些事儿》、《群山回唱》、《和时间做朋友》、《白夜行》、《解忧杂货店》。在读：《教父》</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ol>\n<li>计划制定不好。只有上半年，下半年计划无。计划不具体，读什么书，健身成果未明确。</li>\n<li>完成情况不及格</li>\n</ol>\n<h2 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h2><p><strong>时间线：</strong></p>\n<ol>\n<li>春节回家火车上：在上一个寒假回家的火车上确定不考研，转而找工作。到目前为止这个决定是正确，在这一年准备工作以及实习的收获颇多。</li>\n<li>寒假：在家里学习前端知识，回想当时为什么学习前端，一个是微信小程序刚出，了解到技术原理是html5，而当时觉得html5就是前端，于是去学习相关的知识。在慕课网上顺便找了几个课程学习了一下就算学了，可笑。浪费了一个寒假。</li>\n<li>开学大概一个月：开始准备春招实习，首先是投华为，笔试没过。为什么没过，当时考完就问小薇感觉怎么样，小薇用了半个小时左右就写完了全部AC，自己前两个AC，最后一个只有0.7AC。然后就提交了。还有就是简历提交错误，没有按要求在自我介绍部分写上备注：实习。没有全身心投入春招，这种状态真的很像是安慰自己，麻痹自己说我努力了，能不能成都无怨无悔。这是狗屁，因为我真的没有重视，只是一味地学习，为了学而学。没有效率。然后海投各种公司被拒，每个都是笔试未通过。最后幸运的进入“借贷宝”实习。</li>\n<li>期末考试：整个学期在课程上挺上心，最后结果也还好，都在八十以上，一些九十以上。最后能拿到励志也是对自己的一种肯定。</li>\n<li>暑期实习：孤身一人来到北京实习，没有太多恐惧和孤单，倒是此时遇见了一些人对自己有了很大的帮助。一个是吴平平，平哥，我的直接领导及实习导师。川大研究生毕业，之前在阿里和去哪儿工作过。他作为一个小组的负责人的日常工作给了我很多启发，学习很多内容。<strong>对事不对人</strong>、<strong>不管是谁的方案，好的就是对的，我的理解有问题就承认，没有不好意思</strong>、<strong>加班很正常，工作应该投入</strong>。第二个是陶文祥，很有意思的一个人，重庆四川的人都确实比较独立，有自己的思想，独立，执行力强。在我身边的四川重庆人基本都有这些有点。陶文祥情商很高，跟他说话他都能对上话，一是知道得多，一个下大雨晚上和一位借贷宝同事拼车回家他跟那个人对重庆房价聊得很多，两人的交谈也很愉快，还有就是跟平哥一起回家的时候在各个点都能理解并交流。但最让我受益的还是他比较有执行力，他在哪儿都是学习，我们在吃饭走路坐公交回家都会在技术上进行交流。如果在学校和其他同学我是不会这么直率的。</li>\n<li>回校秋招：这是我真正转折的时间，本来已经快心灰的我重新拾起信心，找到了工作。在大四开学后我几乎决定不再秋招，但我不死心。于是在借贷宝请假两周，回校进入就业服务队，接待企业。从外面实习回来的我更加珍惜在学校的时光，每天都充实的学习工作。就在要回借贷宝的前两天拿到了去那儿的offer。接着便是华为，京东的offer。于是辞去借贷宝的实习，回校专心学习准备入职去哪儿。</li>\n<li>国庆回家：在拿到offer之后回家休息了两周，一周在老家，一周在厦门爸妈的身边。</li>\n<li>去哪儿培训：在这儿学习了很多，这次的培训确实很值。进步很快，也学习很多东西和方法。一是看得技术书多了，不再盲目学习；二是实践多了，不是走马观花；最后是日常工作的交流和执行力得到提升，对很多事儿不再拖拉。</li>\n</ol>\n<p>总的来说今年的工作完成的比较及格，重要的工作都已完成。也找到了理想的工作。<strong>但真正不好的点是家庭，这一年与家庭的交流更加的少。每周的电话只是例行公事的问问有没有吃饭，家里天气怎么样，身体好不好。能感觉得到每次电话的尴尬。</strong></p>\n<h2 id=\"2018年——计划\"><a href=\"#2018年——计划\" class=\"headerlink\" title=\"2018年——计划\"></a>2018年——计划</h2><p>补足2017不好的地方，为3年后的出路做铺垫。<br><strong>计划：</strong></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 健身，体重增加到66kg。卧推45kg，深蹲90kg，引体一次20个，平板5分钟，硬拉60kg。腹肌6块。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语，能听说读，交两个以上美国朋友。看《生活大爆炸》全部</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 毕业旅行，一次国外旅行或者国内自驾游，最少15天。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 毕业设计。达到优秀</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 理财，完全自给自足，不再找家里要钱。年底给家里三万。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 交女朋友。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 平日书单：</li>\n<li>《教父》</li>\n<li>《三个火枪手》</li>\n<li>《不能承受生命之轻》</li>\n<li>《马丁伊登》</li>\n<li>《曾国藩家书》</li>\n<li>《雅致生活》</li>\n<li>《重新认识你自己》</li>\n<li>《影响力》</li>\n<li>《谈话的力量》</li>\n<li>《穷爸爸富爸爸》</li>\n<li>《别闹了，费曼先生》</li>\n<li>《阿加西自传》</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 技术书单：</li>\n<li>《图解HTTP》</li>\n<li>《java 网络编程》</li>\n<li>《java核心技术 下》</li>\n<li>《effective Java》</li>\n<li>《python核心编程》</li>\n<li>待更新。。。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>一年又过去了，现在总结一下，看看有哪些计划完成，哪些未完成，以此来计划新的一年，达到更高的目标。</p>","more":"<p><strong>上一年计划：</strong></p>\n<ul>\n<li>上半学期<br><img src=\"blob:https://maxiang.io/b3ad9004-884c-40a1-a85e-17a6b209df88\" alt=\"Alt text\"><br>计划：</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 健身</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语四级和6级</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 数学建模</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 课业</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 学习声乐</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 读书20本<br>完成情况：</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 体重62kg，相较上一年基本没有变化。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语6级 457分，及格</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2016吉林省数学建模2等奖</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2016-2017年 励志奖学金</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 还是不会唱歌</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 2017年已读书单：《史蒂夫乔布斯传》、《明朝那些事儿》、《群山回唱》、《和时间做朋友》、《白夜行》、《解忧杂货店》。在读：《教父》</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ol>\n<li>计划制定不好。只有上半年，下半年计划无。计划不具体，读什么书，健身成果未明确。</li>\n<li>完成情况不及格</li>\n</ol>\n<h2 id=\"2017回顾\"><a href=\"#2017回顾\" class=\"headerlink\" title=\"2017回顾\"></a>2017回顾</h2><p><strong>时间线：</strong></p>\n<ol>\n<li>春节回家火车上：在上一个寒假回家的火车上确定不考研，转而找工作。到目前为止这个决定是正确，在这一年准备工作以及实习的收获颇多。</li>\n<li>寒假：在家里学习前端知识，回想当时为什么学习前端，一个是微信小程序刚出，了解到技术原理是html5，而当时觉得html5就是前端，于是去学习相关的知识。在慕课网上顺便找了几个课程学习了一下就算学了，可笑。浪费了一个寒假。</li>\n<li>开学大概一个月：开始准备春招实习，首先是投华为，笔试没过。为什么没过，当时考完就问小薇感觉怎么样，小薇用了半个小时左右就写完了全部AC，自己前两个AC，最后一个只有0.7AC。然后就提交了。还有就是简历提交错误，没有按要求在自我介绍部分写上备注：实习。没有全身心投入春招，这种状态真的很像是安慰自己，麻痹自己说我努力了，能不能成都无怨无悔。这是狗屁，因为我真的没有重视，只是一味地学习，为了学而学。没有效率。然后海投各种公司被拒，每个都是笔试未通过。最后幸运的进入“借贷宝”实习。</li>\n<li>期末考试：整个学期在课程上挺上心，最后结果也还好，都在八十以上，一些九十以上。最后能拿到励志也是对自己的一种肯定。</li>\n<li>暑期实习：孤身一人来到北京实习，没有太多恐惧和孤单，倒是此时遇见了一些人对自己有了很大的帮助。一个是吴平平，平哥，我的直接领导及实习导师。川大研究生毕业，之前在阿里和去哪儿工作过。他作为一个小组的负责人的日常工作给了我很多启发，学习很多内容。<strong>对事不对人</strong>、<strong>不管是谁的方案，好的就是对的，我的理解有问题就承认，没有不好意思</strong>、<strong>加班很正常，工作应该投入</strong>。第二个是陶文祥，很有意思的一个人，重庆四川的人都确实比较独立，有自己的思想，独立，执行力强。在我身边的四川重庆人基本都有这些有点。陶文祥情商很高，跟他说话他都能对上话，一是知道得多，一个下大雨晚上和一位借贷宝同事拼车回家他跟那个人对重庆房价聊得很多，两人的交谈也很愉快，还有就是跟平哥一起回家的时候在各个点都能理解并交流。但最让我受益的还是他比较有执行力，他在哪儿都是学习，我们在吃饭走路坐公交回家都会在技术上进行交流。如果在学校和其他同学我是不会这么直率的。</li>\n<li>回校秋招：这是我真正转折的时间，本来已经快心灰的我重新拾起信心，找到了工作。在大四开学后我几乎决定不再秋招，但我不死心。于是在借贷宝请假两周，回校进入就业服务队，接待企业。从外面实习回来的我更加珍惜在学校的时光，每天都充实的学习工作。就在要回借贷宝的前两天拿到了去那儿的offer。接着便是华为，京东的offer。于是辞去借贷宝的实习，回校专心学习准备入职去哪儿。</li>\n<li>国庆回家：在拿到offer之后回家休息了两周，一周在老家，一周在厦门爸妈的身边。</li>\n<li>去哪儿培训：在这儿学习了很多，这次的培训确实很值。进步很快，也学习很多东西和方法。一是看得技术书多了，不再盲目学习；二是实践多了，不是走马观花；最后是日常工作的交流和执行力得到提升，对很多事儿不再拖拉。</li>\n</ol>\n<p>总的来说今年的工作完成的比较及格，重要的工作都已完成。也找到了理想的工作。<strong>但真正不好的点是家庭，这一年与家庭的交流更加的少。每周的电话只是例行公事的问问有没有吃饭，家里天气怎么样，身体好不好。能感觉得到每次电话的尴尬。</strong></p>\n<h2 id=\"2018年——计划\"><a href=\"#2018年——计划\" class=\"headerlink\" title=\"2018年——计划\"></a>2018年——计划</h2><p>补足2017不好的地方，为3年后的出路做铺垫。<br><strong>计划：</strong></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 健身，体重增加到66kg。卧推45kg，深蹲90kg，引体一次20个，平板5分钟，硬拉60kg。腹肌6块。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 英语，能听说读，交两个以上美国朋友。看《生活大爆炸》全部</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 毕业旅行，一次国外旅行或者国内自驾游，最少15天。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 毕业设计。达到优秀</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 理财，完全自给自足，不再找家里要钱。年底给家里三万。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 交女朋友。</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 平日书单：</li>\n<li>《教父》</li>\n<li>《三个火枪手》</li>\n<li>《不能承受生命之轻》</li>\n<li>《马丁伊登》</li>\n<li>《曾国藩家书》</li>\n<li>《雅致生活》</li>\n<li>《重新认识你自己》</li>\n<li>《影响力》</li>\n<li>《谈话的力量》</li>\n<li>《穷爸爸富爸爸》</li>\n<li>《别闹了，费曼先生》</li>\n<li>《阿加西自传》</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 技术书单：</li>\n<li>《图解HTTP》</li>\n<li>《java 网络编程》</li>\n<li>《java核心技术 下》</li>\n<li>《effective Java》</li>\n<li>《python核心编程》</li>\n<li>待更新。。。</li>\n</ul>"},{"toc":true,"title":"AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别","date":"2018-04-08T08:20:04.000Z","_content":"","source":"_posts/AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别.md","raw":"---\ntoc: true\ntitle: >-\n  AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别\ndate: 2018-04-08 16:20:04\ntags:\n---\n","slug":"AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别","published":1,"updated":"2018-08-13T14:28:27.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e3r00016k15s4z1olbc","content":"","site":{"data":{}},"excerpt":"","more":""},{"toc":true,"title":"Hexo博客提交百度和谷歌收录","date":"2018-04-10T13:18:18.000Z","_content":"\n写博客很辛苦，希望能够让更多人发现自己，需要先让两个最大的搜索引擎能够收录自己的网站。\n\n参考博客：\n[Hexo博客提交百度和Google收录](https://fengdi.org/2017/08/10/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95.html)\n[hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？](https://blog.csdn.net/sunshine940326/article/details/70936988)","source":"_posts/Hexo博客提交百度和谷歌收录.md","raw":"---\ntoc: true\ntitle: Hexo博客提交百度和谷歌收录\ndate: 2018-04-10 21:18:18\ntags: [Hexo,seo]\n---\n\n写博客很辛苦，希望能够让更多人发现自己，需要先让两个最大的搜索引擎能够收录自己的网站。\n\n参考博客：\n[Hexo博客提交百度和Google收录](https://fengdi.org/2017/08/10/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95.html)\n[hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？](https://blog.csdn.net/sunshine940326/article/details/70936988)","slug":"Hexo博客提交百度和谷歌收录","published":1,"updated":"2018-08-13T14:28:27.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e3w00036k153d09n04m","content":"<p>写博客很辛苦，希望能够让更多人发现自己，需要先让两个最大的搜索引擎能够收录自己的网站。</p>\n<p>参考博客：<br><a href=\"https://fengdi.org/2017/08/10/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95.html\" target=\"_blank\" rel=\"noopener\">Hexo博客提交百度和Google收录</a><br><a href=\"https://blog.csdn.net/sunshine940326/article/details/70936988\" target=\"_blank\" rel=\"noopener\">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>写博客很辛苦，希望能够让更多人发现自己，需要先让两个最大的搜索引擎能够收录自己的网站。</p>\n<p>参考博客：<br><a href=\"https://fengdi.org/2017/08/10/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95.html\" target=\"_blank\" rel=\"noopener\">Hexo博客提交百度和Google收录</a><br><a href=\"https://blog.csdn.net/sunshine940326/article/details/70936988\" target=\"_blank\" rel=\"noopener\">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</a></p>\n"},{"toc":true,"title":"Java并发系列","date":"2018-05-23T05:57:46.000Z","_content":"\n并发是Web开发内容中非常重要的一环。我在大三暑期实习是翻开过《Java并发编程实战》这本书，但是没看几页就搁置了，原因是太过理论读起来拗口。回校之后前两周强忍难受又看了4章，最后还是放弃了。于是谷歌Java并发系列教程，有幸发现cnblog一位博主liuxiaopeng的并发系列博客，在这里贴出来供大家学习。这个系列博客简单易懂，在初步了解Java并发很有用。\n\n- [Java 并发编程：核心理论](http://www.cnblogs.com/paddix/p/5374810.html)\n- [Java并发编程：Synchronized及其实现原理](http://www.cnblogs.com/paddix/p/5367116.html)\n- [Java并发编程：Synchronized底层优化（轻量级锁、偏向锁）](http://www.cnblogs.com/paddix/p/5405678.html)\n- [Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)](http://www.cnblogs.com/paddix/p/5381958.html)\n- [Java 并发编程：volatile的使用及其原理](http://www.cnblogs.com/paddix/p/5428507.html)\n\n","source":"_posts/Java并发系列.md","raw":"---\ntoc: true\ntitle: Java并发系列\ndate: 2018-05-23 13:57:46\ntags: [并发]\n---\n\n并发是Web开发内容中非常重要的一环。我在大三暑期实习是翻开过《Java并发编程实战》这本书，但是没看几页就搁置了，原因是太过理论读起来拗口。回校之后前两周强忍难受又看了4章，最后还是放弃了。于是谷歌Java并发系列教程，有幸发现cnblog一位博主liuxiaopeng的并发系列博客，在这里贴出来供大家学习。这个系列博客简单易懂，在初步了解Java并发很有用。\n\n- [Java 并发编程：核心理论](http://www.cnblogs.com/paddix/p/5374810.html)\n- [Java并发编程：Synchronized及其实现原理](http://www.cnblogs.com/paddix/p/5367116.html)\n- [Java并发编程：Synchronized底层优化（轻量级锁、偏向锁）](http://www.cnblogs.com/paddix/p/5405678.html)\n- [Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)](http://www.cnblogs.com/paddix/p/5381958.html)\n- [Java 并发编程：volatile的使用及其原理](http://www.cnblogs.com/paddix/p/5428507.html)\n\n","slug":"Java并发系列","published":1,"updated":"2018-08-13T14:28:27.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e3x00046k15wlpjykg1","content":"<p>并发是Web开发内容中非常重要的一环。我在大三暑期实习是翻开过《Java并发编程实战》这本书，但是没看几页就搁置了，原因是太过理论读起来拗口。回校之后前两周强忍难受又看了4章，最后还是放弃了。于是谷歌Java并发系列教程，有幸发现cnblog一位博主liuxiaopeng的并发系列博客，在这里贴出来供大家学习。这个系列博客简单易懂，在初步了解Java并发很有用。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5374810.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：核心理论</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5367116.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：Synchronized及其实现原理</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5405678.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：Synchronized底层优化（轻量级锁、偏向锁）</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5381958.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5428507.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：volatile的使用及其原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>并发是Web开发内容中非常重要的一环。我在大三暑期实习是翻开过《Java并发编程实战》这本书，但是没看几页就搁置了，原因是太过理论读起来拗口。回校之后前两周强忍难受又看了4章，最后还是放弃了。于是谷歌Java并发系列教程，有幸发现cnblog一位博主liuxiaopeng的并发系列博客，在这里贴出来供大家学习。这个系列博客简单易懂，在初步了解Java并发很有用。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5374810.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：核心理论</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5367116.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：Synchronized及其实现原理</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5405678.html\" target=\"_blank\" rel=\"noopener\">Java并发编程：Synchronized底层优化（轻量级锁、偏向锁）</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5381958.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)</a></li>\n<li><a href=\"http://www.cnblogs.com/paddix/p/5428507.html\" target=\"_blank\" rel=\"noopener\">Java 并发编程：volatile的使用及其原理</a></li>\n</ul>\n"},{"toc":true,"title":"JVM","date":"2017-10-18T06:12:54.000Z","_content":"\n### 一、类初始化\n我们常说的类初始化分为三个阶段，类加载、连接、和初始化。类加载把class文件载入内存，类连接进行内存分配、初始化为静态变量赋值。\n<!--more-->\n#### 类的加载\n类的加载指将类的class文件载入内存，并为之创建一个java.lang.Class对象。可以从下面几种来源加载类。\n- 本地文件系统\n- JAR包\n- 网络\n- 把一个java文件动态编译，并执行加载\n类加载完成后，JVM就为其生成一个java.lang.Class对象，通过这个对象就可操作这个类。\n\n#### 类的连接\n将类的二进制文件合并到jre中，连接阶段会为变量分配内存并赋初始值。\n\n#### 类初始化\n<font color=\"red\">**在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量的语句，和静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类中的先后顺序来依次执行他们。**</font>\n类的初始化时机：\n1. **主动使用**：（6种情况）\n\t- 创建类的实例 ` new Test() `\n\t- 访问某个类或接口的静态变量，或者对该静态变量赋值\n\t\t- ```int b = Test.a; Test.b = a; ```\n\t- 调用类的静态方法\n\t- 反射\n\t- 初始化一个类的子类，那么这个类会先被初始化\n\t- java虚拟机启动时被标明为启动类的类\n\n2. 除了以上6种情况为**主动使用**，其余使用java类的方式都被看做是对类的**被动使用**，都不会导致类的初始化。\n\n#### 接口的特殊性\n当java虚拟机初始化一个类时，会先初始化它的父类，但是**这条规则不适用于接口**。\n- <font color=\"red\">在初始化一个类时，并不会初始化它实现的接口</font>\n- <font color=\"red\">在初始化一个接口时，并不会初始化它的父接口</font>\n\n因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。\n#### final类型的静态变量\n- 如果一个静态变量的值是一个编译时的常量，就不会对类型进行初始化（类的static块不执行）\n- 如果一个静态变量的值是一个非编译时的变量，即只有运行时会有确定的初始值，则就会对这个类型进行初始化（类的static块执行）\n\n#### ClassLoader\nClassLoader类的loadClass()知识加载类，不初始化类。\n\n### 二、类加载器\n类加载器负责将.class文件加载到内存，并为其创建java.lang.Class对象，这个对象就代表这个类。\n在java中，通过包名+类名来唯一标识一个类，而在JVM中，要用类加载器实例+包名+雷鸣 来唯一标识一个类。\n在JVM中，类加载器是层次结构的，从上当下依次为根加载器（BootStrapLoader）、扩展类加载器（ExtentionLoader）、应用类加载器（ApplicaitonLoader）和用户自定义类加载器。\n#### 1. 根加载器（BootStrapLoader）\n负责加载JAVA核心类，底层由C/C++实现，不是java.lang.Classloader的子类\n#### 2. 扩展类加载器（ExtentionLoader）\n负责加载来自JRE的扩展目录（\\jre\\lib\\ext\\ 或者 java.ext.dirs 系统属性指定的目录）中JAR包中的类，，我们也可以将自己的类放到这个目录作为扩展类加载。\n#### 系统类加载器\n也称为应用类加载器，负责加载下面几种类，\n- JVM启动时加载来自 java命令的 -classpath选项的JAR包\n- java.lang.path系统属性\n- CLASSPATH环境变量\n\n#### 类的加载机制\n- 全盘负责\n当一个类的加载器加载一个CLass时，改class依赖的其他class也由这个加载器加载。\n- 父类委托\n\nJVM加载一个Class时，会先使用其父类加载器来加载，所以一直迭代到最上层的加载器，一个类会最先由BootstrapLoader尝试加载，如果失败则由extensionLoader尝试加载，再失败则由systemLoader尝试加载，最后还失败则由自定义的类加载器来加载，如果依然失败，就会抛出错误。 父类委托机制可以防止类被重复加载，也更安全。\n![Alt text](./1503387415981.png)\n但是Tomcat采用了完全相反的机制，先通过默认类加载器加载，失败再找父类加载器加载。\n![Alt text](./1503387471723.png)\n#### 缓存机制\n缓存机制保证加载过的Class被缓存起来，当家在新类时，先进缓存查询是否已经加载，只有缓存中没有的时候才进行加载，这样会显著提高性能。\n\n\n\n\n\n\n","source":"_posts/JVM.md","raw":"---\ntoc: true\ntitle: JVM\ndate: 2017-10-18 14:12:54\ntags: [jvm,java虚拟机]\n---\n\n### 一、类初始化\n我们常说的类初始化分为三个阶段，类加载、连接、和初始化。类加载把class文件载入内存，类连接进行内存分配、初始化为静态变量赋值。\n<!--more-->\n#### 类的加载\n类的加载指将类的class文件载入内存，并为之创建一个java.lang.Class对象。可以从下面几种来源加载类。\n- 本地文件系统\n- JAR包\n- 网络\n- 把一个java文件动态编译，并执行加载\n类加载完成后，JVM就为其生成一个java.lang.Class对象，通过这个对象就可操作这个类。\n\n#### 类的连接\n将类的二进制文件合并到jre中，连接阶段会为变量分配内存并赋初始值。\n\n#### 类初始化\n<font color=\"red\">**在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量的语句，和静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类中的先后顺序来依次执行他们。**</font>\n类的初始化时机：\n1. **主动使用**：（6种情况）\n\t- 创建类的实例 ` new Test() `\n\t- 访问某个类或接口的静态变量，或者对该静态变量赋值\n\t\t- ```int b = Test.a; Test.b = a; ```\n\t- 调用类的静态方法\n\t- 反射\n\t- 初始化一个类的子类，那么这个类会先被初始化\n\t- java虚拟机启动时被标明为启动类的类\n\n2. 除了以上6种情况为**主动使用**，其余使用java类的方式都被看做是对类的**被动使用**，都不会导致类的初始化。\n\n#### 接口的特殊性\n当java虚拟机初始化一个类时，会先初始化它的父类，但是**这条规则不适用于接口**。\n- <font color=\"red\">在初始化一个类时，并不会初始化它实现的接口</font>\n- <font color=\"red\">在初始化一个接口时，并不会初始化它的父接口</font>\n\n因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。\n#### final类型的静态变量\n- 如果一个静态变量的值是一个编译时的常量，就不会对类型进行初始化（类的static块不执行）\n- 如果一个静态变量的值是一个非编译时的变量，即只有运行时会有确定的初始值，则就会对这个类型进行初始化（类的static块执行）\n\n#### ClassLoader\nClassLoader类的loadClass()知识加载类，不初始化类。\n\n### 二、类加载器\n类加载器负责将.class文件加载到内存，并为其创建java.lang.Class对象，这个对象就代表这个类。\n在java中，通过包名+类名来唯一标识一个类，而在JVM中，要用类加载器实例+包名+雷鸣 来唯一标识一个类。\n在JVM中，类加载器是层次结构的，从上当下依次为根加载器（BootStrapLoader）、扩展类加载器（ExtentionLoader）、应用类加载器（ApplicaitonLoader）和用户自定义类加载器。\n#### 1. 根加载器（BootStrapLoader）\n负责加载JAVA核心类，底层由C/C++实现，不是java.lang.Classloader的子类\n#### 2. 扩展类加载器（ExtentionLoader）\n负责加载来自JRE的扩展目录（\\jre\\lib\\ext\\ 或者 java.ext.dirs 系统属性指定的目录）中JAR包中的类，，我们也可以将自己的类放到这个目录作为扩展类加载。\n#### 系统类加载器\n也称为应用类加载器，负责加载下面几种类，\n- JVM启动时加载来自 java命令的 -classpath选项的JAR包\n- java.lang.path系统属性\n- CLASSPATH环境变量\n\n#### 类的加载机制\n- 全盘负责\n当一个类的加载器加载一个CLass时，改class依赖的其他class也由这个加载器加载。\n- 父类委托\n\nJVM加载一个Class时，会先使用其父类加载器来加载，所以一直迭代到最上层的加载器，一个类会最先由BootstrapLoader尝试加载，如果失败则由extensionLoader尝试加载，再失败则由systemLoader尝试加载，最后还失败则由自定义的类加载器来加载，如果依然失败，就会抛出错误。 父类委托机制可以防止类被重复加载，也更安全。\n![Alt text](./1503387415981.png)\n但是Tomcat采用了完全相反的机制，先通过默认类加载器加载，失败再找父类加载器加载。\n![Alt text](./1503387471723.png)\n#### 缓存机制\n缓存机制保证加载过的Class被缓存起来，当家在新类时，先进缓存查询是否已经加载，只有缓存中没有的时候才进行加载，这样会显著提高性能。\n\n\n\n\n\n\n","slug":"JVM","published":1,"updated":"2018-08-13T14:28:27.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e3z00056k15jdq6jrxv","content":"<h3 id=\"一、类初始化\"><a href=\"#一、类初始化\" class=\"headerlink\" title=\"一、类初始化\"></a>一、类初始化</h3><p>我们常说的类初始化分为三个阶段，类加载、连接、和初始化。类加载把class文件载入内存，类连接进行内存分配、初始化为静态变量赋值。<br><a id=\"more\"></a></p>\n<h4 id=\"类的加载\"><a href=\"#类的加载\" class=\"headerlink\" title=\"类的加载\"></a>类的加载</h4><p>类的加载指将类的class文件载入内存，并为之创建一个java.lang.Class对象。可以从下面几种来源加载类。</p>\n<ul>\n<li>本地文件系统</li>\n<li>JAR包</li>\n<li>网络</li>\n<li>把一个java文件动态编译，并执行加载<br>类加载完成后，JVM就为其生成一个java.lang.Class对象，通过这个对象就可操作这个类。</li>\n</ul>\n<h4 id=\"类的连接\"><a href=\"#类的连接\" class=\"headerlink\" title=\"类的连接\"></a>类的连接</h4><p>将类的二进制文件合并到jre中，连接阶段会为变量分配内存并赋初始值。</p>\n<h4 id=\"类初始化\"><a href=\"#类初始化\" class=\"headerlink\" title=\"类初始化\"></a>类初始化</h4><font color=\"red\"><strong>在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量的语句，和静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类中的先后顺序来依次执行他们。</strong></font><br>类的初始化时机：<br>1. <strong>主动使用</strong>：（6种情况）<br>    - 创建类的实例 <code>new Test()</code><br>    - 访问某个类或接口的静态变量，或者对该静态变量赋值<br>        - <code>int b = Test.a; Test.b = a;</code><br>    - 调用类的静态方法<br>    - 反射<br>    - 初始化一个类的子类，那么这个类会先被初始化<br>    - java虚拟机启动时被标明为启动类的类<br><br>2. 除了以上6种情况为<strong>主动使用</strong>，其余使用java类的方式都被看做是对类的<strong>被动使用</strong>，都不会导致类的初始化。<br><br>#### 接口的特殊性<br>当java虚拟机初始化一个类时，会先初始化它的父类，但是<strong>这条规则不适用于接口</strong>。<br>- <font color=\"red\">在初始化一个类时，并不会初始化它实现的接口</font><br>- <font color=\"red\">在初始化一个接口时，并不会初始化它的父接口</font>\n\n<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p>\n<h4 id=\"final类型的静态变量\"><a href=\"#final类型的静态变量\" class=\"headerlink\" title=\"final类型的静态变量\"></a>final类型的静态变量</h4><ul>\n<li>如果一个静态变量的值是一个编译时的常量，就不会对类型进行初始化（类的static块不执行）</li>\n<li>如果一个静态变量的值是一个非编译时的变量，即只有运行时会有确定的初始值，则就会对这个类型进行初始化（类的static块执行）</li>\n</ul>\n<h4 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h4><p>ClassLoader类的loadClass()知识加载类，不初始化类。</p>\n<h3 id=\"二、类加载器\"><a href=\"#二、类加载器\" class=\"headerlink\" title=\"二、类加载器\"></a>二、类加载器</h3><p>类加载器负责将.class文件加载到内存，并为其创建java.lang.Class对象，这个对象就代表这个类。<br>在java中，通过包名+类名来唯一标识一个类，而在JVM中，要用类加载器实例+包名+雷鸣 来唯一标识一个类。<br>在JVM中，类加载器是层次结构的，从上当下依次为根加载器（BootStrapLoader）、扩展类加载器（ExtentionLoader）、应用类加载器（ApplicaitonLoader）和用户自定义类加载器。</p>\n<h4 id=\"1-根加载器（BootStrapLoader）\"><a href=\"#1-根加载器（BootStrapLoader）\" class=\"headerlink\" title=\"1. 根加载器（BootStrapLoader）\"></a>1. 根加载器（BootStrapLoader）</h4><p>负责加载JAVA核心类，底层由C/C++实现，不是java.lang.Classloader的子类</p>\n<h4 id=\"2-扩展类加载器（ExtentionLoader）\"><a href=\"#2-扩展类加载器（ExtentionLoader）\" class=\"headerlink\" title=\"2. 扩展类加载器（ExtentionLoader）\"></a>2. 扩展类加载器（ExtentionLoader）</h4><p>负责加载来自JRE的扩展目录（\\jre\\lib\\ext\\ 或者 java.ext.dirs 系统属性指定的目录）中JAR包中的类，，我们也可以将自己的类放到这个目录作为扩展类加载。</p>\n<h4 id=\"系统类加载器\"><a href=\"#系统类加载器\" class=\"headerlink\" title=\"系统类加载器\"></a>系统类加载器</h4><p>也称为应用类加载器，负责加载下面几种类，</p>\n<ul>\n<li>JVM启动时加载来自 java命令的 -classpath选项的JAR包</li>\n<li>java.lang.path系统属性</li>\n<li>CLASSPATH环境变量</li>\n</ul>\n<h4 id=\"类的加载机制\"><a href=\"#类的加载机制\" class=\"headerlink\" title=\"类的加载机制\"></a>类的加载机制</h4><ul>\n<li>全盘负责<br>当一个类的加载器加载一个CLass时，改class依赖的其他class也由这个加载器加载。</li>\n<li>父类委托</li>\n</ul>\n<p>JVM加载一个Class时，会先使用其父类加载器来加载，所以一直迭代到最上层的加载器，一个类会最先由BootstrapLoader尝试加载，如果失败则由extensionLoader尝试加载，再失败则由systemLoader尝试加载，最后还失败则由自定义的类加载器来加载，如果依然失败，就会抛出错误。 父类委托机制可以防止类被重复加载，也更安全。<br><img src=\"./1503387415981.png\" alt=\"Alt text\"><br>但是Tomcat采用了完全相反的机制，先通过默认类加载器加载，失败再找父类加载器加载。<br><img src=\"./1503387471723.png\" alt=\"Alt text\"></p>\n<h4 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h4><p>缓存机制保证加载过的Class被缓存起来，当家在新类时，先进缓存查询是否已经加载，只有缓存中没有的时候才进行加载，这样会显著提高性能。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、类初始化\"><a href=\"#一、类初始化\" class=\"headerlink\" title=\"一、类初始化\"></a>一、类初始化</h3><p>我们常说的类初始化分为三个阶段，类加载、连接、和初始化。类加载把class文件载入内存，类连接进行内存分配、初始化为静态变量赋值。<br>","more":"</p>\n<h4 id=\"类的加载\"><a href=\"#类的加载\" class=\"headerlink\" title=\"类的加载\"></a>类的加载</h4><p>类的加载指将类的class文件载入内存，并为之创建一个java.lang.Class对象。可以从下面几种来源加载类。</p>\n<ul>\n<li>本地文件系统</li>\n<li>JAR包</li>\n<li>网络</li>\n<li>把一个java文件动态编译，并执行加载<br>类加载完成后，JVM就为其生成一个java.lang.Class对象，通过这个对象就可操作这个类。</li>\n</ul>\n<h4 id=\"类的连接\"><a href=\"#类的连接\" class=\"headerlink\" title=\"类的连接\"></a>类的连接</h4><p>将类的二进制文件合并到jre中，连接阶段会为变量分配内存并赋初始值。</p>\n<h4 id=\"类初始化\"><a href=\"#类初始化\" class=\"headerlink\" title=\"类初始化\"></a>类初始化</h4><font color=\"red\"><strong>在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量的语句，和静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类中的先后顺序来依次执行他们。</strong></font><br>类的初始化时机：<br>1. <strong>主动使用</strong>：（6种情况）<br>    - 创建类的实例 <code>new Test()</code><br>    - 访问某个类或接口的静态变量，或者对该静态变量赋值<br>        - <code>int b = Test.a; Test.b = a;</code><br>    - 调用类的静态方法<br>    - 反射<br>    - 初始化一个类的子类，那么这个类会先被初始化<br>    - java虚拟机启动时被标明为启动类的类<br><br>2. 除了以上6种情况为<strong>主动使用</strong>，其余使用java类的方式都被看做是对类的<strong>被动使用</strong>，都不会导致类的初始化。<br><br>#### 接口的特殊性<br>当java虚拟机初始化一个类时，会先初始化它的父类，但是<strong>这条规则不适用于接口</strong>。<br>- <font color=\"red\">在初始化一个类时，并不会初始化它实现的接口</font><br>- <font color=\"red\">在初始化一个接口时，并不会初始化它的父接口</font>\n\n<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p>\n<h4 id=\"final类型的静态变量\"><a href=\"#final类型的静态变量\" class=\"headerlink\" title=\"final类型的静态变量\"></a>final类型的静态变量</h4><ul>\n<li>如果一个静态变量的值是一个编译时的常量，就不会对类型进行初始化（类的static块不执行）</li>\n<li>如果一个静态变量的值是一个非编译时的变量，即只有运行时会有确定的初始值，则就会对这个类型进行初始化（类的static块执行）</li>\n</ul>\n<h4 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h4><p>ClassLoader类的loadClass()知识加载类，不初始化类。</p>\n<h3 id=\"二、类加载器\"><a href=\"#二、类加载器\" class=\"headerlink\" title=\"二、类加载器\"></a>二、类加载器</h3><p>类加载器负责将.class文件加载到内存，并为其创建java.lang.Class对象，这个对象就代表这个类。<br>在java中，通过包名+类名来唯一标识一个类，而在JVM中，要用类加载器实例+包名+雷鸣 来唯一标识一个类。<br>在JVM中，类加载器是层次结构的，从上当下依次为根加载器（BootStrapLoader）、扩展类加载器（ExtentionLoader）、应用类加载器（ApplicaitonLoader）和用户自定义类加载器。</p>\n<h4 id=\"1-根加载器（BootStrapLoader）\"><a href=\"#1-根加载器（BootStrapLoader）\" class=\"headerlink\" title=\"1. 根加载器（BootStrapLoader）\"></a>1. 根加载器（BootStrapLoader）</h4><p>负责加载JAVA核心类，底层由C/C++实现，不是java.lang.Classloader的子类</p>\n<h4 id=\"2-扩展类加载器（ExtentionLoader）\"><a href=\"#2-扩展类加载器（ExtentionLoader）\" class=\"headerlink\" title=\"2. 扩展类加载器（ExtentionLoader）\"></a>2. 扩展类加载器（ExtentionLoader）</h4><p>负责加载来自JRE的扩展目录（\\jre\\lib\\ext\\ 或者 java.ext.dirs 系统属性指定的目录）中JAR包中的类，，我们也可以将自己的类放到这个目录作为扩展类加载。</p>\n<h4 id=\"系统类加载器\"><a href=\"#系统类加载器\" class=\"headerlink\" title=\"系统类加载器\"></a>系统类加载器</h4><p>也称为应用类加载器，负责加载下面几种类，</p>\n<ul>\n<li>JVM启动时加载来自 java命令的 -classpath选项的JAR包</li>\n<li>java.lang.path系统属性</li>\n<li>CLASSPATH环境变量</li>\n</ul>\n<h4 id=\"类的加载机制\"><a href=\"#类的加载机制\" class=\"headerlink\" title=\"类的加载机制\"></a>类的加载机制</h4><ul>\n<li>全盘负责<br>当一个类的加载器加载一个CLass时，改class依赖的其他class也由这个加载器加载。</li>\n<li>父类委托</li>\n</ul>\n<p>JVM加载一个Class时，会先使用其父类加载器来加载，所以一直迭代到最上层的加载器，一个类会最先由BootstrapLoader尝试加载，如果失败则由extensionLoader尝试加载，再失败则由systemLoader尝试加载，最后还失败则由自定义的类加载器来加载，如果依然失败，就会抛出错误。 父类委托机制可以防止类被重复加载，也更安全。<br><img src=\"./1503387415981.png\" alt=\"Alt text\"><br>但是Tomcat采用了完全相反的机制，先通过默认类加载器加载，失败再找父类加载器加载。<br><img src=\"./1503387471723.png\" alt=\"Alt text\"></p>\n<h4 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h4><p>缓存机制保证加载过的Class被缓存起来，当家在新类时，先进缓存查询是否已经加载，只有缓存中没有的时候才进行加载，这样会显著提高性能。</p>"},{"toc":true,"title":"Java泛型","date":"2018-05-18T04:05:07.000Z","_content":"\n[java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一](https://blog.csdn.net/s10461/article/details/53941091)","source":"_posts/Java泛型.md","raw":"---\ntoc: true\ntitle: Java泛型\ndate: 2018-05-18 12:05:07\ntags: [泛型]\n---\n\n[java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一](https://blog.csdn.net/s10461/article/details/53941091)","slug":"Java泛型","published":1,"updated":"2018-08-13T14:28:27.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4000076k15oous8xqq","content":"<p><a href=\"https://blog.csdn.net/s10461/article/details/53941091\" target=\"_blank\" rel=\"noopener\">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/s10461/article/details/53941091\" target=\"_blank\" rel=\"noopener\">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>\n"},{"toc":true,"title":"Java 流与文件","date":"2018-03-20T14:44:15.000Z","_content":"\n之前学过很多次流，但是用得少，忘得快，于是今天看《java核心技术 卷二》重新看了一遍,涉及到的内容甚多。\n<!--more-->\n## 一、java IO流\n[java IO流](http://cap-ljf.top/2018/03/21/javaIO%E6%B5%81/)\n\n## 二、字符集\n[字符集](http://cap-ljf.top/2018/03/21/%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/)\n\n## 三、序列化、反序列化\n[序列化](http://cap-ljf.top/2018/03/21/java%20%E5%BA%8F%E5%88%97%E5%8C%96(serialization)\n\n## 四、java 7 Files、Path类\n\n## 五、 channel\n\n## 六、java正则\n\n","source":"_posts/Java流与文件.md","raw":"---\ntoc: true\ntitle: Java 流与文件\ndate: 2018-03-20 22:44:15\ntags:\n---\n\n之前学过很多次流，但是用得少，忘得快，于是今天看《java核心技术 卷二》重新看了一遍,涉及到的内容甚多。\n<!--more-->\n## 一、java IO流\n[java IO流](http://cap-ljf.top/2018/03/21/javaIO%E6%B5%81/)\n\n## 二、字符集\n[字符集](http://cap-ljf.top/2018/03/21/%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/)\n\n## 三、序列化、反序列化\n[序列化](http://cap-ljf.top/2018/03/21/java%20%E5%BA%8F%E5%88%97%E5%8C%96(serialization)\n\n## 四、java 7 Files、Path类\n\n## 五、 channel\n\n## 六、java正则\n\n","slug":"Java流与文件","published":1,"updated":"2018-08-13T14:28:27.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4200086k15i7ynuj6t","content":"<p>之前学过很多次流，但是用得少，忘得快，于是今天看《java核心技术 卷二》重新看了一遍,涉及到的内容甚多。<br><a id=\"more\"></a></p>\n<h2 id=\"一、java-IO流\"><a href=\"#一、java-IO流\" class=\"headerlink\" title=\"一、java IO流\"></a>一、java IO流</h2><p><a href=\"http://cap-ljf.top/2018/03/21/javaIO%E6%B5%81/\">java IO流</a></p>\n<h2 id=\"二、字符集\"><a href=\"#二、字符集\" class=\"headerlink\" title=\"二、字符集\"></a>二、字符集</h2><p><a href=\"http://cap-ljf.top/2018/03/21/%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/\">字符集</a></p>\n<h2 id=\"三、序列化、反序列化\"><a href=\"#三、序列化、反序列化\" class=\"headerlink\" title=\"三、序列化、反序列化\"></a>三、序列化、反序列化</h2><p><a href=\"http://cap-ljf.top/2018/03/21/java%20%E5%BA%8F%E5%88%97%E5%8C%96(serialization\">序列化</a></p>\n<h2 id=\"四、java-7-Files、Path类\"><a href=\"#四、java-7-Files、Path类\" class=\"headerlink\" title=\"四、java 7 Files、Path类\"></a>四、java 7 Files、Path类</h2><h2 id=\"五、-channel\"><a href=\"#五、-channel\" class=\"headerlink\" title=\"五、 channel\"></a>五、 channel</h2><h2 id=\"六、java正则\"><a href=\"#六、java正则\" class=\"headerlink\" title=\"六、java正则\"></a>六、java正则</h2>","site":{"data":{}},"excerpt":"<p>之前学过很多次流，但是用得少，忘得快，于是今天看《java核心技术 卷二》重新看了一遍,涉及到的内容甚多。<br>","more":"</p>\n<h2 id=\"一、java-IO流\"><a href=\"#一、java-IO流\" class=\"headerlink\" title=\"一、java IO流\"></a>一、java IO流</h2><p><a href=\"http://cap-ljf.top/2018/03/21/javaIO%E6%B5%81/\">java IO流</a></p>\n<h2 id=\"二、字符集\"><a href=\"#二、字符集\" class=\"headerlink\" title=\"二、字符集\"></a>二、字符集</h2><p><a href=\"http://cap-ljf.top/2018/03/21/%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/\">字符集</a></p>\n<h2 id=\"三、序列化、反序列化\"><a href=\"#三、序列化、反序列化\" class=\"headerlink\" title=\"三、序列化、反序列化\"></a>三、序列化、反序列化</h2><p><a href=\"http://cap-ljf.top/2018/03/21/java%20%E5%BA%8F%E5%88%97%E5%8C%96(serialization\">序列化</a></p>\n<h2 id=\"四、java-7-Files、Path类\"><a href=\"#四、java-7-Files、Path类\" class=\"headerlink\" title=\"四、java 7 Files、Path类\"></a>四、java 7 Files、Path类</h2><h2 id=\"五、-channel\"><a href=\"#五、-channel\" class=\"headerlink\" title=\"五、 channel\"></a>五、 channel</h2><h2 id=\"六、java正则\"><a href=\"#六、java正则\" class=\"headerlink\" title=\"六、java正则\"></a>六、java正则</h2>"},{"toc":true,"title":"Spring Data Redis","date":"2018-04-11T07:40:43.000Z","_content":"\n\nRedis是一种特殊类型的数据库，它被称为key-value存储。\nRedis教程官网：http://www.redis.net.cn/tutorial/3501.html\n\nSpring Data Redis是Spring Data系列的一部分，使用它可以轻松配置和访问Spring应用程序中的redis。如果直接操作redis，我们需要处理字节数组和各种类型之间的转换问题，类似于JDBC模板，Spring Data Redis提供了RedisTemplate。\n<!--more-->\n废话少说，咱们来实践一下。\n\n### pom.xml\nSpring Data Redis使用spring-data-redis，同时依赖jedis。\n这里需要非常注意版本问题。\n**spring-data-redis 2.0版本**\n![Alt text](https://app.yinxiang.com/shard/s15/res/dcb7d832-be14-4db7-a12b-39368ebcaee9/1523431453714.png)\n2.0以上版本要求 jdk 6以上， 以及Spring Framework 5.0.3以上。\n**spring-data-redis 1.8版本**\n![Alt text](https://app.yinxiang.com/shard/s15/res/c9984bec-cd00-4d89-965c-5d1fd3e2b6f3/1523431347709.png)\n这里1.8版本要求jdk 6以上，以及spring framework4.3.15以上。\n\n\n我一开始用的使用spring-data-redis 2.0.6，但是spring是4.3.13。所以装配Bean的时候一直报错。\n```xml\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.8.11.RELEASE</version>\n        </dependency>\n```\n\n### JavaConfig配置\nRedis连接工厂会生成到Redis数据库服务器的连接。Spring Data Redis为四种Redis客户端实现提供了连接工厂：\n- JedisConnectionFactory\n- JredisConnectionFactory\n- LettuceConnectionFactory\n- SrpConnectionFactory\n\n这里使用JedisConnectionFactory\n```java\n\t/**\n     * Redis连接工厂\n     * @return\n     */\n    @Bean\n    public RedisConnectionFactory redisConnectionFactory(){\n        return new JedisConnectionFactory();\n    }\n\n    /**\n     * Redis访问模板\n     * @param redisConnectionFactory\n     * @return\n     */\n    @Bean\n    public RedisTemplate<String, Spitter> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n        RedisTemplate<String, Spitter> redisTemplate = new RedisTemplate<String, Spitter>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        return redisTemplate;\n    }\n\n    @Bean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory){\n        return new StringRedisTemplate(redisConnectionFactory);\n    }\n```\nSpring Data Redis以模板的形式提供了较高等级的数据访问方案\t。实际上,Spring Data Redis提供了两个模板:\n- RedisTemplate\n- StringRedisTemplate\n\nRedisTemplate<K, V>使用两个类型进行参数化。第一个是key类型，第二个是value类型。\n\n如果你所使用的value和key都是String类型,那么可以考虑使用StringRedisTemplate。\n\n### 使用RedisTemplate\n![Alt text](https://app.yinxiang.com/shard/s15/res/bee56819-a3f9-478f-ad30-14bfbd333fbc/1523432112729.png)\n对于每一种数据类型都有相应的方法，详细可以查阅源码或API文档有多少方法。\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = {SpittrConfig.class})\npublic class ISpitterServiceTest {\n\n    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(ISpitterServiceTest.class);\n\n    @Autowired\n    public RedisTemplate<String, Spitter> redisTemplate;\n\n    @Test\n    public void registerTest(){\n        Spitter capljf = new Spitter();\n        capljf.setUsername(\"capljf\");\n        capljf.setPassword(\"123456\");\n        // 操作单个值\n        redisTemplate.opsForValue().set(capljf.getUsername(),capljf);\n        String out = redisTemplate.opsForValue().get(\"capljf\").toString();\n        LOG.info(\"======================={}\", out);\n        // 操作List\n        redisTemplate.opsForList().leftPush(\"spitterList\",capljf);\n        List<Spitter> spitterList = redisTemplate.opsForList().range(\"spitterList\", 0, 2);\n        LOG.info(\"======================={}\", spitterList);\n        // 操作Set\n        redisTemplate.opsForSet().add(\"spitterSet\", capljf);\n        Spitter spitter = redisTemplate.opsForSet().randomMember(\"spitterSet\");\n        LOG.info(\"======================={}\", spitter);\n        redisTemplate.opsForSet().remove(\"spitterSet\",capljf);\n        spitter = redisTemplate.opsForSet().randomMember(\"spitterSet\");\n        LOG.info(\"======================={}\", spitter);\n\n    }\n\n}\n```\n\n\n\n> 参考文献\n> [1] 《Spring实战》4th\n> [2] [Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/1.8.11.RELEASE/reference/html/)\n> [3] [Spring Data Redis 实践](https://blog.csdn.net/wlwlwlwl015/article/details/52863821)","source":"_posts/Spring-Data-Redis.md","raw":"---\ntoc: true\ntitle: Spring Data Redis\ndate: 2018-04-11 15:40:43\ntags: [redis, spring data redis]\n---\n\n\nRedis是一种特殊类型的数据库，它被称为key-value存储。\nRedis教程官网：http://www.redis.net.cn/tutorial/3501.html\n\nSpring Data Redis是Spring Data系列的一部分，使用它可以轻松配置和访问Spring应用程序中的redis。如果直接操作redis，我们需要处理字节数组和各种类型之间的转换问题，类似于JDBC模板，Spring Data Redis提供了RedisTemplate。\n<!--more-->\n废话少说，咱们来实践一下。\n\n### pom.xml\nSpring Data Redis使用spring-data-redis，同时依赖jedis。\n这里需要非常注意版本问题。\n**spring-data-redis 2.0版本**\n![Alt text](https://app.yinxiang.com/shard/s15/res/dcb7d832-be14-4db7-a12b-39368ebcaee9/1523431453714.png)\n2.0以上版本要求 jdk 6以上， 以及Spring Framework 5.0.3以上。\n**spring-data-redis 1.8版本**\n![Alt text](https://app.yinxiang.com/shard/s15/res/c9984bec-cd00-4d89-965c-5d1fd3e2b6f3/1523431347709.png)\n这里1.8版本要求jdk 6以上，以及spring framework4.3.15以上。\n\n\n我一开始用的使用spring-data-redis 2.0.6，但是spring是4.3.13。所以装配Bean的时候一直报错。\n```xml\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.8.11.RELEASE</version>\n        </dependency>\n```\n\n### JavaConfig配置\nRedis连接工厂会生成到Redis数据库服务器的连接。Spring Data Redis为四种Redis客户端实现提供了连接工厂：\n- JedisConnectionFactory\n- JredisConnectionFactory\n- LettuceConnectionFactory\n- SrpConnectionFactory\n\n这里使用JedisConnectionFactory\n```java\n\t/**\n     * Redis连接工厂\n     * @return\n     */\n    @Bean\n    public RedisConnectionFactory redisConnectionFactory(){\n        return new JedisConnectionFactory();\n    }\n\n    /**\n     * Redis访问模板\n     * @param redisConnectionFactory\n     * @return\n     */\n    @Bean\n    public RedisTemplate<String, Spitter> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n        RedisTemplate<String, Spitter> redisTemplate = new RedisTemplate<String, Spitter>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        return redisTemplate;\n    }\n\n    @Bean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory){\n        return new StringRedisTemplate(redisConnectionFactory);\n    }\n```\nSpring Data Redis以模板的形式提供了较高等级的数据访问方案\t。实际上,Spring Data Redis提供了两个模板:\n- RedisTemplate\n- StringRedisTemplate\n\nRedisTemplate<K, V>使用两个类型进行参数化。第一个是key类型，第二个是value类型。\n\n如果你所使用的value和key都是String类型,那么可以考虑使用StringRedisTemplate。\n\n### 使用RedisTemplate\n![Alt text](https://app.yinxiang.com/shard/s15/res/bee56819-a3f9-478f-ad30-14bfbd333fbc/1523432112729.png)\n对于每一种数据类型都有相应的方法，详细可以查阅源码或API文档有多少方法。\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = {SpittrConfig.class})\npublic class ISpitterServiceTest {\n\n    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(ISpitterServiceTest.class);\n\n    @Autowired\n    public RedisTemplate<String, Spitter> redisTemplate;\n\n    @Test\n    public void registerTest(){\n        Spitter capljf = new Spitter();\n        capljf.setUsername(\"capljf\");\n        capljf.setPassword(\"123456\");\n        // 操作单个值\n        redisTemplate.opsForValue().set(capljf.getUsername(),capljf);\n        String out = redisTemplate.opsForValue().get(\"capljf\").toString();\n        LOG.info(\"======================={}\", out);\n        // 操作List\n        redisTemplate.opsForList().leftPush(\"spitterList\",capljf);\n        List<Spitter> spitterList = redisTemplate.opsForList().range(\"spitterList\", 0, 2);\n        LOG.info(\"======================={}\", spitterList);\n        // 操作Set\n        redisTemplate.opsForSet().add(\"spitterSet\", capljf);\n        Spitter spitter = redisTemplate.opsForSet().randomMember(\"spitterSet\");\n        LOG.info(\"======================={}\", spitter);\n        redisTemplate.opsForSet().remove(\"spitterSet\",capljf);\n        spitter = redisTemplate.opsForSet().randomMember(\"spitterSet\");\n        LOG.info(\"======================={}\", spitter);\n\n    }\n\n}\n```\n\n\n\n> 参考文献\n> [1] 《Spring实战》4th\n> [2] [Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/1.8.11.RELEASE/reference/html/)\n> [3] [Spring Data Redis 实践](https://blog.csdn.net/wlwlwlwl015/article/details/52863821)","slug":"Spring-Data-Redis","published":1,"updated":"2018-08-13T14:28:27.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e43000a6k15fz0twzyz","content":"<p>Redis是一种特殊类型的数据库，它被称为key-value存储。<br>Redis教程官网：<a href=\"http://www.redis.net.cn/tutorial/3501.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.net.cn/tutorial/3501.html</a></p>\n<p>Spring Data Redis是Spring Data系列的一部分，使用它可以轻松配置和访问Spring应用程序中的redis。如果直接操作redis，我们需要处理字节数组和各种类型之间的转换问题，类似于JDBC模板，Spring Data Redis提供了RedisTemplate。<br><a id=\"more\"></a><br>废话少说，咱们来实践一下。</p>\n<h3 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h3><p>Spring Data Redis使用spring-data-redis，同时依赖jedis。<br>这里需要非常注意版本问题。<br><strong>spring-data-redis 2.0版本</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/dcb7d832-be14-4db7-a12b-39368ebcaee9/1523431453714.png\" alt=\"Alt text\"><br>2.0以上版本要求 jdk 6以上， 以及Spring Framework 5.0.3以上。<br><strong>spring-data-redis 1.8版本</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/c9984bec-cd00-4d89-965c-5d1fd3e2b6f3/1523431347709.png\" alt=\"Alt text\"><br>这里1.8版本要求jdk 6以上，以及spring framework4.3.15以上。</p>\n<p>我一开始用的使用spring-data-redis 2.0.6，但是spring是4.3.13。所以装配Bean的时候一直报错。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.data<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.11.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JavaConfig配置\"><a href=\"#JavaConfig配置\" class=\"headerlink\" title=\"JavaConfig配置\"></a>JavaConfig配置</h3><p>Redis连接工厂会生成到Redis数据库服务器的连接。Spring Data Redis为四种Redis客户端实现提供了连接工厂：</p>\n<ul>\n<li>JedisConnectionFactory</li>\n<li>JredisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory</li>\n</ul>\n<p>这里使用JedisConnectionFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Redis连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RedisConnectionFactory <span class=\"title\">redisConnectionFactory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JedisConnectionFactory();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Redis访问模板</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> redisConnectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, Spitter&gt; <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class=\"line\">       RedisTemplate&lt;String, Spitter&gt; redisTemplate = <span class=\"keyword\">new</span> RedisTemplate&lt;String, Spitter&gt;();</span><br><span class=\"line\">       redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redisTemplate;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> StringRedisTemplate <span class=\"title\">stringRedisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StringRedisTemplate(redisConnectionFactory);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Spring Data Redis以模板的形式提供了较高等级的数据访问方案    。实际上,Spring Data Redis提供了两个模板:</p>\n<ul>\n<li>RedisTemplate</li>\n<li>StringRedisTemplate</li>\n</ul>\n<p>RedisTemplate&lt;K, V&gt;使用两个类型进行参数化。第一个是key类型，第二个是value类型。</p>\n<p>如果你所使用的value和key都是String类型,那么可以考虑使用StringRedisTemplate。</p>\n<h3 id=\"使用RedisTemplate\"><a href=\"#使用RedisTemplate\" class=\"headerlink\" title=\"使用RedisTemplate\"></a>使用RedisTemplate</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/bee56819-a3f9-478f-ad30-14bfbd333fbc/1523432112729.png\" alt=\"Alt text\"><br>对于每一种数据类型都有相应的方法，详细可以查阅源码或API文档有多少方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes = &#123;SpittrConfig.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ISpitterServiceTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.slf4j.Logger LOG = LoggerFactory.getLogger(ISpitterServiceTest.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedisTemplate&lt;String, Spitter&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Spitter capljf = <span class=\"keyword\">new</span> Spitter();</span><br><span class=\"line\">        capljf.setUsername(<span class=\"string\">\"capljf\"</span>);</span><br><span class=\"line\">        capljf.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 操作单个值</span></span><br><span class=\"line\">        redisTemplate.opsForValue().set(capljf.getUsername(),capljf);</span><br><span class=\"line\">        String out = redisTemplate.opsForValue().get(<span class=\"string\">\"capljf\"</span>).toString();</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, out);</span><br><span class=\"line\">        <span class=\"comment\">// 操作List</span></span><br><span class=\"line\">        redisTemplate.opsForList().leftPush(<span class=\"string\">\"spitterList\"</span>,capljf);</span><br><span class=\"line\">        List&lt;Spitter&gt; spitterList = redisTemplate.opsForList().range(<span class=\"string\">\"spitterList\"</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitterList);</span><br><span class=\"line\">        <span class=\"comment\">// 操作Set</span></span><br><span class=\"line\">        redisTemplate.opsForSet().add(<span class=\"string\">\"spitterSet\"</span>, capljf);</span><br><span class=\"line\">        Spitter spitter = redisTemplate.opsForSet().randomMember(<span class=\"string\">\"spitterSet\"</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitter);</span><br><span class=\"line\">        redisTemplate.opsForSet().remove(<span class=\"string\">\"spitterSet\"</span>,capljf);</span><br><span class=\"line\">        spitter = redisTemplate.opsForSet().randomMember(<span class=\"string\">\"spitterSet\"</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitter);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考文献<br>[1] 《Spring实战》4th<br>[2] <a href=\"https://docs.spring.io/spring-data/redis/docs/1.8.11.RELEASE/reference/html/\" target=\"_blank\" rel=\"noopener\">Spring Data Redis</a><br>[3] <a href=\"https://blog.csdn.net/wlwlwlwl015/article/details/52863821\" target=\"_blank\" rel=\"noopener\">Spring Data Redis 实践</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Redis是一种特殊类型的数据库，它被称为key-value存储。<br>Redis教程官网：<a href=\"http://www.redis.net.cn/tutorial/3501.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.net.cn/tutorial/3501.html</a></p>\n<p>Spring Data Redis是Spring Data系列的一部分，使用它可以轻松配置和访问Spring应用程序中的redis。如果直接操作redis，我们需要处理字节数组和各种类型之间的转换问题，类似于JDBC模板，Spring Data Redis提供了RedisTemplate。<br>","more":"<br>废话少说，咱们来实践一下。</p>\n<h3 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h3><p>Spring Data Redis使用spring-data-redis，同时依赖jedis。<br>这里需要非常注意版本问题。<br><strong>spring-data-redis 2.0版本</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/dcb7d832-be14-4db7-a12b-39368ebcaee9/1523431453714.png\" alt=\"Alt text\"><br>2.0以上版本要求 jdk 6以上， 以及Spring Framework 5.0.3以上。<br><strong>spring-data-redis 1.8版本</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/c9984bec-cd00-4d89-965c-5d1fd3e2b6f3/1523431347709.png\" alt=\"Alt text\"><br>这里1.8版本要求jdk 6以上，以及spring framework4.3.15以上。</p>\n<p>我一开始用的使用spring-data-redis 2.0.6，但是spring是4.3.13。所以装配Bean的时候一直报错。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.data<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.11.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JavaConfig配置\"><a href=\"#JavaConfig配置\" class=\"headerlink\" title=\"JavaConfig配置\"></a>JavaConfig配置</h3><p>Redis连接工厂会生成到Redis数据库服务器的连接。Spring Data Redis为四种Redis客户端实现提供了连接工厂：</p>\n<ul>\n<li>JedisConnectionFactory</li>\n<li>JredisConnectionFactory</li>\n<li>LettuceConnectionFactory</li>\n<li>SrpConnectionFactory</li>\n</ul>\n<p>这里使用JedisConnectionFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Redis连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RedisConnectionFactory <span class=\"title\">redisConnectionFactory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JedisConnectionFactory();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Redis访问模板</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> redisConnectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, Spitter&gt; <span class=\"title\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class=\"line\">       RedisTemplate&lt;String, Spitter&gt; redisTemplate = <span class=\"keyword\">new</span> RedisTemplate&lt;String, Spitter&gt;();</span><br><span class=\"line\">       redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> redisTemplate;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> StringRedisTemplate <span class=\"title\">stringRedisTemplate</span><span class=\"params\">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StringRedisTemplate(redisConnectionFactory);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Spring Data Redis以模板的形式提供了较高等级的数据访问方案    。实际上,Spring Data Redis提供了两个模板:</p>\n<ul>\n<li>RedisTemplate</li>\n<li>StringRedisTemplate</li>\n</ul>\n<p>RedisTemplate&lt;K, V&gt;使用两个类型进行参数化。第一个是key类型，第二个是value类型。</p>\n<p>如果你所使用的value和key都是String类型,那么可以考虑使用StringRedisTemplate。</p>\n<h3 id=\"使用RedisTemplate\"><a href=\"#使用RedisTemplate\" class=\"headerlink\" title=\"使用RedisTemplate\"></a>使用RedisTemplate</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/bee56819-a3f9-478f-ad30-14bfbd333fbc/1523432112729.png\" alt=\"Alt text\"><br>对于每一种数据类型都有相应的方法，详细可以查阅源码或API文档有多少方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes = &#123;SpittrConfig.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ISpitterServiceTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.slf4j.Logger LOG = LoggerFactory.getLogger(ISpitterServiceTest.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedisTemplate&lt;String, Spitter&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Spitter capljf = <span class=\"keyword\">new</span> Spitter();</span><br><span class=\"line\">        capljf.setUsername(<span class=\"string\">\"capljf\"</span>);</span><br><span class=\"line\">        capljf.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 操作单个值</span></span><br><span class=\"line\">        redisTemplate.opsForValue().set(capljf.getUsername(),capljf);</span><br><span class=\"line\">        String out = redisTemplate.opsForValue().get(<span class=\"string\">\"capljf\"</span>).toString();</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, out);</span><br><span class=\"line\">        <span class=\"comment\">// 操作List</span></span><br><span class=\"line\">        redisTemplate.opsForList().leftPush(<span class=\"string\">\"spitterList\"</span>,capljf);</span><br><span class=\"line\">        List&lt;Spitter&gt; spitterList = redisTemplate.opsForList().range(<span class=\"string\">\"spitterList\"</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitterList);</span><br><span class=\"line\">        <span class=\"comment\">// 操作Set</span></span><br><span class=\"line\">        redisTemplate.opsForSet().add(<span class=\"string\">\"spitterSet\"</span>, capljf);</span><br><span class=\"line\">        Spitter spitter = redisTemplate.opsForSet().randomMember(<span class=\"string\">\"spitterSet\"</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitter);</span><br><span class=\"line\">        redisTemplate.opsForSet().remove(<span class=\"string\">\"spitterSet\"</span>,capljf);</span><br><span class=\"line\">        spitter = redisTemplate.opsForSet().randomMember(<span class=\"string\">\"spitterSet\"</span>);</span><br><span class=\"line\">        LOG.info(<span class=\"string\">\"=======================&#123;&#125;\"</span>, spitter);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考文献<br>[1] 《Spring实战》4th<br>[2] <a href=\"https://docs.spring.io/spring-data/redis/docs/1.8.11.RELEASE/reference/html/\" target=\"_blank\" rel=\"noopener\">Spring Data Redis</a><br>[3] <a href=\"https://blog.csdn.net/wlwlwlwl015/article/details/52863821\" target=\"_blank\" rel=\"noopener\">Spring Data Redis 实践</a></p>\n</blockquote>"},{"toc":true,"title":"java网络I/O","date":"2017-08-10T06:10:03.000Z","_content":"\n**一.套接字**：\n1.定义：源IP地址和目的IP地址、源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。\n<!--more-->\n它是网络通信过程中端点的抽象表示，包含进行网络通信的五个必备信息：连接使用的协议、本地主机IP地址、本地进程协议端口号、目的IP地址、目的进程协议端口号。\n2.主要参数：区分不同应用程序进程间的网络通信和连接，主要有三个参数：使用的目的IP地址、使用的传输层协议（TPC、UDP）和使用的端口号。\n\n**1  BIO编程**\n* 传统的BIO编程采用C/S模型，是两个进程间的通讯。\n* 客户端向服务端监听的地址发出请求，在三次握手连接之后通过socket套接字进行通讯。\n* 传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通讯。\n* 通常服务端有一个Acceptor进程，每当有一个客户端请求，如果Acceptor接受之后就新建一个线程，处理完成后，通过输出流返回应答给客户端，线程销毁。每个线程的处理流程（读取数据、解码、处理、编码、发送响应）\n* BIO最大的缺点就是会产生很多的线程，占用很多资源。当客户端并发访问量增加后，服务端的线程个数就和客户端成1:1的关系。系统性能随之降低。\n![BIO图示](https://www.tuhd.me/img/xinde/javaio2.png)\n\n**2  伪异步IO**\n-  传统的IO，每来一个请求就创建一个线程，不适合高并发量请求处理。\n-  伪异步IO就是把每个请求丢进请求队列中，服务器端增加了一个线程池，用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型。\n  ![伪异步IO](https://www.tuhd.me/img/xinde/javaio2.png)\n\n**NIO编程**\n- Non-block IO\n- NIO提供了与传统BIO模型中的Socket和ServerSocket对应的SocketChannel和ServerChannel两种不同的套接字通道实现。\n- 新增的两种通道都支持阻塞和非阻塞两种方式\n- 对于低负载、低并发的应用程序，可以使用BIO来提升开发速率和更好的维护；对于高负载、高并发的网络应用，可以使用BIO的非阻塞模式开发。\n![NIO](http://img0.tuicool.com/QJNVzei.png!web)\n- Channel分为两大类\n\t- SelectableChannel：用户网络读写\n\t- FileChannel：文件读写\n\n- 三个核心API：\n\t- Channels\n\t- Buffers\n\t- Selectors\n\n- NIO与BIO的最大区别就是，BIO是面向流的，NIO是面向缓冲的。\n\n**AIO编程**\n\n\t\n\n\n","source":"_posts/java网络IO.md","raw":"---\ntoc: true\ntitle: java网络I/O\ndate: 2017-08-10 14:10:03\ntags: [java,I/O]\n---\n\n**一.套接字**：\n1.定义：源IP地址和目的IP地址、源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。\n<!--more-->\n它是网络通信过程中端点的抽象表示，包含进行网络通信的五个必备信息：连接使用的协议、本地主机IP地址、本地进程协议端口号、目的IP地址、目的进程协议端口号。\n2.主要参数：区分不同应用程序进程间的网络通信和连接，主要有三个参数：使用的目的IP地址、使用的传输层协议（TPC、UDP）和使用的端口号。\n\n**1  BIO编程**\n* 传统的BIO编程采用C/S模型，是两个进程间的通讯。\n* 客户端向服务端监听的地址发出请求，在三次握手连接之后通过socket套接字进行通讯。\n* 传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通讯。\n* 通常服务端有一个Acceptor进程，每当有一个客户端请求，如果Acceptor接受之后就新建一个线程，处理完成后，通过输出流返回应答给客户端，线程销毁。每个线程的处理流程（读取数据、解码、处理、编码、发送响应）\n* BIO最大的缺点就是会产生很多的线程，占用很多资源。当客户端并发访问量增加后，服务端的线程个数就和客户端成1:1的关系。系统性能随之降低。\n![BIO图示](https://www.tuhd.me/img/xinde/javaio2.png)\n\n**2  伪异步IO**\n-  传统的IO，每来一个请求就创建一个线程，不适合高并发量请求处理。\n-  伪异步IO就是把每个请求丢进请求队列中，服务器端增加了一个线程池，用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型。\n  ![伪异步IO](https://www.tuhd.me/img/xinde/javaio2.png)\n\n**NIO编程**\n- Non-block IO\n- NIO提供了与传统BIO模型中的Socket和ServerSocket对应的SocketChannel和ServerChannel两种不同的套接字通道实现。\n- 新增的两种通道都支持阻塞和非阻塞两种方式\n- 对于低负载、低并发的应用程序，可以使用BIO来提升开发速率和更好的维护；对于高负载、高并发的网络应用，可以使用BIO的非阻塞模式开发。\n![NIO](http://img0.tuicool.com/QJNVzei.png!web)\n- Channel分为两大类\n\t- SelectableChannel：用户网络读写\n\t- FileChannel：文件读写\n\n- 三个核心API：\n\t- Channels\n\t- Buffers\n\t- Selectors\n\n- NIO与BIO的最大区别就是，BIO是面向流的，NIO是面向缓冲的。\n\n**AIO编程**\n\n\t\n\n\n","slug":"java网络IO","published":1,"updated":"2018-08-13T14:28:27.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e45000c6k154olstacu","content":"<p><strong>一.套接字</strong>：<br>1.定义：源IP地址和目的IP地址、源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。<br><a id=\"more\"></a><br>它是网络通信过程中端点的抽象表示，包含进行网络通信的五个必备信息：连接使用的协议、本地主机IP地址、本地进程协议端口号、目的IP地址、目的进程协议端口号。<br>2.主要参数：区分不同应用程序进程间的网络通信和连接，主要有三个参数：使用的目的IP地址、使用的传输层协议（TPC、UDP）和使用的端口号。</p>\n<p><strong>1  BIO编程</strong></p>\n<ul>\n<li>传统的BIO编程采用C/S模型，是两个进程间的通讯。</li>\n<li>客户端向服务端监听的地址发出请求，在三次握手连接之后通过socket套接字进行通讯。</li>\n<li>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通讯。</li>\n<li>通常服务端有一个Acceptor进程，每当有一个客户端请求，如果Acceptor接受之后就新建一个线程，处理完成后，通过输出流返回应答给客户端，线程销毁。每个线程的处理流程（读取数据、解码、处理、编码、发送响应）</li>\n<li>BIO最大的缺点就是会产生很多的线程，占用很多资源。当客户端并发访问量增加后，服务端的线程个数就和客户端成1:1的关系。系统性能随之降低。<br><img src=\"https://www.tuhd.me/img/xinde/javaio2.png\" alt=\"BIO图示\"></li>\n</ul>\n<p><strong>2  伪异步IO</strong></p>\n<ul>\n<li>传统的IO，每来一个请求就创建一个线程，不适合高并发量请求处理。</li>\n<li>伪异步IO就是把每个请求丢进请求队列中，服务器端增加了一个线程池，用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型。<br><img src=\"https://www.tuhd.me/img/xinde/javaio2.png\" alt=\"伪异步IO\"></li>\n</ul>\n<p><strong>NIO编程</strong></p>\n<ul>\n<li>Non-block IO</li>\n<li>NIO提供了与传统BIO模型中的Socket和ServerSocket对应的SocketChannel和ServerChannel两种不同的套接字通道实现。</li>\n<li>新增的两种通道都支持阻塞和非阻塞两种方式</li>\n<li>对于低负载、低并发的应用程序，可以使用BIO来提升开发速率和更好的维护；对于高负载、高并发的网络应用，可以使用BIO的非阻塞模式开发。<br><img src=\"http://img0.tuicool.com/QJNVzei.png!web\" alt=\"NIO\"></li>\n<li><p>Channel分为两大类</p>\n<ul>\n<li>SelectableChannel：用户网络读写</li>\n<li>FileChannel：文件读写</li>\n</ul>\n</li>\n<li><p>三个核心API：</p>\n<ul>\n<li>Channels</li>\n<li>Buffers</li>\n<li>Selectors</li>\n</ul>\n</li>\n<li><p>NIO与BIO的最大区别就是，BIO是面向流的，NIO是面向缓冲的。</p>\n</li>\n</ul>\n<p><strong>AIO编程</strong></p>\n","site":{"data":{}},"excerpt":"<p><strong>一.套接字</strong>：<br>1.定义：源IP地址和目的IP地址、源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。<br>","more":"<br>它是网络通信过程中端点的抽象表示，包含进行网络通信的五个必备信息：连接使用的协议、本地主机IP地址、本地进程协议端口号、目的IP地址、目的进程协议端口号。<br>2.主要参数：区分不同应用程序进程间的网络通信和连接，主要有三个参数：使用的目的IP地址、使用的传输层协议（TPC、UDP）和使用的端口号。</p>\n<p><strong>1  BIO编程</strong></p>\n<ul>\n<li>传统的BIO编程采用C/S模型，是两个进程间的通讯。</li>\n<li>客户端向服务端监听的地址发出请求，在三次握手连接之后通过socket套接字进行通讯。</li>\n<li>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通讯。</li>\n<li>通常服务端有一个Acceptor进程，每当有一个客户端请求，如果Acceptor接受之后就新建一个线程，处理完成后，通过输出流返回应答给客户端，线程销毁。每个线程的处理流程（读取数据、解码、处理、编码、发送响应）</li>\n<li>BIO最大的缺点就是会产生很多的线程，占用很多资源。当客户端并发访问量增加后，服务端的线程个数就和客户端成1:1的关系。系统性能随之降低。<br><img src=\"https://www.tuhd.me/img/xinde/javaio2.png\" alt=\"BIO图示\"></li>\n</ul>\n<p><strong>2  伪异步IO</strong></p>\n<ul>\n<li>传统的IO，每来一个请求就创建一个线程，不适合高并发量请求处理。</li>\n<li>伪异步IO就是把每个请求丢进请求队列中，服务器端增加了一个线程池，用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型。<br><img src=\"https://www.tuhd.me/img/xinde/javaio2.png\" alt=\"伪异步IO\"></li>\n</ul>\n<p><strong>NIO编程</strong></p>\n<ul>\n<li>Non-block IO</li>\n<li>NIO提供了与传统BIO模型中的Socket和ServerSocket对应的SocketChannel和ServerChannel两种不同的套接字通道实现。</li>\n<li>新增的两种通道都支持阻塞和非阻塞两种方式</li>\n<li>对于低负载、低并发的应用程序，可以使用BIO来提升开发速率和更好的维护；对于高负载、高并发的网络应用，可以使用BIO的非阻塞模式开发。<br><img src=\"http://img0.tuicool.com/QJNVzei.png!web\" alt=\"NIO\"></li>\n<li><p>Channel分为两大类</p>\n<ul>\n<li>SelectableChannel：用户网络读写</li>\n<li>FileChannel：文件读写</li>\n</ul>\n</li>\n<li><p>三个核心API：</p>\n<ul>\n<li>Channels</li>\n<li>Buffers</li>\n<li>Selectors</li>\n</ul>\n</li>\n<li><p>NIO与BIO的最大区别就是，BIO是面向流的，NIO是面向缓冲的。</p>\n</li>\n</ul>\n<p><strong>AIO编程</strong></p>"},{"toc":true,"title":"java I/O流","date":"2018-03-21T06:16:43.000Z","_content":"\n\n### 1. 概述\nIO流简单来说就是Input和Output流，IO流主要是用来处理设备之间的数据传输，Java对于数据的操作都是通过流实现，而java用于操作流的对象都在IO包中。\n<!--more-->\n### 2. 分类\n按操作数据分为：字节流和字符流。 如：`Reader`和`InpurStream`\n按流向分：输入流和输出流。如：`InputStream`和`OutputStream`\n\t\n\t顺序访问：相当于链表，想要读取第5个位置的字节，必须按顺序读取第1\\2\\3\\4位置的字节\n\t随机访问：相当于数组，想要读取第5个位置的字节，可以直接读取到\n\n![IO流家族](https://app.yinxiang.com/shard/s15/res/2c5ca3f2-2db4-45f3-acb9-4515c3257ae1)\n\n\n### 3. N点（notice point）\n使用了缓冲区是否一定要flush \n【BufferedReader源码】\n```java\npublic class BufferedReader extends Reader {\n\n    private Reader in;\n\n    private char cb[];\n    private int nChars, nextChar;\n\n    private static final int INVALIDATED = -2;\n    private static final int UNMARKED = -1;\n    private int markedChar = UNMARKED;\n    private int readAheadLimit = 0; /* Valid only when markedChar > 0 */\n\n    /** If the next character is a line feed, skip it */\n    private boolean skipLF = false;\n\n    /** The skipLF flag when the mark was set */\n    private boolean markedSkipLF = false;\n\n    private static int defaultCharBufferSize = 8192;\n    private static int defaultExpectedLineLength = 80;\n    /**\n\t * 省略很多源码\n\t */\n}\n```\n可以看到`defaultCharBufferSize`是8192，单位是char，即8192 Byte\n如果文件size大于8192 Byte，而且写入的时候不及时flush，就会发生数据丢失。\n由于`close()`方法会执行`flush()`，所以我写得测试代码并没有发生数据丢失的情况，而我一行的大小却明显大于8192字节，由于源码看得有点痛苦，我大致认为是`readline()`方法多次调用buffer，一次读满了就append到返回字符串后面。\n\n流close的顺序\n【示例代码：】\n```java\npackage stream;\n\nimport java.io.*;\n\npublic class InputStream {\n    public static void main(String[] args) throws IOException {\n        FileReader fr = new FileReader(\"/home/jifang/Desktop/a.txt\");\n        BufferedReader br = new BufferedReader(fr);\n        String str;\n        FileWriter fw = new FileWriter(\"/home/jifang/Desktop/b.txt\");\n        BufferedWriter bw = new BufferedWriter(fw);\n        while ((str=br.readLine())!=null){\n            bw.write(str);\n        }\n        fr.close();\n        br.close();\n        fw.close();\n        bw.close();\n    }\n}\n```\n【运行出现异常】\n```java\nException in thread \"main\" java.io.IOException: Stream closed\n\tat sun.nio.cs.StreamEncoder.ensureOpen(StreamEncoder.java:45)\n\tat sun.nio.cs.StreamEncoder.write(StreamEncoder.java:118)\n\tat java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)\n\tat java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)\n\tat java.io.BufferedWriter.close(BufferedWriter.java:265)\n\tat stream.InputStream.main(InputStream.java:18)\n```\n### 4. 流操作基本规律\n在阅读了[这篇博客](https://www.cnblogs.com/xll1025/p/6418766.html)之后，他提出的这一点我感觉很好用，也方便记忆，但是博主不允许转载，我也就不贴了。有兴趣的可以点链接看看。\n\n使用流的思路：\n1. 明确源和目的\n2. 明确操作数据类型（字符或字节）\n3. 明确设备（键盘、内存、文件、网络）\n4. 是否使用buffer\n\n**BufferReader的威力**\n《Java核心技术 卷二》表1-7\n| 方法      |    时间 |\n| :-------- | --------:|\n| 普通输入流  | 110秒 |\n|带缓冲的输入流|9.9秒|\n|随机访问文件|162秒|\n|内存映射文件|7.2秒|\n相信大家看完这个对比之后能直观的感受到缓冲带来的效率提升。\n\n> 参考文献\n> [1] [inputStream关闭了，还有必要关闭InputStreamReader和BufferedReader吗？](https://segmentfault.com/q/1010000005970993)\n> [2] [JAVA IO流最详解](https://www.cnblogs.com/xll1025/p/6418766.html)\n> [3] 《Java核心技术 卷二》","source":"_posts/javaIO流.md","raw":"---\ntoc: true\ntitle: java I/O流\ndate: 2018-03-21 14:16:43\ntags: [java,I/O,流]\n---\n\n\n### 1. 概述\nIO流简单来说就是Input和Output流，IO流主要是用来处理设备之间的数据传输，Java对于数据的操作都是通过流实现，而java用于操作流的对象都在IO包中。\n<!--more-->\n### 2. 分类\n按操作数据分为：字节流和字符流。 如：`Reader`和`InpurStream`\n按流向分：输入流和输出流。如：`InputStream`和`OutputStream`\n\t\n\t顺序访问：相当于链表，想要读取第5个位置的字节，必须按顺序读取第1\\2\\3\\4位置的字节\n\t随机访问：相当于数组，想要读取第5个位置的字节，可以直接读取到\n\n![IO流家族](https://app.yinxiang.com/shard/s15/res/2c5ca3f2-2db4-45f3-acb9-4515c3257ae1)\n\n\n### 3. N点（notice point）\n使用了缓冲区是否一定要flush \n【BufferedReader源码】\n```java\npublic class BufferedReader extends Reader {\n\n    private Reader in;\n\n    private char cb[];\n    private int nChars, nextChar;\n\n    private static final int INVALIDATED = -2;\n    private static final int UNMARKED = -1;\n    private int markedChar = UNMARKED;\n    private int readAheadLimit = 0; /* Valid only when markedChar > 0 */\n\n    /** If the next character is a line feed, skip it */\n    private boolean skipLF = false;\n\n    /** The skipLF flag when the mark was set */\n    private boolean markedSkipLF = false;\n\n    private static int defaultCharBufferSize = 8192;\n    private static int defaultExpectedLineLength = 80;\n    /**\n\t * 省略很多源码\n\t */\n}\n```\n可以看到`defaultCharBufferSize`是8192，单位是char，即8192 Byte\n如果文件size大于8192 Byte，而且写入的时候不及时flush，就会发生数据丢失。\n由于`close()`方法会执行`flush()`，所以我写得测试代码并没有发生数据丢失的情况，而我一行的大小却明显大于8192字节，由于源码看得有点痛苦，我大致认为是`readline()`方法多次调用buffer，一次读满了就append到返回字符串后面。\n\n流close的顺序\n【示例代码：】\n```java\npackage stream;\n\nimport java.io.*;\n\npublic class InputStream {\n    public static void main(String[] args) throws IOException {\n        FileReader fr = new FileReader(\"/home/jifang/Desktop/a.txt\");\n        BufferedReader br = new BufferedReader(fr);\n        String str;\n        FileWriter fw = new FileWriter(\"/home/jifang/Desktop/b.txt\");\n        BufferedWriter bw = new BufferedWriter(fw);\n        while ((str=br.readLine())!=null){\n            bw.write(str);\n        }\n        fr.close();\n        br.close();\n        fw.close();\n        bw.close();\n    }\n}\n```\n【运行出现异常】\n```java\nException in thread \"main\" java.io.IOException: Stream closed\n\tat sun.nio.cs.StreamEncoder.ensureOpen(StreamEncoder.java:45)\n\tat sun.nio.cs.StreamEncoder.write(StreamEncoder.java:118)\n\tat java.io.OutputStreamWriter.write(OutputStreamWriter.java:207)\n\tat java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129)\n\tat java.io.BufferedWriter.close(BufferedWriter.java:265)\n\tat stream.InputStream.main(InputStream.java:18)\n```\n### 4. 流操作基本规律\n在阅读了[这篇博客](https://www.cnblogs.com/xll1025/p/6418766.html)之后，他提出的这一点我感觉很好用，也方便记忆，但是博主不允许转载，我也就不贴了。有兴趣的可以点链接看看。\n\n使用流的思路：\n1. 明确源和目的\n2. 明确操作数据类型（字符或字节）\n3. 明确设备（键盘、内存、文件、网络）\n4. 是否使用buffer\n\n**BufferReader的威力**\n《Java核心技术 卷二》表1-7\n| 方法      |    时间 |\n| :-------- | --------:|\n| 普通输入流  | 110秒 |\n|带缓冲的输入流|9.9秒|\n|随机访问文件|162秒|\n|内存映射文件|7.2秒|\n相信大家看完这个对比之后能直观的感受到缓冲带来的效率提升。\n\n> 参考文献\n> [1] [inputStream关闭了，还有必要关闭InputStreamReader和BufferedReader吗？](https://segmentfault.com/q/1010000005970993)\n> [2] [JAVA IO流最详解](https://www.cnblogs.com/xll1025/p/6418766.html)\n> [3] 《Java核心技术 卷二》","slug":"javaIO流","published":1,"updated":"2018-08-13T14:28:27.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e47000f6k15xe65mq0u","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><p>IO流简单来说就是Input和Output流，IO流主要是用来处理设备之间的数据传输，Java对于数据的操作都是通过流实现，而java用于操作流的对象都在IO包中。<br><a id=\"more\"></a></p>\n<h3 id=\"2-分类\"><a href=\"#2-分类\" class=\"headerlink\" title=\"2. 分类\"></a>2. 分类</h3><p>按操作数据分为：字节流和字符流。 如：<code>Reader</code>和<code>InpurStream</code><br>按流向分：输入流和输出流。如：<code>InputStream</code>和<code>OutputStream</code></p>\n<pre><code>顺序访问：相当于链表，想要读取第5个位置的字节，必须按顺序读取第1\\2\\3\\4位置的字节\n随机访问：相当于数组，想要读取第5个位置的字节，可以直接读取到\n</code></pre><p><img src=\"https://app.yinxiang.com/shard/s15/res/2c5ca3f2-2db4-45f3-acb9-4515c3257ae1\" alt=\"IO流家族\"></p>\n<h3 id=\"3-N点（notice-point）\"><a href=\"#3-N点（notice-point）\" class=\"headerlink\" title=\"3. N点（notice point）\"></a>3. N点（notice point）</h3><p>使用了缓冲区是否一定要flush<br>【BufferedReader源码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedReader</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Reader in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span> cb[];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nChars, nextChar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INVALIDATED = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNMARKED = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> markedChar = UNMARKED;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> readAheadLimit = <span class=\"number\">0</span>; <span class=\"comment\">/* Valid only when markedChar &gt; 0 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** If the next character is a line feed, skip it */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> skipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The skipLF flag when the mark was set */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> markedSkipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultCharBufferSize = <span class=\"number\">8192</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultExpectedLineLength = <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 省略很多源码</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>defaultCharBufferSize</code>是8192，单位是char，即8192 Byte<br>如果文件size大于8192 Byte，而且写入的时候不及时flush，就会发生数据丢失。<br>由于<code>close()</code>方法会执行<code>flush()</code>，所以我写得测试代码并没有发生数据丢失的情况，而我一行的大小却明显大于8192字节，由于源码看得有点痛苦，我大致认为是<code>readline()</code>方法多次调用buffer，一次读满了就append到返回字符串后面。</p>\n<p>流close的顺序<br>【示例代码：】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        FileReader fr = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"/home/jifang/Desktop/a.txt\"</span>);</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(fr);</span><br><span class=\"line\">        String str;</span><br><span class=\"line\">        FileWriter fw = <span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"/home/jifang/Desktop/b.txt\"</span>);</span><br><span class=\"line\">        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(fw);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((str=br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            bw.write(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fr.close();</span><br><span class=\"line\">        br.close();</span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">        bw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【运行出现异常】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.io.IOException: Stream closed</span><br><span class=\"line\">\tat sun.nio.cs.StreamEncoder.ensureOpen(StreamEncoder.java:<span class=\"number\">45</span>)</span><br><span class=\"line\">\tat sun.nio.cs.StreamEncoder.write(StreamEncoder.java:<span class=\"number\">118</span>)</span><br><span class=\"line\">\tat java.io.OutputStreamWriter.write(OutputStreamWriter.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">\tat java.io.BufferedWriter.flushBuffer(BufferedWriter.java:<span class=\"number\">129</span>)</span><br><span class=\"line\">\tat java.io.BufferedWriter.close(BufferedWriter.java:<span class=\"number\">265</span>)</span><br><span class=\"line\">\tat stream.InputStream.main(InputStream.java:<span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-流操作基本规律\"><a href=\"#4-流操作基本规律\" class=\"headerlink\" title=\"4. 流操作基本规律\"></a>4. 流操作基本规律</h3><p>在阅读了<a href=\"https://www.cnblogs.com/xll1025/p/6418766.html\" target=\"_blank\" rel=\"noopener\">这篇博客</a>之后，他提出的这一点我感觉很好用，也方便记忆，但是博主不允许转载，我也就不贴了。有兴趣的可以点链接看看。</p>\n<p>使用流的思路：</p>\n<ol>\n<li>明确源和目的</li>\n<li>明确操作数据类型（字符或字节）</li>\n<li>明确设备（键盘、内存、文件、网络）</li>\n<li>是否使用buffer</li>\n</ol>\n<p><strong>BufferReader的威力</strong><br>《Java核心技术 卷二》表1-7<br>| 方法      |    时间 |<br>| :——– | ——–:|<br>| 普通输入流  | 110秒 |<br>|带缓冲的输入流|9.9秒|<br>|随机访问文件|162秒|<br>|内存映射文件|7.2秒|<br>相信大家看完这个对比之后能直观的感受到缓冲带来的效率提升。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://segmentfault.com/q/1010000005970993\" target=\"_blank\" rel=\"noopener\">inputStream关闭了，还有必要关闭InputStreamReader和BufferedReader吗？</a><br>[2] <a href=\"https://www.cnblogs.com/xll1025/p/6418766.html\" target=\"_blank\" rel=\"noopener\">JAVA IO流最详解</a><br>[3] 《Java核心技术 卷二》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><p>IO流简单来说就是Input和Output流，IO流主要是用来处理设备之间的数据传输，Java对于数据的操作都是通过流实现，而java用于操作流的对象都在IO包中。<br>","more":"</p>\n<h3 id=\"2-分类\"><a href=\"#2-分类\" class=\"headerlink\" title=\"2. 分类\"></a>2. 分类</h3><p>按操作数据分为：字节流和字符流。 如：<code>Reader</code>和<code>InpurStream</code><br>按流向分：输入流和输出流。如：<code>InputStream</code>和<code>OutputStream</code></p>\n<pre><code>顺序访问：相当于链表，想要读取第5个位置的字节，必须按顺序读取第1\\2\\3\\4位置的字节\n随机访问：相当于数组，想要读取第5个位置的字节，可以直接读取到\n</code></pre><p><img src=\"https://app.yinxiang.com/shard/s15/res/2c5ca3f2-2db4-45f3-acb9-4515c3257ae1\" alt=\"IO流家族\"></p>\n<h3 id=\"3-N点（notice-point）\"><a href=\"#3-N点（notice-point）\" class=\"headerlink\" title=\"3. N点（notice point）\"></a>3. N点（notice point）</h3><p>使用了缓冲区是否一定要flush<br>【BufferedReader源码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedReader</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reader</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Reader in;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span> cb[];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> nChars, nextChar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INVALIDATED = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNMARKED = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> markedChar = UNMARKED;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> readAheadLimit = <span class=\"number\">0</span>; <span class=\"comment\">/* Valid only when markedChar &gt; 0 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** If the next character is a line feed, skip it */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> skipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The skipLF flag when the mark was set */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> markedSkipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultCharBufferSize = <span class=\"number\">8192</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultExpectedLineLength = <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 省略很多源码</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到<code>defaultCharBufferSize</code>是8192，单位是char，即8192 Byte<br>如果文件size大于8192 Byte，而且写入的时候不及时flush，就会发生数据丢失。<br>由于<code>close()</code>方法会执行<code>flush()</code>，所以我写得测试代码并没有发生数据丢失的情况，而我一行的大小却明显大于8192字节，由于源码看得有点痛苦，我大致认为是<code>readline()</code>方法多次调用buffer，一次读满了就append到返回字符串后面。</p>\n<p>流close的顺序<br>【示例代码：】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        FileReader fr = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"/home/jifang/Desktop/a.txt\"</span>);</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(fr);</span><br><span class=\"line\">        String str;</span><br><span class=\"line\">        FileWriter fw = <span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"/home/jifang/Desktop/b.txt\"</span>);</span><br><span class=\"line\">        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(fw);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((str=br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            bw.write(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fr.close();</span><br><span class=\"line\">        br.close();</span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">        bw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【运行出现异常】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.io.IOException: Stream closed</span><br><span class=\"line\">\tat sun.nio.cs.StreamEncoder.ensureOpen(StreamEncoder.java:<span class=\"number\">45</span>)</span><br><span class=\"line\">\tat sun.nio.cs.StreamEncoder.write(StreamEncoder.java:<span class=\"number\">118</span>)</span><br><span class=\"line\">\tat java.io.OutputStreamWriter.write(OutputStreamWriter.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">\tat java.io.BufferedWriter.flushBuffer(BufferedWriter.java:<span class=\"number\">129</span>)</span><br><span class=\"line\">\tat java.io.BufferedWriter.close(BufferedWriter.java:<span class=\"number\">265</span>)</span><br><span class=\"line\">\tat stream.InputStream.main(InputStream.java:<span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-流操作基本规律\"><a href=\"#4-流操作基本规律\" class=\"headerlink\" title=\"4. 流操作基本规律\"></a>4. 流操作基本规律</h3><p>在阅读了<a href=\"https://www.cnblogs.com/xll1025/p/6418766.html\" target=\"_blank\" rel=\"noopener\">这篇博客</a>之后，他提出的这一点我感觉很好用，也方便记忆，但是博主不允许转载，我也就不贴了。有兴趣的可以点链接看看。</p>\n<p>使用流的思路：</p>\n<ol>\n<li>明确源和目的</li>\n<li>明确操作数据类型（字符或字节）</li>\n<li>明确设备（键盘、内存、文件、网络）</li>\n<li>是否使用buffer</li>\n</ol>\n<p><strong>BufferReader的威力</strong><br>《Java核心技术 卷二》表1-7<br>| 方法      |    时间 |<br>| :——– | ——–:|<br>| 普通输入流  | 110秒 |<br>|带缓冲的输入流|9.9秒|<br>|随机访问文件|162秒|<br>|内存映射文件|7.2秒|<br>相信大家看完这个对比之后能直观的感受到缓冲带来的效率提升。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://segmentfault.com/q/1010000005970993\" target=\"_blank\" rel=\"noopener\">inputStream关闭了，还有必要关闭InputStreamReader和BufferedReader吗？</a><br>[2] <a href=\"https://www.cnblogs.com/xll1025/p/6418766.html\" target=\"_blank\" rel=\"noopener\">JAVA IO流最详解</a><br>[3] 《Java核心技术 卷二》</p>\n</blockquote>"},{"toc":true,"title":"python爬虫之新浪微博评论","date":"2018-03-19T13:29:40.000Z","_content":"\n今天继续进行毕设工作，昨天完成今日头条爬虫之后，今天开始编写微博评论的爬虫。\n\n    环境：\n    ubuntu16.10\n    python3.5\n    \n<!--more-->\n\n一开始我用老一套爬虫方法\"chrome登录网站，F12->network查找相应接口\"，废老劲找到了评论接口，结果返回结果是html格式。于是google微博api，没想到找到这篇[博客](https://www.jianshu.com/p/92de44f0376a)，于是开启了轻松愉快的爬虫。\n\n## [0] 寻找 weibo 评论接口\n爬虫最重要的就是找到合适的接口，这是我目前对爬虫的理解，找到合适的接口能给你减少一半以上的工作。`微博`作为流量数一数二的平台，早就公开了开发者接口。那我们就来看看怎么使用weibo 开发者 api。\n\n## **[1] 微博开放平台创建应用**\n登录[微博开放平台](http://open.weibo.com)，注册个人或公司看自己需求，我注册的个人。\n![Alt text](https://app.yinxiang.com/shard/s15/res/2b4877c5-9e3b-4c4c-af61-167835268cbf)\n微连接-->其他-->随意填写信息，完成新应用创建.\n然后就可以在我的应用中看到自己刚刚创建的应用。点击`应用信息`\n![Alt text](https://app.yinxiang.com/shard/s15/res/624bbf2a-3107-4a44-8395-ceee0761e5a0)\n我们需要的是这个新应用的两样东西：`App Key`和`App Secret`\n点击`高级信息`，将`https://api.weibo.com/oauth2/default.html`填入`授权回调页`和`取消授权回调页`。\n到这里我们已经完成开发者的申请。\n\n## **[2] 微博api 接口**\n在[微博API](http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI#.E8.AF.84.E8.AE.BA)页面找到评论接口：\n![Alt text](https://app.yinxiang.com/shard/s15/res/1b38a717-564f-4aff-9537-e9303a6ed457)\n\n## **[3] 编写简单测试代码**\n\n首先安装 `sinaweibopy` 模块，我本来想尝试用python3装，但是遇到错误：![Alt text](https://app.yinxiang.com/shard/s15/res/aa7be1dc-5bdf-493a-b5d7-24d85f804c5a)。google 百度 都没有找到解决方法。结合[博客：](https://www.jianshu.com/p/92de44f0376a)和错误信息，觉得是这个模块并不支持python3，于是用python2.7进行了测试。\n\n测试代码参考文章[开头链接](https://www.jianshu.com/p/92de44f0376a)。\n\n## **结尾**\n上面是很好的方法，但我并没有使用这种方法，而是爬去这两个接口：\n- 热评接口：`'https://m.weibo.cn/single/rcList?format=cards&id=' + 单条微博id + '&type=comment&hot=1&page=' + 页码\n`最新评论接口：`'https://m.weibo.cn/api/comments/show?id=' + 单条微博id + '&page=' + 页码`\n\n我采用的方法：scrapy + redis +（cookies、ip、UserAgent池）+ Mysql。详情下回揭晓。\n\n\n\n\n","source":"_posts/python爬虫之新浪微博评论.md","raw":"---\ntoc: true\ntitle: python爬虫之新浪微博评论\ndate: 2018-03-19 21:29:40\ntags: [爬虫,新浪微博]\n---\n\n今天继续进行毕设工作，昨天完成今日头条爬虫之后，今天开始编写微博评论的爬虫。\n\n    环境：\n    ubuntu16.10\n    python3.5\n    \n<!--more-->\n\n一开始我用老一套爬虫方法\"chrome登录网站，F12->network查找相应接口\"，废老劲找到了评论接口，结果返回结果是html格式。于是google微博api，没想到找到这篇[博客](https://www.jianshu.com/p/92de44f0376a)，于是开启了轻松愉快的爬虫。\n\n## [0] 寻找 weibo 评论接口\n爬虫最重要的就是找到合适的接口，这是我目前对爬虫的理解，找到合适的接口能给你减少一半以上的工作。`微博`作为流量数一数二的平台，早就公开了开发者接口。那我们就来看看怎么使用weibo 开发者 api。\n\n## **[1] 微博开放平台创建应用**\n登录[微博开放平台](http://open.weibo.com)，注册个人或公司看自己需求，我注册的个人。\n![Alt text](https://app.yinxiang.com/shard/s15/res/2b4877c5-9e3b-4c4c-af61-167835268cbf)\n微连接-->其他-->随意填写信息，完成新应用创建.\n然后就可以在我的应用中看到自己刚刚创建的应用。点击`应用信息`\n![Alt text](https://app.yinxiang.com/shard/s15/res/624bbf2a-3107-4a44-8395-ceee0761e5a0)\n我们需要的是这个新应用的两样东西：`App Key`和`App Secret`\n点击`高级信息`，将`https://api.weibo.com/oauth2/default.html`填入`授权回调页`和`取消授权回调页`。\n到这里我们已经完成开发者的申请。\n\n## **[2] 微博api 接口**\n在[微博API](http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI#.E8.AF.84.E8.AE.BA)页面找到评论接口：\n![Alt text](https://app.yinxiang.com/shard/s15/res/1b38a717-564f-4aff-9537-e9303a6ed457)\n\n## **[3] 编写简单测试代码**\n\n首先安装 `sinaweibopy` 模块，我本来想尝试用python3装，但是遇到错误：![Alt text](https://app.yinxiang.com/shard/s15/res/aa7be1dc-5bdf-493a-b5d7-24d85f804c5a)。google 百度 都没有找到解决方法。结合[博客：](https://www.jianshu.com/p/92de44f0376a)和错误信息，觉得是这个模块并不支持python3，于是用python2.7进行了测试。\n\n测试代码参考文章[开头链接](https://www.jianshu.com/p/92de44f0376a)。\n\n## **结尾**\n上面是很好的方法，但我并没有使用这种方法，而是爬去这两个接口：\n- 热评接口：`'https://m.weibo.cn/single/rcList?format=cards&id=' + 单条微博id + '&type=comment&hot=1&page=' + 页码\n`最新评论接口：`'https://m.weibo.cn/api/comments/show?id=' + 单条微博id + '&page=' + 页码`\n\n我采用的方法：scrapy + redis +（cookies、ip、UserAgent池）+ Mysql。详情下回揭晓。\n\n\n\n\n","slug":"python爬虫之新浪微博评论","published":1,"updated":"2018-08-13T14:28:27.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4a000g6k15feat1z3i","content":"<p>今天继续进行毕设工作，昨天完成今日头条爬虫之后，今天开始编写微博评论的爬虫。</p>\n<pre><code>环境：\nubuntu16.10\npython3.5\n</code></pre><a id=\"more\"></a>\n<p>一开始我用老一套爬虫方法”chrome登录网站，F12-&gt;network查找相应接口”，废老劲找到了评论接口，结果返回结果是html格式。于是google微博api，没想到找到这篇<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">博客</a>，于是开启了轻松愉快的爬虫。</p>\n<h2 id=\"0-寻找-weibo-评论接口\"><a href=\"#0-寻找-weibo-评论接口\" class=\"headerlink\" title=\"[0] 寻找 weibo 评论接口\"></a>[0] 寻找 weibo 评论接口</h2><p>爬虫最重要的就是找到合适的接口，这是我目前对爬虫的理解，找到合适的接口能给你减少一半以上的工作。<code>微博</code>作为流量数一数二的平台，早就公开了开发者接口。那我们就来看看怎么使用weibo 开发者 api。</p>\n<h2 id=\"1-微博开放平台创建应用\"><a href=\"#1-微博开放平台创建应用\" class=\"headerlink\" title=\"[1] 微博开放平台创建应用\"></a><strong>[1] 微博开放平台创建应用</strong></h2><p>登录<a href=\"http://open.weibo.com\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，注册个人或公司看自己需求，我注册的个人。<br><img src=\"https://app.yinxiang.com/shard/s15/res/2b4877c5-9e3b-4c4c-af61-167835268cbf\" alt=\"Alt text\"><br>微连接–&gt;其他–&gt;随意填写信息，完成新应用创建.<br>然后就可以在我的应用中看到自己刚刚创建的应用。点击<code>应用信息</code><br><img src=\"https://app.yinxiang.com/shard/s15/res/624bbf2a-3107-4a44-8395-ceee0761e5a0\" alt=\"Alt text\"><br>我们需要的是这个新应用的两样东西：<code>App Key</code>和<code>App Secret</code><br>点击<code>高级信息</code>，将<code>https://api.weibo.com/oauth2/default.html</code>填入<code>授权回调页</code>和<code>取消授权回调页</code>。<br>到这里我们已经完成开发者的申请。</p>\n<h2 id=\"2-微博api-接口\"><a href=\"#2-微博api-接口\" class=\"headerlink\" title=\"[2] 微博api 接口\"></a><strong>[2] 微博api 接口</strong></h2><p>在<a href=\"http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI#.E8.AF.84.E8.AE.BA\" target=\"_blank\" rel=\"noopener\">微博API</a>页面找到评论接口：<br><img src=\"https://app.yinxiang.com/shard/s15/res/1b38a717-564f-4aff-9537-e9303a6ed457\" alt=\"Alt text\"></p>\n<h2 id=\"3-编写简单测试代码\"><a href=\"#3-编写简单测试代码\" class=\"headerlink\" title=\"[3] 编写简单测试代码\"></a><strong>[3] 编写简单测试代码</strong></h2><p>首先安装 <code>sinaweibopy</code> 模块，我本来想尝试用python3装，但是遇到错误：<img src=\"https://app.yinxiang.com/shard/s15/res/aa7be1dc-5bdf-493a-b5d7-24d85f804c5a\" alt=\"Alt text\">。google 百度 都没有找到解决方法。结合<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">博客：</a>和错误信息，觉得是这个模块并不支持python3，于是用python2.7进行了测试。</p>\n<p>测试代码参考文章<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">开头链接</a>。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a><strong>结尾</strong></h2><p>上面是很好的方法，但我并没有使用这种方法，而是爬去这两个接口：</p>\n<ul>\n<li>热评接口：<code>&#39;https://m.weibo.cn/single/rcList?format=cards&amp;id=&#39; + 单条微博id + &#39;&amp;type=comment&amp;hot=1&amp;page=&#39; + 页码</code>最新评论接口：<code>&#39;https://m.weibo.cn/api/comments/show?id=&#39; + 单条微博id + &#39;&amp;page=&#39; + 页码</code></li>\n</ul>\n<p>我采用的方法：scrapy + redis +（cookies、ip、UserAgent池）+ Mysql。详情下回揭晓。</p>\n","site":{"data":{}},"excerpt":"<p>今天继续进行毕设工作，昨天完成今日头条爬虫之后，今天开始编写微博评论的爬虫。</p>\n<pre><code>环境：\nubuntu16.10\npython3.5\n</code></pre>","more":"<p>一开始我用老一套爬虫方法”chrome登录网站，F12-&gt;network查找相应接口”，废老劲找到了评论接口，结果返回结果是html格式。于是google微博api，没想到找到这篇<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">博客</a>，于是开启了轻松愉快的爬虫。</p>\n<h2 id=\"0-寻找-weibo-评论接口\"><a href=\"#0-寻找-weibo-评论接口\" class=\"headerlink\" title=\"[0] 寻找 weibo 评论接口\"></a>[0] 寻找 weibo 评论接口</h2><p>爬虫最重要的就是找到合适的接口，这是我目前对爬虫的理解，找到合适的接口能给你减少一半以上的工作。<code>微博</code>作为流量数一数二的平台，早就公开了开发者接口。那我们就来看看怎么使用weibo 开发者 api。</p>\n<h2 id=\"1-微博开放平台创建应用\"><a href=\"#1-微博开放平台创建应用\" class=\"headerlink\" title=\"[1] 微博开放平台创建应用\"></a><strong>[1] 微博开放平台创建应用</strong></h2><p>登录<a href=\"http://open.weibo.com\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，注册个人或公司看自己需求，我注册的个人。<br><img src=\"https://app.yinxiang.com/shard/s15/res/2b4877c5-9e3b-4c4c-af61-167835268cbf\" alt=\"Alt text\"><br>微连接–&gt;其他–&gt;随意填写信息，完成新应用创建.<br>然后就可以在我的应用中看到自己刚刚创建的应用。点击<code>应用信息</code><br><img src=\"https://app.yinxiang.com/shard/s15/res/624bbf2a-3107-4a44-8395-ceee0761e5a0\" alt=\"Alt text\"><br>我们需要的是这个新应用的两样东西：<code>App Key</code>和<code>App Secret</code><br>点击<code>高级信息</code>，将<code>https://api.weibo.com/oauth2/default.html</code>填入<code>授权回调页</code>和<code>取消授权回调页</code>。<br>到这里我们已经完成开发者的申请。</p>\n<h2 id=\"2-微博api-接口\"><a href=\"#2-微博api-接口\" class=\"headerlink\" title=\"[2] 微博api 接口\"></a><strong>[2] 微博api 接口</strong></h2><p>在<a href=\"http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9AAPI#.E8.AF.84.E8.AE.BA\" target=\"_blank\" rel=\"noopener\">微博API</a>页面找到评论接口：<br><img src=\"https://app.yinxiang.com/shard/s15/res/1b38a717-564f-4aff-9537-e9303a6ed457\" alt=\"Alt text\"></p>\n<h2 id=\"3-编写简单测试代码\"><a href=\"#3-编写简单测试代码\" class=\"headerlink\" title=\"[3] 编写简单测试代码\"></a><strong>[3] 编写简单测试代码</strong></h2><p>首先安装 <code>sinaweibopy</code> 模块，我本来想尝试用python3装，但是遇到错误：<img src=\"https://app.yinxiang.com/shard/s15/res/aa7be1dc-5bdf-493a-b5d7-24d85f804c5a\" alt=\"Alt text\">。google 百度 都没有找到解决方法。结合<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">博客：</a>和错误信息，觉得是这个模块并不支持python3，于是用python2.7进行了测试。</p>\n<p>测试代码参考文章<a href=\"https://www.jianshu.com/p/92de44f0376a\" target=\"_blank\" rel=\"noopener\">开头链接</a>。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a><strong>结尾</strong></h2><p>上面是很好的方法，但我并没有使用这种方法，而是爬去这两个接口：</p>\n<ul>\n<li>热评接口：<code>&#39;https://m.weibo.cn/single/rcList?format=cards&amp;id=&#39; + 单条微博id + &#39;&amp;type=comment&amp;hot=1&amp;page=&#39; + 页码</code>最新评论接口：<code>&#39;https://m.weibo.cn/api/comments/show?id=&#39; + 单条微博id + &#39;&amp;page=&#39; + 页码</code></li>\n</ul>\n<p>我采用的方法：scrapy + redis +（cookies、ip、UserAgent池）+ Mysql。详情下回揭晓。</p>"},{"toc":true,"title":"《Spring实战》搭建Spring MVC","date":"2018-04-08T08:19:01.000Z","_content":"\n本文采用Java将`DispatcherServlet`配置在`Servlet`容器中，而不会再使用`web.xml`文件。\n\n### 1. Spring MVC启动流程\n![Spring MVC启动流程图](https://app.yinxiang.com/shard/s15/res/683c4f95-8bd2-42f5-9024-8519c1b9a121/1523191585434.png)\n<!--more-->\n#### 1.1 \n\n### 2. 搭建web项目\n\n#### 2.1 使用maven创建webapp项目\nmaven是一款管理java项目依赖、编译、发布的工具。我们可以使用Idea或直接使用maven命令来创建`Spittr`项目。\n- maven 命令\n`mvn archetype:generate  -DarchetypeCatalog=local -DgroupId=com.jifang -DartifactId=spittr -DarchetypeArtifactId=maven-archetype-webapp `\n\n注意`-DarchetypeCatalog=local`这里使用的是local而不是remote，因为使用remote需要去远程仓库下载，速度很慢，使用local很快。\n- Idea 使用maven创建webapp项目\n![Alt text](https://app.yinxiang.com/shard/s15/res/31c0786e-fa14-4cfe-93a8-95f8d1191cda/1523173940956.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/0721e144-8736-488a-8c49-d31a5a0dabae/1523173969014.png)\n填入`groupId`和`ArtifactId`即可，同样的可以在Idea的settings中将maven运行参数设置一下：\n![Alt text](https://app.yinxiang.com/shard/s15/res/8cfc7e4e-7feb-4462-a5de-6fa1c954704f/1523174186104.png)\n\n#### 2.2 配置DispatcherServlet\n`DispatcherServlet`是Spring MVC的核心。按照传统方式，像DispatcherServlet这样的Servlet会配置在web.xml文件中，这个文件会放到应用的war包里。但是，借助于Servlet 3规范和Spring 3.1的功能增强，我们可以使用JavaConfig方式配置。\n\n```java\npackage com.jifang.spittr.config;\n\nimport com.jifang.spittr.config.RootConfig;\nimport com.jifang.spittr.config.WebConfig;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * author: jifang\n * date: 18-4-6 上午11:11\n */\n\npublic class SpittrWebAppInitlizer extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[]{RootConfig.class};\n    }\n\n    /**\n     * 指定配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[]{WebConfig.class};\n    }\n\n    /**\n     * 将DispatcherServlet映射到\"/\"\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/*\"};\n    }\n}keyikandao\n```\n这里有两个方法`getRootConfigClasses`和`getServletConfigClasses`，而且他们返回了两个Class类型的数组，每一个都包含独特的一个类，分别是`RootConfig`和`WebConfig`。我们先来看看这两个类都是什么样的。\n【RootConfig.java】\n```java\npackage com.jifang.spittr.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * author: jifang\n * date: 18-4-6 上午11:25\n */\n\n@Configuration\n@ComponentScan(basePackages = {\"com.jifang.spittr\"},\n    excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)})\npublic class RootConfig {\n}\n```\n【WebConfig.java】\n```java\npackage com.jifang.spittr.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n/**\n * 最小但可用的Spring MVC配置\n * author: jifang\n * date: 18-4-6 上午11:26\n */\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.jifang.spittr.web\")\npublic class WebConfig extends WebMvcConfigurerAdapter{\n\n\t/**\n     * 配置JSP视图解析器\n     * @return\n     */\n    @Bean\n    public ViewResolver viewResolver(){\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        //使得可以在JSP页面中通过${ }访问容器中的bean。\n        resolver.setExposeContextBeansAsAttributes(true);\n        return resolver;\n    }\n\n\t/**\n     * 配置静态资源的处理\n     * @param configurer\n     */\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n}\n```\nSpringMVC 项目启动时配置的东西还有很多，HandlerException 异常处理，数据校验等，这些Spring提供的抽象类WebMvcConfigurerAdapter中已经实现好了，我们在项目中直接继承就行了。\n\n\nrootConfig应该扫描除了@Controller注解以外的注解，webConfig专注扫描的@Controller注解。容器启动时加载顺序是 先RootConfig 后WebConfig，RootConfig先加载时会创建Controller层的单例，紧接着WebConfig加载时会检测相应的Bean是否已经创建，若父容器（RootConfig）已经创建了该Bean，子容器（WebConfig）就不会再去创建了。关于`RootConfig`和`WebConfig`这两个类之间的区别可以参考我的下一篇文章：[AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别](http://cap-ljf.top/2018/04/08/AbstractAnnotationConfigDispatcherServletInitializer%E7%B1%BB%E6%96%B9%E6%B3%95getRootConfigClasses%E5%92%8CgetServletConfigClasses%E5%8C%BA%E5%88%AB/)\n\n#### 2.3 定义最简单的Controller\n```java\npackage com.jifang.spittr.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n/**\n * author: jifang\n * date: 18-4-6 下午2:07\n */\n@Controller\n@RequestMapping({\"/\",\"/homepage\"})\npublic class HomeController {\n    @RequestMapping(method = RequestMethod.GET)\n    public String home(){\n        return \"home\";\n    }\n}\n```\n\n包结构：\n![Alt text](https://app.yinxiang.com/shard/s15/res/70895f8c-2de6-485f-8ace-fe1b53a60c18/1523176016984.png)\n*框起来的是必须的*\n\npom文件：\n```xml\n<dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- Spring相关 -->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n  </dependencies>\n```\n配置好tomcat启动项目，运行之后可以看到Hello World！\n\n> 参考文献\n> [1] [零配置简单搭建SpringMVC 项目](http://www.cnblogs.com/beiyan/p/5942741.html)\n> [2] 《Spring实战》4th\n\n\n\n\n\n","source":"_posts/《Spring实战》搭建Spring-MVC.md","raw":"---\ntoc: true\ntitle: 《Spring实战》搭建Spring MVC\ndate: 2018-04-08 16:19:01\ntags: [Spring,web,Spring MVC]\n---\n\n本文采用Java将`DispatcherServlet`配置在`Servlet`容器中，而不会再使用`web.xml`文件。\n\n### 1. Spring MVC启动流程\n![Spring MVC启动流程图](https://app.yinxiang.com/shard/s15/res/683c4f95-8bd2-42f5-9024-8519c1b9a121/1523191585434.png)\n<!--more-->\n#### 1.1 \n\n### 2. 搭建web项目\n\n#### 2.1 使用maven创建webapp项目\nmaven是一款管理java项目依赖、编译、发布的工具。我们可以使用Idea或直接使用maven命令来创建`Spittr`项目。\n- maven 命令\n`mvn archetype:generate  -DarchetypeCatalog=local -DgroupId=com.jifang -DartifactId=spittr -DarchetypeArtifactId=maven-archetype-webapp `\n\n注意`-DarchetypeCatalog=local`这里使用的是local而不是remote，因为使用remote需要去远程仓库下载，速度很慢，使用local很快。\n- Idea 使用maven创建webapp项目\n![Alt text](https://app.yinxiang.com/shard/s15/res/31c0786e-fa14-4cfe-93a8-95f8d1191cda/1523173940956.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/0721e144-8736-488a-8c49-d31a5a0dabae/1523173969014.png)\n填入`groupId`和`ArtifactId`即可，同样的可以在Idea的settings中将maven运行参数设置一下：\n![Alt text](https://app.yinxiang.com/shard/s15/res/8cfc7e4e-7feb-4462-a5de-6fa1c954704f/1523174186104.png)\n\n#### 2.2 配置DispatcherServlet\n`DispatcherServlet`是Spring MVC的核心。按照传统方式，像DispatcherServlet这样的Servlet会配置在web.xml文件中，这个文件会放到应用的war包里。但是，借助于Servlet 3规范和Spring 3.1的功能增强，我们可以使用JavaConfig方式配置。\n\n```java\npackage com.jifang.spittr.config;\n\nimport com.jifang.spittr.config.RootConfig;\nimport com.jifang.spittr.config.WebConfig;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * author: jifang\n * date: 18-4-6 上午11:11\n */\n\npublic class SpittrWebAppInitlizer extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[]{RootConfig.class};\n    }\n\n    /**\n     * 指定配置类\n     * @return\n     */\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[]{WebConfig.class};\n    }\n\n    /**\n     * 将DispatcherServlet映射到\"/\"\n     * @return\n     */\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/*\"};\n    }\n}keyikandao\n```\n这里有两个方法`getRootConfigClasses`和`getServletConfigClasses`，而且他们返回了两个Class类型的数组，每一个都包含独特的一个类，分别是`RootConfig`和`WebConfig`。我们先来看看这两个类都是什么样的。\n【RootConfig.java】\n```java\npackage com.jifang.spittr.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * author: jifang\n * date: 18-4-6 上午11:25\n */\n\n@Configuration\n@ComponentScan(basePackages = {\"com.jifang.spittr\"},\n    excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)})\npublic class RootConfig {\n}\n```\n【WebConfig.java】\n```java\npackage com.jifang.spittr.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n/**\n * 最小但可用的Spring MVC配置\n * author: jifang\n * date: 18-4-6 上午11:26\n */\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.jifang.spittr.web\")\npublic class WebConfig extends WebMvcConfigurerAdapter{\n\n\t/**\n     * 配置JSP视图解析器\n     * @return\n     */\n    @Bean\n    public ViewResolver viewResolver(){\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        //使得可以在JSP页面中通过${ }访问容器中的bean。\n        resolver.setExposeContextBeansAsAttributes(true);\n        return resolver;\n    }\n\n\t/**\n     * 配置静态资源的处理\n     * @param configurer\n     */\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n}\n```\nSpringMVC 项目启动时配置的东西还有很多，HandlerException 异常处理，数据校验等，这些Spring提供的抽象类WebMvcConfigurerAdapter中已经实现好了，我们在项目中直接继承就行了。\n\n\nrootConfig应该扫描除了@Controller注解以外的注解，webConfig专注扫描的@Controller注解。容器启动时加载顺序是 先RootConfig 后WebConfig，RootConfig先加载时会创建Controller层的单例，紧接着WebConfig加载时会检测相应的Bean是否已经创建，若父容器（RootConfig）已经创建了该Bean，子容器（WebConfig）就不会再去创建了。关于`RootConfig`和`WebConfig`这两个类之间的区别可以参考我的下一篇文章：[AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别](http://cap-ljf.top/2018/04/08/AbstractAnnotationConfigDispatcherServletInitializer%E7%B1%BB%E6%96%B9%E6%B3%95getRootConfigClasses%E5%92%8CgetServletConfigClasses%E5%8C%BA%E5%88%AB/)\n\n#### 2.3 定义最简单的Controller\n```java\npackage com.jifang.spittr.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n/**\n * author: jifang\n * date: 18-4-6 下午2:07\n */\n@Controller\n@RequestMapping({\"/\",\"/homepage\"})\npublic class HomeController {\n    @RequestMapping(method = RequestMethod.GET)\n    public String home(){\n        return \"home\";\n    }\n}\n```\n\n包结构：\n![Alt text](https://app.yinxiang.com/shard/s15/res/70895f8c-2de6-485f-8ace-fe1b53a60c18/1523176016984.png)\n*框起来的是必须的*\n\npom文件：\n```xml\n<dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n    <!-- Spring相关 -->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-webmvc</artifactId>\n      <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n  </dependencies>\n```\n配置好tomcat启动项目，运行之后可以看到Hello World！\n\n> 参考文献\n> [1] [零配置简单搭建SpringMVC 项目](http://www.cnblogs.com/beiyan/p/5942741.html)\n> [2] 《Spring实战》4th\n\n\n\n\n\n","slug":"《Spring实战》搭建Spring-MVC","published":1,"updated":"2018-08-13T14:28:27.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4c000i6k153ajwrqqn","content":"<p>本文采用Java将<code>DispatcherServlet</code>配置在<code>Servlet</code>容器中，而不会再使用<code>web.xml</code>文件。</p>\n<h3 id=\"1-Spring-MVC启动流程\"><a href=\"#1-Spring-MVC启动流程\" class=\"headerlink\" title=\"1. Spring MVC启动流程\"></a>1. Spring MVC启动流程</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/683c4f95-8bd2-42f5-9024-8519c1b9a121/1523191585434.png\" alt=\"Spring MVC启动流程图\"><br><a id=\"more\"></a></p>\n<h4 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h4><h3 id=\"2-搭建web项目\"><a href=\"#2-搭建web项目\" class=\"headerlink\" title=\"2. 搭建web项目\"></a>2. 搭建web项目</h3><h4 id=\"2-1-使用maven创建webapp项目\"><a href=\"#2-1-使用maven创建webapp项目\" class=\"headerlink\" title=\"2.1 使用maven创建webapp项目\"></a>2.1 使用maven创建webapp项目</h4><p>maven是一款管理java项目依赖、编译、发布的工具。我们可以使用Idea或直接使用maven命令来创建<code>Spittr</code>项目。</p>\n<ul>\n<li>maven 命令<br><code>mvn archetype:generate  -DarchetypeCatalog=local -DgroupId=com.jifang -DartifactId=spittr -DarchetypeArtifactId=maven-archetype-webapp</code></li>\n</ul>\n<p>注意<code>-DarchetypeCatalog=local</code>这里使用的是local而不是remote，因为使用remote需要去远程仓库下载，速度很慢，使用local很快。</p>\n<ul>\n<li>Idea 使用maven创建webapp项目<br><img src=\"https://app.yinxiang.com/shard/s15/res/31c0786e-fa14-4cfe-93a8-95f8d1191cda/1523173940956.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/0721e144-8736-488a-8c49-d31a5a0dabae/1523173969014.png\" alt=\"Alt text\"><br>填入<code>groupId</code>和<code>ArtifactId</code>即可，同样的可以在Idea的settings中将maven运行参数设置一下：<br><img src=\"https://app.yinxiang.com/shard/s15/res/8cfc7e4e-7feb-4462-a5de-6fa1c954704f/1523174186104.png\" alt=\"Alt text\"></li>\n</ul>\n<h4 id=\"2-2-配置DispatcherServlet\"><a href=\"#2-2-配置DispatcherServlet\" class=\"headerlink\" title=\"2.2 配置DispatcherServlet\"></a>2.2 配置DispatcherServlet</h4><p><code>DispatcherServlet</code>是Spring MVC的核心。按照传统方式，像DispatcherServlet这样的Servlet会配置在web.xml文件中，这个文件会放到应用的war包里。但是，借助于Servlet 3规范和Spring 3.1的功能增强，我们可以使用JavaConfig方式配置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.config.RootConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.config.WebConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittrWebAppInitlizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定配置类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将DispatcherServlet映射到\"/\"</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"/*\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;keyikandao</span><br></pre></td></tr></table></figure>\n<p>这里有两个方法<code>getRootConfigClasses</code>和<code>getServletConfigClasses</code>，而且他们返回了两个Class类型的数组，每一个都包含独特的一个类，分别是<code>RootConfig</code>和<code>WebConfig</code>。我们先来看看这两个类都是什么样的。<br>【RootConfig.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.FilterType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:25</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages = &#123;<span class=\"string\">\"com.jifang.spittr\"</span>&#125;,</span><br><span class=\"line\">    excludeFilters = &#123;<span class=\"meta\">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【WebConfig.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最小但可用的Spring MVC配置</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:26</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"com.jifang.spittr.web\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置JSP视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewResolver <span class=\"title\">viewResolver</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        InternalResourceViewResolver resolver = <span class=\"keyword\">new</span> InternalResourceViewResolver();</span><br><span class=\"line\">        resolver.setPrefix(<span class=\"string\">\"/WEB-INF/views/\"</span>);</span><br><span class=\"line\">        resolver.setSuffix(<span class=\"string\">\".jsp\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//使得可以在JSP页面中通过$&#123; &#125;访问容器中的bean。</span></span><br><span class=\"line\">        resolver.setExposeContextBeansAsAttributes(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置静态资源的处理</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configurer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configureDefaultServletHandling</span><span class=\"params\">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class=\"line\">        configurer.enable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SpringMVC 项目启动时配置的东西还有很多，HandlerException 异常处理，数据校验等，这些Spring提供的抽象类WebMvcConfigurerAdapter中已经实现好了，我们在项目中直接继承就行了。</p>\n<p>rootConfig应该扫描除了@Controller注解以外的注解，webConfig专注扫描的@Controller注解。容器启动时加载顺序是 先RootConfig 后WebConfig，RootConfig先加载时会创建Controller层的单例，紧接着WebConfig加载时会检测相应的Bean是否已经创建，若父容器（RootConfig）已经创建了该Bean，子容器（WebConfig）就不会再去创建了。关于<code>RootConfig</code>和<code>WebConfig</code>这两个类之间的区别可以参考我的下一篇文章：<a href=\"http://cap-ljf.top/2018/04/08/AbstractAnnotationConfigDispatcherServletInitializer%E7%B1%BB%E6%96%B9%E6%B3%95getRootConfigClasses%E5%92%8CgetServletConfigClasses%E5%8C%BA%E5%88%AB/\">AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别</a></p>\n<h4 id=\"2-3-定义最简单的Controller\"><a href=\"#2-3-定义最简单的Controller\" class=\"headerlink\" title=\"2.3 定义最简单的Controller\"></a>2.3 定义最简单的Controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 下午2:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(&#123;<span class=\"string\">\"/\"</span>,<span class=\"string\">\"/homepage\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">home</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包结构：<br><img src=\"https://app.yinxiang.com/shard/s15/res/70895f8c-2de6-485f-8ace-fe1b53a60c18/1523176016984.png\" alt=\"Alt text\"><br><em>框起来的是必须的</em></p>\n<p>pom文件：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Spring相关 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jstl<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>配置好tomcat启动项目，运行之后可以看到Hello World！</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://www.cnblogs.com/beiyan/p/5942741.html\" target=\"_blank\" rel=\"noopener\">零配置简单搭建SpringMVC 项目</a><br>[2] 《Spring实战》4th</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>本文采用Java将<code>DispatcherServlet</code>配置在<code>Servlet</code>容器中，而不会再使用<code>web.xml</code>文件。</p>\n<h3 id=\"1-Spring-MVC启动流程\"><a href=\"#1-Spring-MVC启动流程\" class=\"headerlink\" title=\"1. Spring MVC启动流程\"></a>1. Spring MVC启动流程</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/683c4f95-8bd2-42f5-9024-8519c1b9a121/1523191585434.png\" alt=\"Spring MVC启动流程图\"><br>","more":"</p>\n<h4 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h4><h3 id=\"2-搭建web项目\"><a href=\"#2-搭建web项目\" class=\"headerlink\" title=\"2. 搭建web项目\"></a>2. 搭建web项目</h3><h4 id=\"2-1-使用maven创建webapp项目\"><a href=\"#2-1-使用maven创建webapp项目\" class=\"headerlink\" title=\"2.1 使用maven创建webapp项目\"></a>2.1 使用maven创建webapp项目</h4><p>maven是一款管理java项目依赖、编译、发布的工具。我们可以使用Idea或直接使用maven命令来创建<code>Spittr</code>项目。</p>\n<ul>\n<li>maven 命令<br><code>mvn archetype:generate  -DarchetypeCatalog=local -DgroupId=com.jifang -DartifactId=spittr -DarchetypeArtifactId=maven-archetype-webapp</code></li>\n</ul>\n<p>注意<code>-DarchetypeCatalog=local</code>这里使用的是local而不是remote，因为使用remote需要去远程仓库下载，速度很慢，使用local很快。</p>\n<ul>\n<li>Idea 使用maven创建webapp项目<br><img src=\"https://app.yinxiang.com/shard/s15/res/31c0786e-fa14-4cfe-93a8-95f8d1191cda/1523173940956.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/0721e144-8736-488a-8c49-d31a5a0dabae/1523173969014.png\" alt=\"Alt text\"><br>填入<code>groupId</code>和<code>ArtifactId</code>即可，同样的可以在Idea的settings中将maven运行参数设置一下：<br><img src=\"https://app.yinxiang.com/shard/s15/res/8cfc7e4e-7feb-4462-a5de-6fa1c954704f/1523174186104.png\" alt=\"Alt text\"></li>\n</ul>\n<h4 id=\"2-2-配置DispatcherServlet\"><a href=\"#2-2-配置DispatcherServlet\" class=\"headerlink\" title=\"2.2 配置DispatcherServlet\"></a>2.2 配置DispatcherServlet</h4><p><code>DispatcherServlet</code>是Spring MVC的核心。按照传统方式，像DispatcherServlet这样的Servlet会配置在web.xml文件中，这个文件会放到应用的war包里。但是，借助于Servlet 3规范和Spring 3.1的功能增强，我们可以使用JavaConfig方式配置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.config.RootConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.config.WebConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittrWebAppInitlizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定配置类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将DispatcherServlet映射到\"/\"</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"/*\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;keyikandao</span><br></pre></td></tr></table></figure>\n<p>这里有两个方法<code>getRootConfigClasses</code>和<code>getServletConfigClasses</code>，而且他们返回了两个Class类型的数组，每一个都包含独特的一个类，分别是<code>RootConfig</code>和<code>WebConfig</code>。我们先来看看这两个类都是什么样的。<br>【RootConfig.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.FilterType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:25</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages = &#123;<span class=\"string\">\"com.jifang.spittr\"</span>&#125;,</span><br><span class=\"line\">    excludeFilters = &#123;<span class=\"meta\">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【WebConfig.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最小但可用的Spring MVC配置</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 上午11:26</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"com.jifang.spittr.web\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置JSP视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewResolver <span class=\"title\">viewResolver</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        InternalResourceViewResolver resolver = <span class=\"keyword\">new</span> InternalResourceViewResolver();</span><br><span class=\"line\">        resolver.setPrefix(<span class=\"string\">\"/WEB-INF/views/\"</span>);</span><br><span class=\"line\">        resolver.setSuffix(<span class=\"string\">\".jsp\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//使得可以在JSP页面中通过$&#123; &#125;访问容器中的bean。</span></span><br><span class=\"line\">        resolver.setExposeContextBeansAsAttributes(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置静态资源的处理</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configurer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configureDefaultServletHandling</span><span class=\"params\">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class=\"line\">        configurer.enable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SpringMVC 项目启动时配置的东西还有很多，HandlerException 异常处理，数据校验等，这些Spring提供的抽象类WebMvcConfigurerAdapter中已经实现好了，我们在项目中直接继承就行了。</p>\n<p>rootConfig应该扫描除了@Controller注解以外的注解，webConfig专注扫描的@Controller注解。容器启动时加载顺序是 先RootConfig 后WebConfig，RootConfig先加载时会创建Controller层的单例，紧接着WebConfig加载时会检测相应的Bean是否已经创建，若父容器（RootConfig）已经创建了该Bean，子容器（WebConfig）就不会再去创建了。关于<code>RootConfig</code>和<code>WebConfig</code>这两个类之间的区别可以参考我的下一篇文章：<a href=\"http://cap-ljf.top/2018/04/08/AbstractAnnotationConfigDispatcherServletInitializer%E7%B1%BB%E6%96%B9%E6%B3%95getRootConfigClasses%E5%92%8CgetServletConfigClasses%E5%8C%BA%E5%88%AB/\">AbstractAnnotationConfigDispatcherServletInitializer类方法getRootConfigClasses和getServletConfigClasses区别</a></p>\n<h4 id=\"2-3-定义最简单的Controller\"><a href=\"#2-3-定义最简单的Controller\" class=\"headerlink\" title=\"2.3 定义最简单的Controller\"></a>2.3 定义最简单的Controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-6 下午2:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(&#123;<span class=\"string\">\"/\"</span>,<span class=\"string\">\"/homepage\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">home</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包结构：<br><img src=\"https://app.yinxiang.com/shard/s15/res/70895f8c-2de6-485f-8ace-fe1b53a60c18/1523176016984.png\" alt=\"Alt text\"><br><em>框起来的是必须的</em></p>\n<p>pom文件：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Spring相关 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jstl<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>配置好tomcat启动项目，运行之后可以看到Hello World！</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://www.cnblogs.com/beiyan/p/5942741.html\" target=\"_blank\" rel=\"noopener\">零配置简单搭建SpringMVC 项目</a><br>[2] 《Spring实战》4th</p>\n</blockquote>"},{"toc":true,"title":"《Spring实战》高级装配","date":"2018-04-04T07:11:57.000Z","_content":"\n\n- Spring profile\n- 条件化的bean声明\n- 自动装配及歧义性\n- bean的作用域\n- SpEL\n<!--more-->\n### 1. 环境与profile\n\n在正常开发过程中，我们会有不同的环境。例如：\n- 开发环境（dev）：也就是每个人在电脑上进行开发的环境。\n- Beta环境（beta）：即测试环境，QA环境，在测试机器上运行的环境。\n- 线上环境（prod）：也称为生产环境。即在线上机器上跑的环境。\n\n这里的环境指的是类似于数据库，ng等资源。\n\n#### 1.1 配置profile bean\n**在JavaConfig中配置profile**\n`@Profile(\"dev\")`：这个注解可以应用在类或方法上。如果应用于类级别上，他会告诉Spring这个配置类中的bean在相应dev profile 激活时才会创建。如果dev profile没有激活的话，那么带有`@Bean`注解的方法都会被忽略。\n\n在Spring 3.1中,只能在类级别上使用@Profile注解。不过,从Spring 3.2开始,你也可以在方法级别上使用@Profile注解,与@Bean注解一同使用。这样的话,就能将这两个bean的声明放到同一个配置类之中。\n\n没有指定profile的bean始终都会被创建,与激活哪个profile没有关系。\n\n**在XML中配置profile**\n使用标签：\n```xml\n<beans profile=\"dev\">\n\t这里定义相应的bean\n</beans>\n```\n\n### 2. 激活profile\n\nSpring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：`spring.profiles.active`和`spring.profiles.default`。如果设置了`spring.profiles.active`属性的话,那么它的值就会用来确定哪个profile是激活的。但如果没有设置`spring.profiles.active`属性的话,那Spring将会查找`spring.profiles.default`的值。如果`spring.profiles.active`和`spring.profiles.default`均没有设置的话,那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。\n\n有多种方法来设置这两种属性：\n- 作为DispatcherServlet的初始化参数;\n- 作为Web应用的上下文参数;\n- 作为JNDI条目;\n- 作为环境变量;\n- 作为JVM的系统属性;\n- 在集成测试类上,使用@ActiveProfiles注解设置。\n\n\n**在Web应用的web.xml文件中设置默认的profile**\n\n```xml\n# 为web应用上下文设置默认的profile\n<context-param>\n\t<param-name>spring.profiles.default</param-name>\n\t<param-value>dev</param-value>\n</context-param>\n# 为Servlet设置默认的profile\n<servlet>\n\t<servlet-name>appServlet</servlet-name>\n\t<servlet-class>\n\t\torg.springframework.web.servlet.DispatcherServlet\n\t</servlet-class>\n\t<init-param>\n\t\t<param-name>spring.profile.default</param-name>\n\t\t<param-value>dev</param-value>\n\t</init-param>\n</servlet>\n...\n```\n\n**使用profile进行测试**\n当运行集成测试时,通常会希望采用与生产环境(或者是生产环境的部分子集)相同的配置进行测试。但是,如果配置中的bean定义在了profile中,那么在运行测试时,我们就需要有一种方式来启用合适的profile。\n\nSpring提供了@ActiveProfiles注解,我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时,通常想要激活的是开发环境的profile。例如,下面的测试类片段展现了使用@ActiveProfiles激活dev profile:\n```java\n  @RunWith(SpringJUnit4ClassRunner.class)\n  @ContextConfiguration(classes=DataSourceConfig.class)\n  @ActiveProfiles(\"dev\")\n  public static class DevDataSourceTest {\n  }\n```\n\n### 2. 条件化bean\n假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后,才会创建某个bean。\n\nSpring4引入了一个新的注解：\n`@Conditional`：它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true,就会创建这个bean,否则的话,这个bean会被忽略。\n```java\n  @Bean\n  @Conditional(MagicExistsCondition.class)\n  public MagicBean magicBean() {\n    return new MagicBean();\n  }\n```\n可以看到,@Conditional中给定了一个Class,它指明了条件——在本例中,也就是MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比:\n```java\npublic class MagicExistsCondition implements Condition {\n\n  @Override\n  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n    Environment env = context.getEnvironment();\n    return env.containsProperty(\"magic\");\n  }\n  \n}\n```\n设置给@Conditional的类可以是任意实现了Condition接口的类型。可以看出来,这个接口实现起来很简单直接,只需提供matches()方法的实现即可。如果matches()方法返回true,那么就会创建带有@Conditional注解的bean。如果matches()方法返回\nfalse,将不会创建这些bean。\n\n*提示：`@Profile`注解源码使用了`@Conditional`注解来实现*\n\n### 3. 处理自动装配的歧义性\n\n仅有一个bean匹配所需的结果时,自动装配才是有效的。如果不仅有一个bean能够匹配结果的话,这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。\n\nSpring提供了多种可选方案来解决这样的问题。你可以将可选bean中的某一个设为首选(primary)的bean,或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。\n\n`@Primary`：在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候,Spring将会使用首选的bean,而不是其他可选的bean。实际上,你所声明就是“最喜欢”的bean。\n\n**限定自动装配的bean**\n\n`@Qualifier`注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用,在注入的时候指定想要注入进去的是哪个bean。\n\n更准确地讲,`@Qualifier(\"iceCream\")`所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话,所有的bean都会给定一个默认的限定符,这个限定符与bean的ID相同。因此,框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean,它是IceCream类在组件扫描的时候创建的。\n\n限定符和bean id 是不同的概念，但是默认的限定符就是bean id。\n\n### 4. Bean的作用域\n在默认情况下,Spring应用上下文中所有bean都是作为以单例(singleton)的形式创建的。也就是说,不管给定的一个bean被注入到其他bean多少次,每次所注入的都是同一个实例。\n\nSpring定义了多种作用域,可以基于这些作用域创建bean,包括:\n- 单例(Singleton):在整个应用中,只创建bean的一个实例。\n- 原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。\n- 会话(Session):在Web应用中,为每个会话创建一个bean实例。\n- 请求(Rquest):在Web应用中,为每个请求创建一个bean实例。\n\n`@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)`：这个注解能够更改bean的作用域。这里,使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然也可以使用`@Scope(\"prototype\")`,但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。\n\n`@Scope`可以应用在组件扫描和Java配置中。\n在XML配置中：\n`<bean id=\"xxx\" class=\"xxx\" scope=\"prototype\">`\n\n会话和请求作用域指Spring为Web应用中的每个会话或请求创建一个对应的bean。\n\n","source":"_posts/《Spring实战》高级装配.md","raw":"---\ntoc: true\ntitle: 《Spring实战》高级装配\ndate: 2018-04-04 15:11:57\ntags: [Spring, DI]\n---\n\n\n- Spring profile\n- 条件化的bean声明\n- 自动装配及歧义性\n- bean的作用域\n- SpEL\n<!--more-->\n### 1. 环境与profile\n\n在正常开发过程中，我们会有不同的环境。例如：\n- 开发环境（dev）：也就是每个人在电脑上进行开发的环境。\n- Beta环境（beta）：即测试环境，QA环境，在测试机器上运行的环境。\n- 线上环境（prod）：也称为生产环境。即在线上机器上跑的环境。\n\n这里的环境指的是类似于数据库，ng等资源。\n\n#### 1.1 配置profile bean\n**在JavaConfig中配置profile**\n`@Profile(\"dev\")`：这个注解可以应用在类或方法上。如果应用于类级别上，他会告诉Spring这个配置类中的bean在相应dev profile 激活时才会创建。如果dev profile没有激活的话，那么带有`@Bean`注解的方法都会被忽略。\n\n在Spring 3.1中,只能在类级别上使用@Profile注解。不过,从Spring 3.2开始,你也可以在方法级别上使用@Profile注解,与@Bean注解一同使用。这样的话,就能将这两个bean的声明放到同一个配置类之中。\n\n没有指定profile的bean始终都会被创建,与激活哪个profile没有关系。\n\n**在XML中配置profile**\n使用标签：\n```xml\n<beans profile=\"dev\">\n\t这里定义相应的bean\n</beans>\n```\n\n### 2. 激活profile\n\nSpring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：`spring.profiles.active`和`spring.profiles.default`。如果设置了`spring.profiles.active`属性的话,那么它的值就会用来确定哪个profile是激活的。但如果没有设置`spring.profiles.active`属性的话,那Spring将会查找`spring.profiles.default`的值。如果`spring.profiles.active`和`spring.profiles.default`均没有设置的话,那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。\n\n有多种方法来设置这两种属性：\n- 作为DispatcherServlet的初始化参数;\n- 作为Web应用的上下文参数;\n- 作为JNDI条目;\n- 作为环境变量;\n- 作为JVM的系统属性;\n- 在集成测试类上,使用@ActiveProfiles注解设置。\n\n\n**在Web应用的web.xml文件中设置默认的profile**\n\n```xml\n# 为web应用上下文设置默认的profile\n<context-param>\n\t<param-name>spring.profiles.default</param-name>\n\t<param-value>dev</param-value>\n</context-param>\n# 为Servlet设置默认的profile\n<servlet>\n\t<servlet-name>appServlet</servlet-name>\n\t<servlet-class>\n\t\torg.springframework.web.servlet.DispatcherServlet\n\t</servlet-class>\n\t<init-param>\n\t\t<param-name>spring.profile.default</param-name>\n\t\t<param-value>dev</param-value>\n\t</init-param>\n</servlet>\n...\n```\n\n**使用profile进行测试**\n当运行集成测试时,通常会希望采用与生产环境(或者是生产环境的部分子集)相同的配置进行测试。但是,如果配置中的bean定义在了profile中,那么在运行测试时,我们就需要有一种方式来启用合适的profile。\n\nSpring提供了@ActiveProfiles注解,我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时,通常想要激活的是开发环境的profile。例如,下面的测试类片段展现了使用@ActiveProfiles激活dev profile:\n```java\n  @RunWith(SpringJUnit4ClassRunner.class)\n  @ContextConfiguration(classes=DataSourceConfig.class)\n  @ActiveProfiles(\"dev\")\n  public static class DevDataSourceTest {\n  }\n```\n\n### 2. 条件化bean\n假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后,才会创建某个bean。\n\nSpring4引入了一个新的注解：\n`@Conditional`：它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true,就会创建这个bean,否则的话,这个bean会被忽略。\n```java\n  @Bean\n  @Conditional(MagicExistsCondition.class)\n  public MagicBean magicBean() {\n    return new MagicBean();\n  }\n```\n可以看到,@Conditional中给定了一个Class,它指明了条件——在本例中,也就是MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比:\n```java\npublic class MagicExistsCondition implements Condition {\n\n  @Override\n  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n    Environment env = context.getEnvironment();\n    return env.containsProperty(\"magic\");\n  }\n  \n}\n```\n设置给@Conditional的类可以是任意实现了Condition接口的类型。可以看出来,这个接口实现起来很简单直接,只需提供matches()方法的实现即可。如果matches()方法返回true,那么就会创建带有@Conditional注解的bean。如果matches()方法返回\nfalse,将不会创建这些bean。\n\n*提示：`@Profile`注解源码使用了`@Conditional`注解来实现*\n\n### 3. 处理自动装配的歧义性\n\n仅有一个bean匹配所需的结果时,自动装配才是有效的。如果不仅有一个bean能够匹配结果的话,这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。\n\nSpring提供了多种可选方案来解决这样的问题。你可以将可选bean中的某一个设为首选(primary)的bean,或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。\n\n`@Primary`：在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候,Spring将会使用首选的bean,而不是其他可选的bean。实际上,你所声明就是“最喜欢”的bean。\n\n**限定自动装配的bean**\n\n`@Qualifier`注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用,在注入的时候指定想要注入进去的是哪个bean。\n\n更准确地讲,`@Qualifier(\"iceCream\")`所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话,所有的bean都会给定一个默认的限定符,这个限定符与bean的ID相同。因此,框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean,它是IceCream类在组件扫描的时候创建的。\n\n限定符和bean id 是不同的概念，但是默认的限定符就是bean id。\n\n### 4. Bean的作用域\n在默认情况下,Spring应用上下文中所有bean都是作为以单例(singleton)的形式创建的。也就是说,不管给定的一个bean被注入到其他bean多少次,每次所注入的都是同一个实例。\n\nSpring定义了多种作用域,可以基于这些作用域创建bean,包括:\n- 单例(Singleton):在整个应用中,只创建bean的一个实例。\n- 原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。\n- 会话(Session):在Web应用中,为每个会话创建一个bean实例。\n- 请求(Rquest):在Web应用中,为每个请求创建一个bean实例。\n\n`@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)`：这个注解能够更改bean的作用域。这里,使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然也可以使用`@Scope(\"prototype\")`,但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。\n\n`@Scope`可以应用在组件扫描和Java配置中。\n在XML配置中：\n`<bean id=\"xxx\" class=\"xxx\" scope=\"prototype\">`\n\n会话和请求作用域指Spring为Web应用中的每个会话或请求创建一个对应的bean。\n\n","slug":"《Spring实战》高级装配","published":1,"updated":"2018-08-13T14:28:27.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4e000k6k15uxljqr3m","content":"<ul>\n<li>Spring profile</li>\n<li>条件化的bean声明</li>\n<li>自动装配及歧义性</li>\n<li>bean的作用域</li>\n<li>SpEL<a id=\"more\"></a>\n<h3 id=\"1-环境与profile\"><a href=\"#1-环境与profile\" class=\"headerlink\" title=\"1. 环境与profile\"></a>1. 环境与profile</h3></li>\n</ul>\n<p>在正常开发过程中，我们会有不同的环境。例如：</p>\n<ul>\n<li>开发环境（dev）：也就是每个人在电脑上进行开发的环境。</li>\n<li>Beta环境（beta）：即测试环境，QA环境，在测试机器上运行的环境。</li>\n<li>线上环境（prod）：也称为生产环境。即在线上机器上跑的环境。</li>\n</ul>\n<p>这里的环境指的是类似于数据库，ng等资源。</p>\n<h4 id=\"1-1-配置profile-bean\"><a href=\"#1-1-配置profile-bean\" class=\"headerlink\" title=\"1.1 配置profile bean\"></a>1.1 配置profile bean</h4><p><strong>在JavaConfig中配置profile</strong><br><code>@Profile(&quot;dev&quot;)</code>：这个注解可以应用在类或方法上。如果应用于类级别上，他会告诉Spring这个配置类中的bean在相应dev profile 激活时才会创建。如果dev profile没有激活的话，那么带有<code>@Bean</code>注解的方法都会被忽略。</p>\n<p>在Spring 3.1中,只能在类级别上使用@Profile注解。不过,从Spring 3.2开始,你也可以在方法级别上使用@Profile注解,与@Bean注解一同使用。这样的话,就能将这两个bean的声明放到同一个配置类之中。</p>\n<p>没有指定profile的bean始终都会被创建,与激活哪个profile没有关系。</p>\n<p><strong>在XML中配置profile</strong><br>使用标签：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>&gt;</span></span><br><span class=\"line\">\t这里定义相应的bean</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-激活profile\"><a href=\"#2-激活profile\" class=\"headerlink\" title=\"2. 激活profile\"></a>2. 激活profile</h3><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：<code>spring.profiles.active</code>和<code>spring.profiles.default</code>。如果设置了<code>spring.profiles.active</code>属性的话,那么它的值就会用来确定哪个profile是激活的。但如果没有设置<code>spring.profiles.active</code>属性的话,那Spring将会查找<code>spring.profiles.default</code>的值。如果<code>spring.profiles.active</code>和<code>spring.profiles.default</code>均没有设置的话,那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。</p>\n<p>有多种方法来设置这两种属性：</p>\n<ul>\n<li>作为DispatcherServlet的初始化参数;</li>\n<li>作为Web应用的上下文参数;</li>\n<li>作为JNDI条目;</li>\n<li>作为环境变量;</li>\n<li>作为JVM的系统属性;</li>\n<li>在集成测试类上,使用@ActiveProfiles注解设置。</li>\n</ul>\n<p><strong>在Web应用的web.xml文件中设置默认的profile</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 为web应用上下文设置默认的profile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profiles.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"># 为Servlet设置默认的profile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t\torg.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profile.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>使用profile进行测试</strong><br>当运行集成测试时,通常会希望采用与生产环境(或者是生产环境的部分子集)相同的配置进行测试。但是,如果配置中的bean定义在了profile中,那么在运行测试时,我们就需要有一种方式来启用合适的profile。</p>\n<p>Spring提供了@ActiveProfiles注解,我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时,通常想要激活的是开发环境的profile。例如,下面的测试类片段展现了使用@ActiveProfiles激活dev profile:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=DataSourceConfig.class)</span><br><span class=\"line\"><span class=\"meta\">@ActiveProfiles</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DevDataSourceTest</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-条件化bean\"><a href=\"#2-条件化bean\" class=\"headerlink\" title=\"2. 条件化bean\"></a>2. 条件化bean</h3><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后,才会创建某个bean。</p>\n<p>Spring4引入了一个新的注解：<br><code>@Conditional</code>：它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true,就会创建这个bean,否则的话,这个bean会被忽略。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(MagicExistsCondition.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MagicBean <span class=\"title\">magicBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MagicBean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到,@Conditional中给定了一个Class,它指明了条件——在本例中,也就是MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">    Environment env = context.getEnvironment();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env.containsProperty(<span class=\"string\">\"magic\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>设置给@Conditional的类可以是任意实现了Condition接口的类型。可以看出来,这个接口实现起来很简单直接,只需提供matches()方法的实现即可。如果matches()方法返回true,那么就会创建带有@Conditional注解的bean。如果matches()方法返回<br>false,将不会创建这些bean。</p>\n<p><em>提示：<code>@Profile</code>注解源码使用了<code>@Conditional</code>注解来实现</em></p>\n<h3 id=\"3-处理自动装配的歧义性\"><a href=\"#3-处理自动装配的歧义性\" class=\"headerlink\" title=\"3. 处理自动装配的歧义性\"></a>3. 处理自动装配的歧义性</h3><p>仅有一个bean匹配所需的结果时,自动装配才是有效的。如果不仅有一个bean能够匹配结果的话,这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。</p>\n<p>Spring提供了多种可选方案来解决这样的问题。你可以将可选bean中的某一个设为首选(primary)的bean,或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。</p>\n<p><code>@Primary</code>：在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候,Spring将会使用首选的bean,而不是其他可选的bean。实际上,你所声明就是“最喜欢”的bean。</p>\n<p><strong>限定自动装配的bean</strong></p>\n<p><code>@Qualifier</code>注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用,在注入的时候指定想要注入进去的是哪个bean。</p>\n<p>更准确地讲,<code>@Qualifier(&quot;iceCream&quot;)</code>所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话,所有的bean都会给定一个默认的限定符,这个限定符与bean的ID相同。因此,框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean,它是IceCream类在组件扫描的时候创建的。</p>\n<p>限定符和bean id 是不同的概念，但是默认的限定符就是bean id。</p>\n<h3 id=\"4-Bean的作用域\"><a href=\"#4-Bean的作用域\" class=\"headerlink\" title=\"4. Bean的作用域\"></a>4. Bean的作用域</h3><p>在默认情况下,Spring应用上下文中所有bean都是作为以单例(singleton)的形式创建的。也就是说,不管给定的一个bean被注入到其他bean多少次,每次所注入的都是同一个实例。</p>\n<p>Spring定义了多种作用域,可以基于这些作用域创建bean,包括:</p>\n<ul>\n<li>单例(Singleton):在整个应用中,只创建bean的一个实例。</li>\n<li>原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。</li>\n<li>会话(Session):在Web应用中,为每个会话创建一个bean实例。</li>\n<li>请求(Rquest):在Web应用中,为每个请求创建一个bean实例。</li>\n</ul>\n<p><code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>：这个注解能够更改bean的作用域。这里,使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然也可以使用<code>@Scope(&quot;prototype&quot;)</code>,但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。</p>\n<p><code>@Scope</code>可以应用在组件扫描和Java配置中。<br>在XML配置中：<br><code>&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot; scope=&quot;prototype&quot;&gt;</code></p>\n<p>会话和请求作用域指Spring为Web应用中的每个会话或请求创建一个对应的bean。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>Spring profile</li>\n<li>条件化的bean声明</li>\n<li>自动装配及歧义性</li>\n<li>bean的作用域</li>\n<li>SpEL","more":"<h3 id=\"1-环境与profile\"><a href=\"#1-环境与profile\" class=\"headerlink\" title=\"1. 环境与profile\"></a>1. 环境与profile</h3></li>\n</ul>\n<p>在正常开发过程中，我们会有不同的环境。例如：</p>\n<ul>\n<li>开发环境（dev）：也就是每个人在电脑上进行开发的环境。</li>\n<li>Beta环境（beta）：即测试环境，QA环境，在测试机器上运行的环境。</li>\n<li>线上环境（prod）：也称为生产环境。即在线上机器上跑的环境。</li>\n</ul>\n<p>这里的环境指的是类似于数据库，ng等资源。</p>\n<h4 id=\"1-1-配置profile-bean\"><a href=\"#1-1-配置profile-bean\" class=\"headerlink\" title=\"1.1 配置profile bean\"></a>1.1 配置profile bean</h4><p><strong>在JavaConfig中配置profile</strong><br><code>@Profile(&quot;dev&quot;)</code>：这个注解可以应用在类或方法上。如果应用于类级别上，他会告诉Spring这个配置类中的bean在相应dev profile 激活时才会创建。如果dev profile没有激活的话，那么带有<code>@Bean</code>注解的方法都会被忽略。</p>\n<p>在Spring 3.1中,只能在类级别上使用@Profile注解。不过,从Spring 3.2开始,你也可以在方法级别上使用@Profile注解,与@Bean注解一同使用。这样的话,就能将这两个bean的声明放到同一个配置类之中。</p>\n<p>没有指定profile的bean始终都会被创建,与激活哪个profile没有关系。</p>\n<p><strong>在XML中配置profile</strong><br>使用标签：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">profile</span>=<span class=\"string\">\"dev\"</span>&gt;</span></span><br><span class=\"line\">\t这里定义相应的bean</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-激活profile\"><a href=\"#2-激活profile\" class=\"headerlink\" title=\"2. 激活profile\"></a>2. 激活profile</h3><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：<code>spring.profiles.active</code>和<code>spring.profiles.default</code>。如果设置了<code>spring.profiles.active</code>属性的话,那么它的值就会用来确定哪个profile是激活的。但如果没有设置<code>spring.profiles.active</code>属性的话,那Spring将会查找<code>spring.profiles.default</code>的值。如果<code>spring.profiles.active</code>和<code>spring.profiles.default</code>均没有设置的话,那就没有激活的profile,因此只会创建那些没有定义在profile中的bean。</p>\n<p>有多种方法来设置这两种属性：</p>\n<ul>\n<li>作为DispatcherServlet的初始化参数;</li>\n<li>作为Web应用的上下文参数;</li>\n<li>作为JNDI条目;</li>\n<li>作为环境变量;</li>\n<li>作为JVM的系统属性;</li>\n<li>在集成测试类上,使用@ActiveProfiles注解设置。</li>\n</ul>\n<p><strong>在Web应用的web.xml文件中设置默认的profile</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 为web应用上下文设置默认的profile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profiles.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"># 为Servlet设置默认的profile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>appServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t\torg.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>spring.profile.default<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>dev<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>使用profile进行测试</strong><br>当运行集成测试时,通常会希望采用与生产环境(或者是生产环境的部分子集)相同的配置进行测试。但是,如果配置中的bean定义在了profile中,那么在运行测试时,我们就需要有一种方式来启用合适的profile。</p>\n<p>Spring提供了@ActiveProfiles注解,我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时,通常想要激活的是开发环境的profile。例如,下面的测试类片段展现了使用@ActiveProfiles激活dev profile:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=DataSourceConfig.class)</span><br><span class=\"line\"><span class=\"meta\">@ActiveProfiles</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DevDataSourceTest</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-条件化bean\"><a href=\"#2-条件化bean\" class=\"headerlink\" title=\"2. 条件化bean\"></a>2. 条件化bean</h3><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后,才会创建某个bean。</p>\n<p>Spring4引入了一个新的注解：<br><code>@Conditional</code>：它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true,就会创建这个bean,否则的话,这个bean会被忽略。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(MagicExistsCondition.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MagicBean <span class=\"title\">magicBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MagicBean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到,@Conditional中给定了一个Class,它指明了条件——在本例中,也就是MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">    Environment env = context.getEnvironment();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env.containsProperty(<span class=\"string\">\"magic\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>设置给@Conditional的类可以是任意实现了Condition接口的类型。可以看出来,这个接口实现起来很简单直接,只需提供matches()方法的实现即可。如果matches()方法返回true,那么就会创建带有@Conditional注解的bean。如果matches()方法返回<br>false,将不会创建这些bean。</p>\n<p><em>提示：<code>@Profile</code>注解源码使用了<code>@Conditional</code>注解来实现</em></p>\n<h3 id=\"3-处理自动装配的歧义性\"><a href=\"#3-处理自动装配的歧义性\" class=\"headerlink\" title=\"3. 处理自动装配的歧义性\"></a>3. 处理自动装配的歧义性</h3><p>仅有一个bean匹配所需的结果时,自动装配才是有效的。如果不仅有一个bean能够匹配结果的话,这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。</p>\n<p>Spring提供了多种可选方案来解决这样的问题。你可以将可选bean中的某一个设为首选(primary)的bean,或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。</p>\n<p><code>@Primary</code>：在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候,Spring将会使用首选的bean,而不是其他可选的bean。实际上,你所声明就是“最喜欢”的bean。</p>\n<p><strong>限定自动装配的bean</strong></p>\n<p><code>@Qualifier</code>注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用,在注入的时候指定想要注入进去的是哪个bean。</p>\n<p>更准确地讲,<code>@Qualifier(&quot;iceCream&quot;)</code>所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话,所有的bean都会给定一个默认的限定符,这个限定符与bean的ID相同。因此,框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean,它是IceCream类在组件扫描的时候创建的。</p>\n<p>限定符和bean id 是不同的概念，但是默认的限定符就是bean id。</p>\n<h3 id=\"4-Bean的作用域\"><a href=\"#4-Bean的作用域\" class=\"headerlink\" title=\"4. Bean的作用域\"></a>4. Bean的作用域</h3><p>在默认情况下,Spring应用上下文中所有bean都是作为以单例(singleton)的形式创建的。也就是说,不管给定的一个bean被注入到其他bean多少次,每次所注入的都是同一个实例。</p>\n<p>Spring定义了多种作用域,可以基于这些作用域创建bean,包括:</p>\n<ul>\n<li>单例(Singleton):在整个应用中,只创建bean的一个实例。</li>\n<li>原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。</li>\n<li>会话(Session):在Web应用中,为每个会话创建一个bean实例。</li>\n<li>请求(Rquest):在Web应用中,为每个请求创建一个bean实例。</li>\n</ul>\n<p><code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>：这个注解能够更改bean的作用域。这里,使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然也可以使用<code>@Scope(&quot;prototype&quot;)</code>,但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。</p>\n<p><code>@Scope</code>可以应用在组件扫描和Java配置中。<br>在XML配置中：<br><code>&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot; scope=&quot;prototype&quot;&gt;</code></p>\n<p>会话和请求作用域指Spring为Web应用中的每个会话或请求创建一个对应的bean。</p>"},{"toc":true,"title":"《三个火枪手》噗噗噗","date":"2018-03-30T07:34:13.000Z","_content":"\n读了三分之一，法国小说都这样吗？我还欣赏不了，意淫大师，跟网络小说一样，三观尽毁。","source":"_posts/《三个火枪手》噗噗噗.md","raw":"---\ntoc: true\ntitle: 《三个火枪手》噗噗噗\ndate: 2018-03-30 15:34:13\ntags: [随笔,读书]\n---\n\n读了三分之一，法国小说都这样吗？我还欣赏不了，意淫大师，跟网络小说一样，三观尽毁。","slug":"《三个火枪手》噗噗噗","published":1,"updated":"2018-08-13T14:28:27.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4f000m6k15289oqonh","content":"<p>读了三分之一，法国小说都这样吗？我还欣赏不了，意淫大师，跟网络小说一样，三观尽毁。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>读了三分之一，法国小说都这样吗？我还欣赏不了，意淫大师，跟网络小说一样，三观尽毁。</p>\n"},{"toc":true,"title":"京东面经","comments":1,"date":"2017-09-18T09:10:25.000Z","_content":"\n#### 一面\n16号晚上8点半的火车，做了一晚上硬座，真是难受的一笔。主要是还背着电脑，第二天十点到北京，一下车就去麦当劳做新浪笔试。\n然后等到中午在麦当劳吃过午饭，就去挤地铁了，大概一点半到的富泰酒店，真是豪华。然后莫名被放鸽子，问人事经理，他帮我联系了面试官，说7点之后再给我安排电话面试。我当时有点炸毛了，心里真是伤的一笔，跟hr较为激烈的争吵的几句，就转身走了。在富泰酒店一楼沙发做到4点半就去车站的，大概五点回到了麦当劳，看起了中国新歌声，把之前的不快都忘了。\n等到七点，面试官准时给我打电话了，然后说八点再面试行么，我说OK。面试官态度特别好，我就没气可撒了。\n\n<!--more-->\n八点准时开始面试：\n> \n- 自我介绍\n- 问项目，Spring 注入\n- 线程池\n- web 攻击知道哪些，怎么处理\n- 如果短时间有多个ip对你进行攻击，怎么解决\n- 上面那个问题我讲到了拦截器，然后问拦截器有哪些算法知道吗。\n- LinkedHashMap工作原理\n- Python爬虫怎么做的\n- python多线程\n- 存储歌曲的数据库mysql\n- mysql了解哪些\n- 怎么查看一条sql语句的运行过程，我回答了explain，让我详细解释，我说不太清楚\n- 你这个100万首歌曲，数据量是很大的，怎么处理。建立索引。\n- 知道复合索引吗。知道。具体呢。说到说不下去为止\n- 数据库索引实现原理\n- 怎么实现的反爬虫。\n- redis缓存\n- 实习都做了些什么。\n- dubbo协议是什么\n- 出个算法题：一个200位的数乘以另一个200位的数，求结果。\n- 。。还有一些，没想起来。大致是这样的。\n\n\n#### 二面\n二面很突然，虽然有短信通知了19号电话面试，但一位一面官只是怜悯自己给了过，就没有好好准备。被打了个措手不及，没想到还是过了。而且立马就接到了三面通知。\n> \n- transient关键字\n- iterator迭代器\n- clone()函数以及clonnable\n- redis\n- 数据库的隔离级别\n- 数据库聚簇索引\n- 还有几个不记得了，只问了十分钟，一位挂了，没想到面完直接给了通过短信。\n\n#### 三面\n凌晨起来就去赶火车，去北京进行现场hr面。上来没有自我介绍等，直接就开始了\n>\n- 对前面两个面试官的情况了解吗\n- 对京东各个事业部了解吗\n- 希望去哪儿工作\n- 拿了哪些offer\n- 为什么选择京东\n- 没查到你的面试官信息，请问可能出错的原因\n- 怎么提高自己\n- 有什么想问的（我问了两个，一个是如果我去京东京东能让我做什么，第二是京东的发展怎么样）\n- 回去等消息吧，10.1之前给结果\n\n总的来说京东面试体验较差，竟然不报销车费...不过第一位面试官给我的印象非常好，人很有礼貌，也给了我一些启示，对待任何事任何人都别耍脾气，毕竟是求职，吃些委屈很正常。\n","source":"_posts/京东面经.md","raw":"---\ntoc: true\ntitle: 京东面经\ncomments: true\ndate: 2017-09-18 17:10:25\ntags: [面经,京东]\n---\n\n#### 一面\n16号晚上8点半的火车，做了一晚上硬座，真是难受的一笔。主要是还背着电脑，第二天十点到北京，一下车就去麦当劳做新浪笔试。\n然后等到中午在麦当劳吃过午饭，就去挤地铁了，大概一点半到的富泰酒店，真是豪华。然后莫名被放鸽子，问人事经理，他帮我联系了面试官，说7点之后再给我安排电话面试。我当时有点炸毛了，心里真是伤的一笔，跟hr较为激烈的争吵的几句，就转身走了。在富泰酒店一楼沙发做到4点半就去车站的，大概五点回到了麦当劳，看起了中国新歌声，把之前的不快都忘了。\n等到七点，面试官准时给我打电话了，然后说八点再面试行么，我说OK。面试官态度特别好，我就没气可撒了。\n\n<!--more-->\n八点准时开始面试：\n> \n- 自我介绍\n- 问项目，Spring 注入\n- 线程池\n- web 攻击知道哪些，怎么处理\n- 如果短时间有多个ip对你进行攻击，怎么解决\n- 上面那个问题我讲到了拦截器，然后问拦截器有哪些算法知道吗。\n- LinkedHashMap工作原理\n- Python爬虫怎么做的\n- python多线程\n- 存储歌曲的数据库mysql\n- mysql了解哪些\n- 怎么查看一条sql语句的运行过程，我回答了explain，让我详细解释，我说不太清楚\n- 你这个100万首歌曲，数据量是很大的，怎么处理。建立索引。\n- 知道复合索引吗。知道。具体呢。说到说不下去为止\n- 数据库索引实现原理\n- 怎么实现的反爬虫。\n- redis缓存\n- 实习都做了些什么。\n- dubbo协议是什么\n- 出个算法题：一个200位的数乘以另一个200位的数，求结果。\n- 。。还有一些，没想起来。大致是这样的。\n\n\n#### 二面\n二面很突然，虽然有短信通知了19号电话面试，但一位一面官只是怜悯自己给了过，就没有好好准备。被打了个措手不及，没想到还是过了。而且立马就接到了三面通知。\n> \n- transient关键字\n- iterator迭代器\n- clone()函数以及clonnable\n- redis\n- 数据库的隔离级别\n- 数据库聚簇索引\n- 还有几个不记得了，只问了十分钟，一位挂了，没想到面完直接给了通过短信。\n\n#### 三面\n凌晨起来就去赶火车，去北京进行现场hr面。上来没有自我介绍等，直接就开始了\n>\n- 对前面两个面试官的情况了解吗\n- 对京东各个事业部了解吗\n- 希望去哪儿工作\n- 拿了哪些offer\n- 为什么选择京东\n- 没查到你的面试官信息，请问可能出错的原因\n- 怎么提高自己\n- 有什么想问的（我问了两个，一个是如果我去京东京东能让我做什么，第二是京东的发展怎么样）\n- 回去等消息吧，10.1之前给结果\n\n总的来说京东面试体验较差，竟然不报销车费...不过第一位面试官给我的印象非常好，人很有礼貌，也给了我一些启示，对待任何事任何人都别耍脾气，毕竟是求职，吃些委屈很正常。\n","slug":"京东面经","published":1,"updated":"2018-08-13T14:28:27.576Z","layout":"post","photos":[],"link":"","_id":"cjloh3e4h000p6k15a5xs17y7","content":"<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>16号晚上8点半的火车，做了一晚上硬座，真是难受的一笔。主要是还背着电脑，第二天十点到北京，一下车就去麦当劳做新浪笔试。<br>然后等到中午在麦当劳吃过午饭，就去挤地铁了，大概一点半到的富泰酒店，真是豪华。然后莫名被放鸽子，问人事经理，他帮我联系了面试官，说7点之后再给我安排电话面试。我当时有点炸毛了，心里真是伤的一笔，跟hr较为激烈的争吵的几句，就转身走了。在富泰酒店一楼沙发做到4点半就去车站的，大概五点回到了麦当劳，看起了中国新歌声，把之前的不快都忘了。<br>等到七点，面试官准时给我打电话了，然后说八点再面试行么，我说OK。面试官态度特别好，我就没气可撒了。</p>\n<a id=\"more\"></a>\n<p>八点准时开始面试：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>自我介绍</li>\n<li>问项目，Spring 注入</li>\n<li>线程池</li>\n<li>web 攻击知道哪些，怎么处理</li>\n<li>如果短时间有多个ip对你进行攻击，怎么解决</li>\n<li>上面那个问题我讲到了拦截器，然后问拦截器有哪些算法知道吗。</li>\n<li>LinkedHashMap工作原理</li>\n<li>Python爬虫怎么做的</li>\n<li>python多线程</li>\n<li>存储歌曲的数据库mysql</li>\n<li>mysql了解哪些</li>\n<li>怎么查看一条sql语句的运行过程，我回答了explain，让我详细解释，我说不太清楚</li>\n<li>你这个100万首歌曲，数据量是很大的，怎么处理。建立索引。</li>\n<li>知道复合索引吗。知道。具体呢。说到说不下去为止</li>\n<li>数据库索引实现原理</li>\n<li>怎么实现的反爬虫。</li>\n<li>redis缓存</li>\n<li>实习都做了些什么。</li>\n<li>dubbo协议是什么</li>\n<li>出个算法题：一个200位的数乘以另一个200位的数，求结果。</li>\n<li>。。还有一些，没想起来。大致是这样的。</li>\n</ul>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>二面很突然，虽然有短信通知了19号电话面试，但一位一面官只是怜悯自己给了过，就没有好好准备。被打了个措手不及，没想到还是过了。而且立马就接到了三面通知。</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>transient关键字</li>\n<li>iterator迭代器</li>\n<li>clone()函数以及clonnable</li>\n<li>redis</li>\n<li>数据库的隔离级别</li>\n<li>数据库聚簇索引</li>\n<li>还有几个不记得了，只问了十分钟，一位挂了，没想到面完直接给了通过短信。</li>\n</ul>\n<h4 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h4><p>凌晨起来就去赶火车，去北京进行现场hr面。上来没有自我介绍等，直接就开始了</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>对前面两个面试官的情况了解吗</li>\n<li>对京东各个事业部了解吗</li>\n<li>希望去哪儿工作</li>\n<li>拿了哪些offer</li>\n<li>为什么选择京东</li>\n<li>没查到你的面试官信息，请问可能出错的原因</li>\n<li>怎么提高自己</li>\n<li>有什么想问的（我问了两个，一个是如果我去京东京东能让我做什么，第二是京东的发展怎么样）</li>\n<li>回去等消息吧，10.1之前给结果</li>\n</ul>\n<p>总的来说京东面试体验较差，竟然不报销车费…不过第一位面试官给我的印象非常好，人很有礼貌，也给了我一些启示，对待任何事任何人都别耍脾气，毕竟是求职，吃些委屈很正常。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><p>16号晚上8点半的火车，做了一晚上硬座，真是难受的一笔。主要是还背着电脑，第二天十点到北京，一下车就去麦当劳做新浪笔试。<br>然后等到中午在麦当劳吃过午饭，就去挤地铁了，大概一点半到的富泰酒店，真是豪华。然后莫名被放鸽子，问人事经理，他帮我联系了面试官，说7点之后再给我安排电话面试。我当时有点炸毛了，心里真是伤的一笔，跟hr较为激烈的争吵的几句，就转身走了。在富泰酒店一楼沙发做到4点半就去车站的，大概五点回到了麦当劳，看起了中国新歌声，把之前的不快都忘了。<br>等到七点，面试官准时给我打电话了，然后说八点再面试行么，我说OK。面试官态度特别好，我就没气可撒了。</p>","more":"<p>八点准时开始面试：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>自我介绍</li>\n<li>问项目，Spring 注入</li>\n<li>线程池</li>\n<li>web 攻击知道哪些，怎么处理</li>\n<li>如果短时间有多个ip对你进行攻击，怎么解决</li>\n<li>上面那个问题我讲到了拦截器，然后问拦截器有哪些算法知道吗。</li>\n<li>LinkedHashMap工作原理</li>\n<li>Python爬虫怎么做的</li>\n<li>python多线程</li>\n<li>存储歌曲的数据库mysql</li>\n<li>mysql了解哪些</li>\n<li>怎么查看一条sql语句的运行过程，我回答了explain，让我详细解释，我说不太清楚</li>\n<li>你这个100万首歌曲，数据量是很大的，怎么处理。建立索引。</li>\n<li>知道复合索引吗。知道。具体呢。说到说不下去为止</li>\n<li>数据库索引实现原理</li>\n<li>怎么实现的反爬虫。</li>\n<li>redis缓存</li>\n<li>实习都做了些什么。</li>\n<li>dubbo协议是什么</li>\n<li>出个算法题：一个200位的数乘以另一个200位的数，求结果。</li>\n<li>。。还有一些，没想起来。大致是这样的。</li>\n</ul>\n<h4 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h4><p>二面很突然，虽然有短信通知了19号电话面试，但一位一面官只是怜悯自己给了过，就没有好好准备。被打了个措手不及，没想到还是过了。而且立马就接到了三面通知。</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>transient关键字</li>\n<li>iterator迭代器</li>\n<li>clone()函数以及clonnable</li>\n<li>redis</li>\n<li>数据库的隔离级别</li>\n<li>数据库聚簇索引</li>\n<li>还有几个不记得了，只问了十分钟，一位挂了，没想到面完直接给了通过短信。</li>\n</ul>\n<h4 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h4><p>凌晨起来就去赶火车，去北京进行现场hr面。上来没有自我介绍等，直接就开始了</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>对前面两个面试官的情况了解吗</li>\n<li>对京东各个事业部了解吗</li>\n<li>希望去哪儿工作</li>\n<li>拿了哪些offer</li>\n<li>为什么选择京东</li>\n<li>没查到你的面试官信息，请问可能出错的原因</li>\n<li>怎么提高自己</li>\n<li>有什么想问的（我问了两个，一个是如果我去京东京东能让我做什么，第二是京东的发展怎么样）</li>\n<li>回去等消息吧，10.1之前给结果</li>\n</ul>\n<p>总的来说京东面试体验较差，竟然不报销车费…不过第一位面试官给我的印象非常好，人很有礼貌，也给了我一些启示，对待任何事任何人都别耍脾气，毕竟是求职，吃些委屈很正常。</p>"},{"toc":true,"title":"健身训练计划","date":"2018-03-27T08:24:15.000Z","_content":"\n### 饮食\n\n训练日：\n1. 早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个、牛奶一盒\n<!--more-->\n2. 上午：苹果或橘子一个\n2. 午餐：西单烤翅鸡胸饭\n3. 训练：蛋白粉、香蕉两根\n3. 晚餐：蒸美味小鸡胸，一碗粥\n4. 睡前：牛奶一盒\n\n休息日：\n1. 早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个\n2. 午餐：五谷渔粉、冒菜、1968牛扒饭选一\n3. 晚餐：五谷渔粉、冒菜、1968牛扒饭选一\n4. 睡前：牛奶一盒\n\n### 健身计划表\n\nhttp://www.jianshen8.com/jihua/biao/14605.html\n\n一周有四天训练时间：\n\n　　如果你每周只有两到三天训练时间建议采用以上的全身训练课表，如果你有四天或五天训练时间，这时候你可以考虑把上肢和下肢分开来练！\n\n　　四天的训练计划，假设你周末休息，我们会建议周一二训练，周三休息，然后周四五训练！\n\n#### 训前综合热身\n```\n1. 向前肩部环绕 20‘\n2. 手臂环绕 20’\n3. 髋关节环绕 30‘\n4. 支撑弓步转体 4次\n5. 半蹲 8次\n6. 平板支撑交替抬腿 12次\n7. 开合跳 30’\n```\n```\n　　周一：深蹲5\\5\\8\\12；硬拉4*10；单腿蹲3*10+\n　　训后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧拉伸、左右梨状肌拉伸\n\n　　周二：卧推5\\5\\8\\12：划船4*10；肩推3*10+\n　　讯后拉伸：胸部蝴蝶机动态拉伸、左右胸静态拉伸、跪姿背部拉伸、左右肩拉伸、三头拉伸\n\n　　周四：硬拉5\\5\\8\\12；深蹲4*10；单腿硬拉3*10+\n　　讯后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧动态拉伸、臀部拉伸\n\n　　周五：肩推5\\5\\8\\12；下拉4*10：卧推3*10+\n　　讯后拉伸：左右肩拉伸、跪姿背部拉伸、胸部动态拉伸、左右胸静态拉伸\n```\n```\n\t1.上下肢分开练，从低次数开始，一次训练中采取一项动作用大重量低次数训练，越往后走次数会越低\n　　2.下肢训练依旧以深蹲硬拉为主（变化式也算）并在训练末尾加入单腿的动作！\n　　3.卧推肩推可以采用哑铃杠铃交换，也可以做单边动作！划船下拉也是一样！\n　　4.10+的意思是课表走到末尾，3组10次和3组12次.15次是差不多的！\n　　5.在完成这些主要训练后，可以时时增加一些辅助训练，比如单关节的动作和固定器械！\n　　6.上肢训练顺序可以调整，但要保证“推”和“拉”动作平衡，不要出现“推”的动作练的太多！\n```\n#### 动作图集\n![Alt text](https://app.yinxiang.com/shard/s15/res/3c4bc44e-8c7f-48b6-9dd4-e63e14dff042/1522137084716.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/d6f23da2-dd8d-4797-b84e-9fab626b4ba6/1522137093672.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/1aaecfee-fb4a-4ecc-983e-61e746b2eca1/1522137112994.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/240399a1-9a18-4836-82d9-fa643a1dab2e/1522137136791.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/2bcf6d06-0581-4d73-8a6c-e01f344619fa/1522137142491.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/11a814ea-8de0-4e81-8404-c6194b9423cf/1522137152197.png)\n\n#### 拉伸图集\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/abbae747-1129-45ba-9e60-89e902718ce9/1522137409176.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/a096d82f-f815-4b89-85c4-051375514128/1522137413653.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/847d7af1-d152-4c65-bd27-4886331a94d6/1522137419264.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/fae9537b-7280-4cda-863c-8b6d24d2de2b/1522137423735.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/03dfcf61-9c73-41c0-8e62-070f19036124/1522137428955.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/7194198f-b144-4c40-8267-b1d43054b9fd/1522137433757.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/bc3172da-7c2f-469e-873d-61c36189bc5f/1522137438550.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/a8510f00-0921-49ec-848a-fb1e481217f9/1522137444999.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/91be2101-60ae-4bec-84c2-a32b4f66644c/1522137452715.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/3d736455-6358-4645-9673-4b295882f9c2/1522137458255.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/081cbdd7-da2b-4aca-bf84-a28d627d0424/1522137463278.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/90543e4e-72e2-4147-9a86-8cb89d8416a7/1522137467643.png)\n\n","source":"_posts/健身训练计划.md","raw":"---\ntoc: true\ntitle: 健身训练计划\ndate: 2018-03-27 16:24:15\ntags: [健身]\n---\n\n### 饮食\n\n训练日：\n1. 早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个、牛奶一盒\n<!--more-->\n2. 上午：苹果或橘子一个\n2. 午餐：西单烤翅鸡胸饭\n3. 训练：蛋白粉、香蕉两根\n3. 晚餐：蒸美味小鸡胸，一碗粥\n4. 睡前：牛奶一盒\n\n休息日：\n1. 早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个\n2. 午餐：五谷渔粉、冒菜、1968牛扒饭选一\n3. 晚餐：五谷渔粉、冒菜、1968牛扒饭选一\n4. 睡前：牛奶一盒\n\n### 健身计划表\n\nhttp://www.jianshen8.com/jihua/biao/14605.html\n\n一周有四天训练时间：\n\n　　如果你每周只有两到三天训练时间建议采用以上的全身训练课表，如果你有四天或五天训练时间，这时候你可以考虑把上肢和下肢分开来练！\n\n　　四天的训练计划，假设你周末休息，我们会建议周一二训练，周三休息，然后周四五训练！\n\n#### 训前综合热身\n```\n1. 向前肩部环绕 20‘\n2. 手臂环绕 20’\n3. 髋关节环绕 30‘\n4. 支撑弓步转体 4次\n5. 半蹲 8次\n6. 平板支撑交替抬腿 12次\n7. 开合跳 30’\n```\n```\n　　周一：深蹲5\\5\\8\\12；硬拉4*10；单腿蹲3*10+\n　　训后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧拉伸、左右梨状肌拉伸\n\n　　周二：卧推5\\5\\8\\12：划船4*10；肩推3*10+\n　　讯后拉伸：胸部蝴蝶机动态拉伸、左右胸静态拉伸、跪姿背部拉伸、左右肩拉伸、三头拉伸\n\n　　周四：硬拉5\\5\\8\\12；深蹲4*10；单腿硬拉3*10+\n　　讯后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧动态拉伸、臀部拉伸\n\n　　周五：肩推5\\5\\8\\12；下拉4*10：卧推3*10+\n　　讯后拉伸：左右肩拉伸、跪姿背部拉伸、胸部动态拉伸、左右胸静态拉伸\n```\n```\n\t1.上下肢分开练，从低次数开始，一次训练中采取一项动作用大重量低次数训练，越往后走次数会越低\n　　2.下肢训练依旧以深蹲硬拉为主（变化式也算）并在训练末尾加入单腿的动作！\n　　3.卧推肩推可以采用哑铃杠铃交换，也可以做单边动作！划船下拉也是一样！\n　　4.10+的意思是课表走到末尾，3组10次和3组12次.15次是差不多的！\n　　5.在完成这些主要训练后，可以时时增加一些辅助训练，比如单关节的动作和固定器械！\n　　6.上肢训练顺序可以调整，但要保证“推”和“拉”动作平衡，不要出现“推”的动作练的太多！\n```\n#### 动作图集\n![Alt text](https://app.yinxiang.com/shard/s15/res/3c4bc44e-8c7f-48b6-9dd4-e63e14dff042/1522137084716.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/d6f23da2-dd8d-4797-b84e-9fab626b4ba6/1522137093672.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/1aaecfee-fb4a-4ecc-983e-61e746b2eca1/1522137112994.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/240399a1-9a18-4836-82d9-fa643a1dab2e/1522137136791.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/2bcf6d06-0581-4d73-8a6c-e01f344619fa/1522137142491.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/11a814ea-8de0-4e81-8404-c6194b9423cf/1522137152197.png)\n\n#### 拉伸图集\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/abbae747-1129-45ba-9e60-89e902718ce9/1522137409176.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/a096d82f-f815-4b89-85c4-051375514128/1522137413653.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/847d7af1-d152-4c65-bd27-4886331a94d6/1522137419264.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/fae9537b-7280-4cda-863c-8b6d24d2de2b/1522137423735.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/03dfcf61-9c73-41c0-8e62-070f19036124/1522137428955.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/7194198f-b144-4c40-8267-b1d43054b9fd/1522137433757.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/bc3172da-7c2f-469e-873d-61c36189bc5f/1522137438550.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/a8510f00-0921-49ec-848a-fb1e481217f9/1522137444999.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/91be2101-60ae-4bec-84c2-a32b4f66644c/1522137452715.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/3d736455-6358-4645-9673-4b295882f9c2/1522137458255.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/081cbdd7-da2b-4aca-bf84-a28d627d0424/1522137463278.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/90543e4e-72e2-4147-9a86-8cb89d8416a7/1522137467643.png)\n\n","slug":"健身训练计划","published":1,"updated":"2018-08-13T14:28:27.577Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4j000q6k15iu8euxgu","content":"<h3 id=\"饮食\"><a href=\"#饮食\" class=\"headerlink\" title=\"饮食\"></a>饮食</h3><p>训练日：</p>\n<ol>\n<li>早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个、牛奶一盒<a id=\"more\"></a></li>\n<li>上午：苹果或橘子一个</li>\n<li>午餐：西单烤翅鸡胸饭</li>\n<li>训练：蛋白粉、香蕉两根</li>\n<li>晚餐：蒸美味小鸡胸，一碗粥</li>\n<li>睡前：牛奶一盒</li>\n</ol>\n<p>休息日：</p>\n<ol>\n<li>早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个</li>\n<li>午餐：五谷渔粉、冒菜、1968牛扒饭选一</li>\n<li>晚餐：五谷渔粉、冒菜、1968牛扒饭选一</li>\n<li>睡前：牛奶一盒</li>\n</ol>\n<h3 id=\"健身计划表\"><a href=\"#健身计划表\" class=\"headerlink\" title=\"健身计划表\"></a>健身计划表</h3><p><a href=\"http://www.jianshen8.com/jihua/biao/14605.html\" target=\"_blank\" rel=\"noopener\">http://www.jianshen8.com/jihua/biao/14605.html</a></p>\n<p>一周有四天训练时间：</p>\n<p>　　如果你每周只有两到三天训练时间建议采用以上的全身训练课表，如果你有四天或五天训练时间，这时候你可以考虑把上肢和下肢分开来练！</p>\n<p>　　四天的训练计划，假设你周末休息，我们会建议周一二训练，周三休息，然后周四五训练！</p>\n<h4 id=\"训前综合热身\"><a href=\"#训前综合热身\" class=\"headerlink\" title=\"训前综合热身\"></a>训前综合热身</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 向前肩部环绕 20‘</span><br><span class=\"line\">2. 手臂环绕 20’</span><br><span class=\"line\">3. 髋关节环绕 30‘</span><br><span class=\"line\">4. 支撑弓步转体 4次</span><br><span class=\"line\">5. 半蹲 8次</span><br><span class=\"line\">6. 平板支撑交替抬腿 12次</span><br><span class=\"line\">7. 开合跳 30’</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　周一：深蹲5\\5\\8\\12；硬拉4*10；单腿蹲3*10+</span><br><span class=\"line\">　　训后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧拉伸、左右梨状肌拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周二：卧推5\\5\\8\\12：划船4*10；肩推3*10+</span><br><span class=\"line\">　　讯后拉伸：胸部蝴蝶机动态拉伸、左右胸静态拉伸、跪姿背部拉伸、左右肩拉伸、三头拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周四：硬拉5\\5\\8\\12；深蹲4*10；单腿硬拉3*10+</span><br><span class=\"line\">　　讯后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧动态拉伸、臀部拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周五：肩推5\\5\\8\\12；下拉4*10：卧推3*10+</span><br><span class=\"line\">　　讯后拉伸：左右肩拉伸、跪姿背部拉伸、胸部动态拉伸、左右胸静态拉伸</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.上下肢分开练，从低次数开始，一次训练中采取一项动作用大重量低次数训练，越往后走次数会越低</span><br><span class=\"line\">　　2.下肢训练依旧以深蹲硬拉为主（变化式也算）并在训练末尾加入单腿的动作！</span><br><span class=\"line\">　　3.卧推肩推可以采用哑铃杠铃交换，也可以做单边动作！划船下拉也是一样！</span><br><span class=\"line\">　　4.10+的意思是课表走到末尾，3组10次和3组12次.15次是差不多的！</span><br><span class=\"line\">　　5.在完成这些主要训练后，可以时时增加一些辅助训练，比如单关节的动作和固定器械！</span><br><span class=\"line\">　　6.上肢训练顺序可以调整，但要保证“推”和“拉”动作平衡，不要出现“推”的动作练的太多！</span><br></pre></td></tr></table></figure>\n<h4 id=\"动作图集\"><a href=\"#动作图集\" class=\"headerlink\" title=\"动作图集\"></a>动作图集</h4><p><img src=\"https://app.yinxiang.com/shard/s15/res/3c4bc44e-8c7f-48b6-9dd4-e63e14dff042/1522137084716.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/d6f23da2-dd8d-4797-b84e-9fab626b4ba6/1522137093672.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/1aaecfee-fb4a-4ecc-983e-61e746b2eca1/1522137112994.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/240399a1-9a18-4836-82d9-fa643a1dab2e/1522137136791.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/2bcf6d06-0581-4d73-8a6c-e01f344619fa/1522137142491.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/11a814ea-8de0-4e81-8404-c6194b9423cf/1522137152197.png\" alt=\"Alt text\"></p>\n<h4 id=\"拉伸图集\"><a href=\"#拉伸图集\" class=\"headerlink\" title=\"拉伸图集\"></a>拉伸图集</h4><p><img src=\"https://app.yinxiang.com/shard/s15/res/abbae747-1129-45ba-9e60-89e902718ce9/1522137409176.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/a096d82f-f815-4b89-85c4-051375514128/1522137413653.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/847d7af1-d152-4c65-bd27-4886331a94d6/1522137419264.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/fae9537b-7280-4cda-863c-8b6d24d2de2b/1522137423735.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/03dfcf61-9c73-41c0-8e62-070f19036124/1522137428955.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/7194198f-b144-4c40-8267-b1d43054b9fd/1522137433757.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/bc3172da-7c2f-469e-873d-61c36189bc5f/1522137438550.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/a8510f00-0921-49ec-848a-fb1e481217f9/1522137444999.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/91be2101-60ae-4bec-84c2-a32b4f66644c/1522137452715.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/3d736455-6358-4645-9673-4b295882f9c2/1522137458255.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/081cbdd7-da2b-4aca-bf84-a28d627d0424/1522137463278.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/90543e4e-72e2-4147-9a86-8cb89d8416a7/1522137467643.png\" alt=\"Alt text\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"饮食\"><a href=\"#饮食\" class=\"headerlink\" title=\"饮食\"></a>饮食</h3><p>训练日：</p>\n<ol>\n<li>早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个、牛奶一盒","more":"</li>\n<li>上午：苹果或橘子一个</li>\n<li>午餐：西单烤翅鸡胸饭</li>\n<li>训练：蛋白粉、香蕉两根</li>\n<li>晚餐：蒸美味小鸡胸，一碗粥</li>\n<li>睡前：牛奶一盒</li>\n</ol>\n<p>休息日：</p>\n<ol>\n<li>早餐: 包子或蒸饺一屉、粥或豆浆一碗、煎蛋或蒸蛋一个</li>\n<li>午餐：五谷渔粉、冒菜、1968牛扒饭选一</li>\n<li>晚餐：五谷渔粉、冒菜、1968牛扒饭选一</li>\n<li>睡前：牛奶一盒</li>\n</ol>\n<h3 id=\"健身计划表\"><a href=\"#健身计划表\" class=\"headerlink\" title=\"健身计划表\"></a>健身计划表</h3><p><a href=\"http://www.jianshen8.com/jihua/biao/14605.html\" target=\"_blank\" rel=\"noopener\">http://www.jianshen8.com/jihua/biao/14605.html</a></p>\n<p>一周有四天训练时间：</p>\n<p>　　如果你每周只有两到三天训练时间建议采用以上的全身训练课表，如果你有四天或五天训练时间，这时候你可以考虑把上肢和下肢分开来练！</p>\n<p>　　四天的训练计划，假设你周末休息，我们会建议周一二训练，周三休息，然后周四五训练！</p>\n<h4 id=\"训前综合热身\"><a href=\"#训前综合热身\" class=\"headerlink\" title=\"训前综合热身\"></a>训前综合热身</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 向前肩部环绕 20‘</span><br><span class=\"line\">2. 手臂环绕 20’</span><br><span class=\"line\">3. 髋关节环绕 30‘</span><br><span class=\"line\">4. 支撑弓步转体 4次</span><br><span class=\"line\">5. 半蹲 8次</span><br><span class=\"line\">6. 平板支撑交替抬腿 12次</span><br><span class=\"line\">7. 开合跳 30’</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　周一：深蹲5\\5\\8\\12；硬拉4*10；单腿蹲3*10+</span><br><span class=\"line\">　　训后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧拉伸、左右梨状肌拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周二：卧推5\\5\\8\\12：划船4*10；肩推3*10+</span><br><span class=\"line\">　　讯后拉伸：胸部蝴蝶机动态拉伸、左右胸静态拉伸、跪姿背部拉伸、左右肩拉伸、三头拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周四：硬拉5\\5\\8\\12；深蹲4*10；单腿硬拉3*10+</span><br><span class=\"line\">　　讯后拉伸：左右腿前侧拉伸、小腿拉伸、坐姿大腿后侧拉伸、仰卧左右腿后侧动态拉伸、臀部拉伸</span><br><span class=\"line\"></span><br><span class=\"line\">　　周五：肩推5\\5\\8\\12；下拉4*10：卧推3*10+</span><br><span class=\"line\">　　讯后拉伸：左右肩拉伸、跪姿背部拉伸、胸部动态拉伸、左右胸静态拉伸</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.上下肢分开练，从低次数开始，一次训练中采取一项动作用大重量低次数训练，越往后走次数会越低</span><br><span class=\"line\">　　2.下肢训练依旧以深蹲硬拉为主（变化式也算）并在训练末尾加入单腿的动作！</span><br><span class=\"line\">　　3.卧推肩推可以采用哑铃杠铃交换，也可以做单边动作！划船下拉也是一样！</span><br><span class=\"line\">　　4.10+的意思是课表走到末尾，3组10次和3组12次.15次是差不多的！</span><br><span class=\"line\">　　5.在完成这些主要训练后，可以时时增加一些辅助训练，比如单关节的动作和固定器械！</span><br><span class=\"line\">　　6.上肢训练顺序可以调整，但要保证“推”和“拉”动作平衡，不要出现“推”的动作练的太多！</span><br></pre></td></tr></table></figure>\n<h4 id=\"动作图集\"><a href=\"#动作图集\" class=\"headerlink\" title=\"动作图集\"></a>动作图集</h4><p><img src=\"https://app.yinxiang.com/shard/s15/res/3c4bc44e-8c7f-48b6-9dd4-e63e14dff042/1522137084716.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/d6f23da2-dd8d-4797-b84e-9fab626b4ba6/1522137093672.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/1aaecfee-fb4a-4ecc-983e-61e746b2eca1/1522137112994.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/240399a1-9a18-4836-82d9-fa643a1dab2e/1522137136791.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/2bcf6d06-0581-4d73-8a6c-e01f344619fa/1522137142491.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/11a814ea-8de0-4e81-8404-c6194b9423cf/1522137152197.png\" alt=\"Alt text\"></p>\n<h4 id=\"拉伸图集\"><a href=\"#拉伸图集\" class=\"headerlink\" title=\"拉伸图集\"></a>拉伸图集</h4><p><img src=\"https://app.yinxiang.com/shard/s15/res/abbae747-1129-45ba-9e60-89e902718ce9/1522137409176.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/a096d82f-f815-4b89-85c4-051375514128/1522137413653.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/847d7af1-d152-4c65-bd27-4886331a94d6/1522137419264.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/fae9537b-7280-4cda-863c-8b6d24d2de2b/1522137423735.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/03dfcf61-9c73-41c0-8e62-070f19036124/1522137428955.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/7194198f-b144-4c40-8267-b1d43054b9fd/1522137433757.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/bc3172da-7c2f-469e-873d-61c36189bc5f/1522137438550.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/a8510f00-0921-49ec-848a-fb1e481217f9/1522137444999.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/91be2101-60ae-4bec-84c2-a32b4f66644c/1522137452715.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/3d736455-6358-4645-9673-4b295882f9c2/1522137458255.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/081cbdd7-da2b-4aca-bf84-a28d627d0424/1522137463278.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/90543e4e-72e2-4147-9a86-8cb89d8416a7/1522137467643.png\" alt=\"Alt text\"></p>"},{"toc":true,"title":"华为面经","date":"2017-09-18T06:15:27.000Z","_content":"\n\n  坐了两个晚上的火车，赶回来面华为，我也是很拼。\n  华为面试跟京东地方差不多，都是一个豪华酒店包了一层。但是面试真的很水，至少技术含量跟别家比起来很水。\n<!--more-->\n#### 一面\n> 进去先给简历，然后说你可以自我介绍了 \n- 自我介绍\n- 本来以为看了我的简历会要问项目，但是问我项目的时候又不问我项目里面的技术，就问我一些零零散散的东西，我想系统的回忆他（一面官）到底问了什么，但是就是整理不起来。（以下部分顺序，回忆起哪个是哪个）\n- 你觉得你哪门课程学的最好\n- 从你学的好的课程里挑几门拿里面的知识点来问（我是说的数据结构、算法、Java、计算机网络）\n- 数据结构之排序算法，熟悉哪些排序算法。我说都熟悉，然后重点说我熟悉堆排序和快速排序，然后面试官问了个冒泡排序的时间复杂度。然后是平衡二叉树。\n- 算法之应用。你学了这些算法，在实际中或者你的项目中怎么用的。我回答：红黑树在hashmap中的运用，B+树在数据库和文件系统中的运用，迪杰特斯拉算法在路由算法中的运用。说到路由算法，面试官问，你都熟悉哪些路由算法或协议，我就说了距离向量和链路状态，BGP和IGMP等等。\n- 计算机网络之TCP和UDP的区别。讲完这个，说到TCP是我说跟TCP相关的主要知识有三次握手、四次分手、滑动窗口、拥塞控制等。然后他就问我拥塞控制有哪些算法，我说了慢启动、拥塞控制、快速重传、快速恢复。说到快重传，面试官又问：假如用TCP协议，我们有两台服务器通信，忽然一台服务器重启了，那会发生什么情况。我就说可能超时，会重发，然后他就说还有么，我说岔了，讲到了三次重传那里去了，他提示我是服务器重启，接收不到，然后我就想起来了，也是超时重传，但是超过16次或者多少次会断开连接。然后还问关于应用层协议都有哪些应用等等，比如http、ftp等等\n- 关于Java基本上没问任何问题，就问我我的这些语言哪个最强，我就说第一Java，然后python，然后C和C++。\n- 关于以后想往哪个方向发展等等。基本上就是在聊天了。\n\n#### 二面（综合面）\n> 综合面。。。就是关于你什么性格吗，怎么学习的，未来怎么规划的，喜欢加班吗。？？？我真是害怕他这么问，那就是说加班很多咯，好怕怕。而且二面官有点年纪了，冷冰冰的，我害怕，然后就一直说话，说一句解释两句。比如加班问题，我说我不是很怕加班，正常加班的话我是能接受的，额，什么是正常加班。。。然后开始解释，越解释越乱。最后二面官笑了，说你回去等通知吧，我说谢谢您嘞。赶紧溜了。\n\n\n华为面试真是奇葩。。\n","source":"_posts/华为面经.md","raw":"---\ntoc: true\ntitle: 华为面经\ndate: 2017-09-18 14:15:27\ntags: [华为,面经]\n---\n\n\n  坐了两个晚上的火车，赶回来面华为，我也是很拼。\n  华为面试跟京东地方差不多，都是一个豪华酒店包了一层。但是面试真的很水，至少技术含量跟别家比起来很水。\n<!--more-->\n#### 一面\n> 进去先给简历，然后说你可以自我介绍了 \n- 自我介绍\n- 本来以为看了我的简历会要问项目，但是问我项目的时候又不问我项目里面的技术，就问我一些零零散散的东西，我想系统的回忆他（一面官）到底问了什么，但是就是整理不起来。（以下部分顺序，回忆起哪个是哪个）\n- 你觉得你哪门课程学的最好\n- 从你学的好的课程里挑几门拿里面的知识点来问（我是说的数据结构、算法、Java、计算机网络）\n- 数据结构之排序算法，熟悉哪些排序算法。我说都熟悉，然后重点说我熟悉堆排序和快速排序，然后面试官问了个冒泡排序的时间复杂度。然后是平衡二叉树。\n- 算法之应用。你学了这些算法，在实际中或者你的项目中怎么用的。我回答：红黑树在hashmap中的运用，B+树在数据库和文件系统中的运用，迪杰特斯拉算法在路由算法中的运用。说到路由算法，面试官问，你都熟悉哪些路由算法或协议，我就说了距离向量和链路状态，BGP和IGMP等等。\n- 计算机网络之TCP和UDP的区别。讲完这个，说到TCP是我说跟TCP相关的主要知识有三次握手、四次分手、滑动窗口、拥塞控制等。然后他就问我拥塞控制有哪些算法，我说了慢启动、拥塞控制、快速重传、快速恢复。说到快重传，面试官又问：假如用TCP协议，我们有两台服务器通信，忽然一台服务器重启了，那会发生什么情况。我就说可能超时，会重发，然后他就说还有么，我说岔了，讲到了三次重传那里去了，他提示我是服务器重启，接收不到，然后我就想起来了，也是超时重传，但是超过16次或者多少次会断开连接。然后还问关于应用层协议都有哪些应用等等，比如http、ftp等等\n- 关于Java基本上没问任何问题，就问我我的这些语言哪个最强，我就说第一Java，然后python，然后C和C++。\n- 关于以后想往哪个方向发展等等。基本上就是在聊天了。\n\n#### 二面（综合面）\n> 综合面。。。就是关于你什么性格吗，怎么学习的，未来怎么规划的，喜欢加班吗。？？？我真是害怕他这么问，那就是说加班很多咯，好怕怕。而且二面官有点年纪了，冷冰冰的，我害怕，然后就一直说话，说一句解释两句。比如加班问题，我说我不是很怕加班，正常加班的话我是能接受的，额，什么是正常加班。。。然后开始解释，越解释越乱。最后二面官笑了，说你回去等通知吧，我说谢谢您嘞。赶紧溜了。\n\n\n华为面试真是奇葩。。\n","slug":"华为面经","published":1,"updated":"2018-08-13T14:28:27.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4l000s6k15fxpfb6yf","content":"<p>  坐了两个晚上的火车，赶回来面华为，我也是很拼。<br>  华为面试跟京东地方差不多，都是一个豪华酒店包了一层。但是面试真的很水，至少技术含量跟别家比起来很水。<br><a id=\"more\"></a></p>\n<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><blockquote>\n<p>进去先给简历，然后说你可以自我介绍了 </p>\n<ul>\n<li>自我介绍</li>\n<li>本来以为看了我的简历会要问项目，但是问我项目的时候又不问我项目里面的技术，就问我一些零零散散的东西，我想系统的回忆他（一面官）到底问了什么，但是就是整理不起来。（以下部分顺序，回忆起哪个是哪个）</li>\n<li>你觉得你哪门课程学的最好</li>\n<li>从你学的好的课程里挑几门拿里面的知识点来问（我是说的数据结构、算法、Java、计算机网络）</li>\n<li>数据结构之排序算法，熟悉哪些排序算法。我说都熟悉，然后重点说我熟悉堆排序和快速排序，然后面试官问了个冒泡排序的时间复杂度。然后是平衡二叉树。</li>\n<li>算法之应用。你学了这些算法，在实际中或者你的项目中怎么用的。我回答：红黑树在hashmap中的运用，B+树在数据库和文件系统中的运用，迪杰特斯拉算法在路由算法中的运用。说到路由算法，面试官问，你都熟悉哪些路由算法或协议，我就说了距离向量和链路状态，BGP和IGMP等等。</li>\n<li>计算机网络之TCP和UDP的区别。讲完这个，说到TCP是我说跟TCP相关的主要知识有三次握手、四次分手、滑动窗口、拥塞控制等。然后他就问我拥塞控制有哪些算法，我说了慢启动、拥塞控制、快速重传、快速恢复。说到快重传，面试官又问：假如用TCP协议，我们有两台服务器通信，忽然一台服务器重启了，那会发生什么情况。我就说可能超时，会重发，然后他就说还有么，我说岔了，讲到了三次重传那里去了，他提示我是服务器重启，接收不到，然后我就想起来了，也是超时重传，但是超过16次或者多少次会断开连接。然后还问关于应用层协议都有哪些应用等等，比如http、ftp等等</li>\n<li>关于Java基本上没问任何问题，就问我我的这些语言哪个最强，我就说第一Java，然后python，然后C和C++。</li>\n<li>关于以后想往哪个方向发展等等。基本上就是在聊天了。</li>\n</ul>\n</blockquote>\n<h4 id=\"二面（综合面）\"><a href=\"#二面（综合面）\" class=\"headerlink\" title=\"二面（综合面）\"></a>二面（综合面）</h4><blockquote>\n<p>综合面。。。就是关于你什么性格吗，怎么学习的，未来怎么规划的，喜欢加班吗。？？？我真是害怕他这么问，那就是说加班很多咯，好怕怕。而且二面官有点年纪了，冷冰冰的，我害怕，然后就一直说话，说一句解释两句。比如加班问题，我说我不是很怕加班，正常加班的话我是能接受的，额，什么是正常加班。。。然后开始解释，越解释越乱。最后二面官笑了，说你回去等通知吧，我说谢谢您嘞。赶紧溜了。</p>\n</blockquote>\n<p>华为面试真是奇葩。。</p>\n","site":{"data":{}},"excerpt":"<p>  坐了两个晚上的火车，赶回来面华为，我也是很拼。<br>  华为面试跟京东地方差不多，都是一个豪华酒店包了一层。但是面试真的很水，至少技术含量跟别家比起来很水。<br>","more":"</p>\n<h4 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h4><blockquote>\n<p>进去先给简历，然后说你可以自我介绍了 </p>\n<ul>\n<li>自我介绍</li>\n<li>本来以为看了我的简历会要问项目，但是问我项目的时候又不问我项目里面的技术，就问我一些零零散散的东西，我想系统的回忆他（一面官）到底问了什么，但是就是整理不起来。（以下部分顺序，回忆起哪个是哪个）</li>\n<li>你觉得你哪门课程学的最好</li>\n<li>从你学的好的课程里挑几门拿里面的知识点来问（我是说的数据结构、算法、Java、计算机网络）</li>\n<li>数据结构之排序算法，熟悉哪些排序算法。我说都熟悉，然后重点说我熟悉堆排序和快速排序，然后面试官问了个冒泡排序的时间复杂度。然后是平衡二叉树。</li>\n<li>算法之应用。你学了这些算法，在实际中或者你的项目中怎么用的。我回答：红黑树在hashmap中的运用，B+树在数据库和文件系统中的运用，迪杰特斯拉算法在路由算法中的运用。说到路由算法，面试官问，你都熟悉哪些路由算法或协议，我就说了距离向量和链路状态，BGP和IGMP等等。</li>\n<li>计算机网络之TCP和UDP的区别。讲完这个，说到TCP是我说跟TCP相关的主要知识有三次握手、四次分手、滑动窗口、拥塞控制等。然后他就问我拥塞控制有哪些算法，我说了慢启动、拥塞控制、快速重传、快速恢复。说到快重传，面试官又问：假如用TCP协议，我们有两台服务器通信，忽然一台服务器重启了，那会发生什么情况。我就说可能超时，会重发，然后他就说还有么，我说岔了，讲到了三次重传那里去了，他提示我是服务器重启，接收不到，然后我就想起来了，也是超时重传，但是超过16次或者多少次会断开连接。然后还问关于应用层协议都有哪些应用等等，比如http、ftp等等</li>\n<li>关于Java基本上没问任何问题，就问我我的这些语言哪个最强，我就说第一Java，然后python，然后C和C++。</li>\n<li>关于以后想往哪个方向发展等等。基本上就是在聊天了。</li>\n</ul>\n</blockquote>\n<h4 id=\"二面（综合面）\"><a href=\"#二面（综合面）\" class=\"headerlink\" title=\"二面（综合面）\"></a>二面（综合面）</h4><blockquote>\n<p>综合面。。。就是关于你什么性格吗，怎么学习的，未来怎么规划的，喜欢加班吗。？？？我真是害怕他这么问，那就是说加班很多咯，好怕怕。而且二面官有点年纪了，冷冰冰的，我害怕，然后就一直说话，说一句解释两句。比如加班问题，我说我不是很怕加班，正常加班的话我是能接受的，额，什么是正常加班。。。然后开始解释，越解释越乱。最后二面官笑了，说你回去等通知吧，我说谢谢您嘞。赶紧溜了。</p>\n</blockquote>\n<p>华为面试真是奇葩。。</p>"},{"toc":true,"title":"去哪儿面经","date":"2017-09-16T06:14:22.000Z","_content":"\n纪念我的第一个offer，心仪的~\n<!--more-->\n##### 篇章1：宣讲会拿pass卡\n时间：9月13日\n地点：逸夫3阶\n经过：去哪儿2018校园招聘宣讲长春站——吉林大学，我在华为和去哪儿之间想了一下，毫不犹豫的去了去哪儿，感谢我的决定，让我幸运的拿到了面试直通卡。在hr介绍完qunar之后，技术面试官XXX开始问答环节，答对专业问题可得有限的pass卡。**第一个问题：Java的同步机制有些？**，我勇敢的举手回答：“synchronized和lock锁”，面试官问还有吗？我一时竟没想起volatile关键字，真是代码写的少啊。再问如果在分布式环境下怎么同步呢？我还是没答上，不过还是很幸运的拿到了pass卡，感谢兵哥。等这几天面试笔试过了再具体研究一下Java同步机制吧。\n\n###### 篇章2：面试之一二三\n时间：9月16日\n地点：吉大东门卡斯顿酒店\n经过：有了面试直通卡，我开始加快紧张的复习进程，由于在数据库以及linux命令方面已经忘了很多，赶紧重新捡起来，幸好这些都是基础的命令以及学过的知识，所以在一天就把这些东西都初略的看了一遍。在15日晚上还在慕课上重温了一下SSM框架，很幸运，有一个问题也问到回答上了。\n**一面：**\n\t15号晚上睡得很晚，就为了多看几眼框架知识，一大早起来吧mybatis又看了一些，过一会儿发现实在是看不完了，时间也不早了，赶紧洗漱去找同学一起去面试。到了酒店，大概8点55分，短信上通知是9点20，前面还有5个人。等了几分钟感觉有点心慌，就上了个大号，很惊奇竟然心情放松了下来，可能是看的毕导公众号新文章《当熊孩子遇到熊工程师，看谁能斗过谁！》心里竟然乐了。出来3分钟左右就被叫上，“XXX去804房间”。终于，我见到了一面面试官，一位很俊朗的中年男子...（反正不小了对吧，hah）。下面是专业问题，非专业人员请注意跳过：\n\t- 自我介绍：你好，我叫XXX，XX的X，XX的X，来自革命红区江西，现在是吉林大学计算机学院大四的本科生。我在大学期间比较擅长算法和数据结构，也喜欢捣鼓一些技术和项目，比如企业管理项目、网易云爬虫；暑期在北京借贷宝公司实习了两个月。在这些项目中我深入的应用了基础知识，更加的牢固，也学习了怎么在团队中合作开发。非常喜欢去哪儿公司，希望能够胜任这次应聘的岗位。（背了很多遍，当时还是有点慌，不过没失误）\n\t- 熟悉jdk源码吗？挑一个最熟悉的讲。我讲的hashmap，然后被问new HashMap(-10)是什么，我：不知道...，面试官：new HashMap(10,-2)呢？我：不知道...\n\t- volatile关键字。回答的一般，没说精确。\n\t- mybatis，回答的一般，因为用的少，没怎么学过，但是项目中写了。\n\t- session验证，怎么实现的，拦截器，答上了。\n\t- 写个Sql语句吧，额，好。在一个表中OID属性列选出重复的元组，写上了。\n\t- linux了解吗？嗯。用的哪些命令最多。more、less、tail、head，然后是ls，mv等等很多。还问了几个linux命令，回答的一般\n\t- 咱们写个代码吧。好。那就写个堆排序吧。额，写了大概5分钟，好了。解释一下，解释了。好的。\n\t- 你表现得不错，为什么来去哪儿。喜欢去哪儿。\n\t- 你是什么样的人。？？？说了一波，感觉自己是个傻子。面试官：这个傻子。。\n\t- 你最近有在看什么书吗？《重构》《设计模式》\n\t- 本来要放我走了，没想到最后还来一个问题。我们有IP黑名单机制，让你用list和set存储这些IP，你选哪个。我选择死亡....当然不能这么说，我选set，因为有HashSet，效率很高，查询时间复杂度O(1)，而list为O(n)；\n\n**二面：**\n\t答完一面后，让我去604房间等，期间认识一个校友保研北大的，想认识这位大佬，结果5分钟左右被叫去1104。到了房间，看见一位穿格子裤衩的大佬坐在那儿等我，没错，就是兵大佬。我敲了门，他说请进，坐下。\n\t- 自我介绍：又背了一遍。\n\t- 诶？我认识你，你是之前拿pass卡的是吧。是。上次那个问题你回去之后有查吗。查了，当时忘了volatile，然后分布式下的同步机制我只知道一致性hash是分布式缓存的，查了一些资料看的很懵，没记住。大佬说也不复杂，就是一些锁。我...是是是，回去再查查。等会又有blog可写了。\n\t- 你做了很多项目啊，选一个你最熟悉的讲讲。我...又是选一个最熟悉的讲，太棒了，hahah。就是这个项目是我自己写的一个爬虫，巴拉巴拉。嗯，遇到了什么难点，怎么解决的。一个是评论页面需要登录，看了一篇Blog解决过；反爬虫，IP代理以及请求头的伪装等；还有事多线程；还有正则表达式解析等。\n\t- 等我讲完上面这个，这个老大开始讲起了飞机票部门，我就静静的看大佬说完。\n\t- 你实习是在借贷宝？对。我有一些之前的同事在里面。是吗，我老大之前是去哪儿的，叫XXX。确定叫XXX？男的女的？男的。不叫某某X吗？哦哦，你说X哥啊，他在我们楼上，经常下来讨论，说话很大声是吧。对，就是他，他是清华毕业的，之前是我带的。我...果然还是你大佬。\n\t- 聊了一会儿。去604等吧。\n\n**三面（HR）：**\n\t在604和北大老哥聊了半天，叫上了我。一进门，hr好漂亮，好有气质。聊得好开心，然后愉快的给了offer。\n\n\n拿到了心仪的offer，很开心，这段时间很忙很乱，但是也知道了自己有很多不足。之后的求职就回轻松一点，不过这几天还是慢不下来。这段时间就多看看专业书以及框架知识吧。求职真的很累，很漫长的过程，一直被拒的感受真的很难受，但是你必须明白，不管有多难受，你都得坚持。加油！\n","source":"_posts/去哪儿面经.md","raw":"---\ntoc: true\ntitle: 去哪儿面经\ndate: 2017-09-16 14:14:22\ntags: [面经,qunar]\n---\n\n纪念我的第一个offer，心仪的~\n<!--more-->\n##### 篇章1：宣讲会拿pass卡\n时间：9月13日\n地点：逸夫3阶\n经过：去哪儿2018校园招聘宣讲长春站——吉林大学，我在华为和去哪儿之间想了一下，毫不犹豫的去了去哪儿，感谢我的决定，让我幸运的拿到了面试直通卡。在hr介绍完qunar之后，技术面试官XXX开始问答环节，答对专业问题可得有限的pass卡。**第一个问题：Java的同步机制有些？**，我勇敢的举手回答：“synchronized和lock锁”，面试官问还有吗？我一时竟没想起volatile关键字，真是代码写的少啊。再问如果在分布式环境下怎么同步呢？我还是没答上，不过还是很幸运的拿到了pass卡，感谢兵哥。等这几天面试笔试过了再具体研究一下Java同步机制吧。\n\n###### 篇章2：面试之一二三\n时间：9月16日\n地点：吉大东门卡斯顿酒店\n经过：有了面试直通卡，我开始加快紧张的复习进程，由于在数据库以及linux命令方面已经忘了很多，赶紧重新捡起来，幸好这些都是基础的命令以及学过的知识，所以在一天就把这些东西都初略的看了一遍。在15日晚上还在慕课上重温了一下SSM框架，很幸运，有一个问题也问到回答上了。\n**一面：**\n\t15号晚上睡得很晚，就为了多看几眼框架知识，一大早起来吧mybatis又看了一些，过一会儿发现实在是看不完了，时间也不早了，赶紧洗漱去找同学一起去面试。到了酒店，大概8点55分，短信上通知是9点20，前面还有5个人。等了几分钟感觉有点心慌，就上了个大号，很惊奇竟然心情放松了下来，可能是看的毕导公众号新文章《当熊孩子遇到熊工程师，看谁能斗过谁！》心里竟然乐了。出来3分钟左右就被叫上，“XXX去804房间”。终于，我见到了一面面试官，一位很俊朗的中年男子...（反正不小了对吧，hah）。下面是专业问题，非专业人员请注意跳过：\n\t- 自我介绍：你好，我叫XXX，XX的X，XX的X，来自革命红区江西，现在是吉林大学计算机学院大四的本科生。我在大学期间比较擅长算法和数据结构，也喜欢捣鼓一些技术和项目，比如企业管理项目、网易云爬虫；暑期在北京借贷宝公司实习了两个月。在这些项目中我深入的应用了基础知识，更加的牢固，也学习了怎么在团队中合作开发。非常喜欢去哪儿公司，希望能够胜任这次应聘的岗位。（背了很多遍，当时还是有点慌，不过没失误）\n\t- 熟悉jdk源码吗？挑一个最熟悉的讲。我讲的hashmap，然后被问new HashMap(-10)是什么，我：不知道...，面试官：new HashMap(10,-2)呢？我：不知道...\n\t- volatile关键字。回答的一般，没说精确。\n\t- mybatis，回答的一般，因为用的少，没怎么学过，但是项目中写了。\n\t- session验证，怎么实现的，拦截器，答上了。\n\t- 写个Sql语句吧，额，好。在一个表中OID属性列选出重复的元组，写上了。\n\t- linux了解吗？嗯。用的哪些命令最多。more、less、tail、head，然后是ls，mv等等很多。还问了几个linux命令，回答的一般\n\t- 咱们写个代码吧。好。那就写个堆排序吧。额，写了大概5分钟，好了。解释一下，解释了。好的。\n\t- 你表现得不错，为什么来去哪儿。喜欢去哪儿。\n\t- 你是什么样的人。？？？说了一波，感觉自己是个傻子。面试官：这个傻子。。\n\t- 你最近有在看什么书吗？《重构》《设计模式》\n\t- 本来要放我走了，没想到最后还来一个问题。我们有IP黑名单机制，让你用list和set存储这些IP，你选哪个。我选择死亡....当然不能这么说，我选set，因为有HashSet，效率很高，查询时间复杂度O(1)，而list为O(n)；\n\n**二面：**\n\t答完一面后，让我去604房间等，期间认识一个校友保研北大的，想认识这位大佬，结果5分钟左右被叫去1104。到了房间，看见一位穿格子裤衩的大佬坐在那儿等我，没错，就是兵大佬。我敲了门，他说请进，坐下。\n\t- 自我介绍：又背了一遍。\n\t- 诶？我认识你，你是之前拿pass卡的是吧。是。上次那个问题你回去之后有查吗。查了，当时忘了volatile，然后分布式下的同步机制我只知道一致性hash是分布式缓存的，查了一些资料看的很懵，没记住。大佬说也不复杂，就是一些锁。我...是是是，回去再查查。等会又有blog可写了。\n\t- 你做了很多项目啊，选一个你最熟悉的讲讲。我...又是选一个最熟悉的讲，太棒了，hahah。就是这个项目是我自己写的一个爬虫，巴拉巴拉。嗯，遇到了什么难点，怎么解决的。一个是评论页面需要登录，看了一篇Blog解决过；反爬虫，IP代理以及请求头的伪装等；还有事多线程；还有正则表达式解析等。\n\t- 等我讲完上面这个，这个老大开始讲起了飞机票部门，我就静静的看大佬说完。\n\t- 你实习是在借贷宝？对。我有一些之前的同事在里面。是吗，我老大之前是去哪儿的，叫XXX。确定叫XXX？男的女的？男的。不叫某某X吗？哦哦，你说X哥啊，他在我们楼上，经常下来讨论，说话很大声是吧。对，就是他，他是清华毕业的，之前是我带的。我...果然还是你大佬。\n\t- 聊了一会儿。去604等吧。\n\n**三面（HR）：**\n\t在604和北大老哥聊了半天，叫上了我。一进门，hr好漂亮，好有气质。聊得好开心，然后愉快的给了offer。\n\n\n拿到了心仪的offer，很开心，这段时间很忙很乱，但是也知道了自己有很多不足。之后的求职就回轻松一点，不过这几天还是慢不下来。这段时间就多看看专业书以及框架知识吧。求职真的很累，很漫长的过程，一直被拒的感受真的很难受，但是你必须明白，不管有多难受，你都得坚持。加油！\n","slug":"去哪儿面经","published":1,"updated":"2018-08-13T14:28:27.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4l000t6k159btquu62","content":"<p>纪念我的第一个offer，心仪的~<br><a id=\"more\"></a></p>\n<h5 id=\"篇章1：宣讲会拿pass卡\"><a href=\"#篇章1：宣讲会拿pass卡\" class=\"headerlink\" title=\"篇章1：宣讲会拿pass卡\"></a>篇章1：宣讲会拿pass卡</h5><p>时间：9月13日<br>地点：逸夫3阶<br>经过：去哪儿2018校园招聘宣讲长春站——吉林大学，我在华为和去哪儿之间想了一下，毫不犹豫的去了去哪儿，感谢我的决定，让我幸运的拿到了面试直通卡。在hr介绍完qunar之后，技术面试官XXX开始问答环节，答对专业问题可得有限的pass卡。<strong>第一个问题：Java的同步机制有些？</strong>，我勇敢的举手回答：“synchronized和lock锁”，面试官问还有吗？我一时竟没想起volatile关键字，真是代码写的少啊。再问如果在分布式环境下怎么同步呢？我还是没答上，不过还是很幸运的拿到了pass卡，感谢兵哥。等这几天面试笔试过了再具体研究一下Java同步机制吧。</p>\n<h6 id=\"篇章2：面试之一二三\"><a href=\"#篇章2：面试之一二三\" class=\"headerlink\" title=\"篇章2：面试之一二三\"></a>篇章2：面试之一二三</h6><p>时间：9月16日<br>地点：吉大东门卡斯顿酒店<br>经过：有了面试直通卡，我开始加快紧张的复习进程，由于在数据库以及linux命令方面已经忘了很多，赶紧重新捡起来，幸好这些都是基础的命令以及学过的知识，所以在一天就把这些东西都初略的看了一遍。在15日晚上还在慕课上重温了一下SSM框架，很幸运，有一个问题也问到回答上了。<br><strong>一面：</strong><br>    15号晚上睡得很晚，就为了多看几眼框架知识，一大早起来吧mybatis又看了一些，过一会儿发现实在是看不完了，时间也不早了，赶紧洗漱去找同学一起去面试。到了酒店，大概8点55分，短信上通知是9点20，前面还有5个人。等了几分钟感觉有点心慌，就上了个大号，很惊奇竟然心情放松了下来，可能是看的毕导公众号新文章《当熊孩子遇到熊工程师，看谁能斗过谁！》心里竟然乐了。出来3分钟左右就被叫上，“XXX去804房间”。终于，我见到了一面面试官，一位很俊朗的中年男子…（反正不小了对吧，hah）。下面是专业问题，非专业人员请注意跳过：</p>\n<pre><code>- 自我介绍：你好，我叫XXX，XX的X，XX的X，来自革命红区江西，现在是吉林大学计算机学院大四的本科生。我在大学期间比较擅长算法和数据结构，也喜欢捣鼓一些技术和项目，比如企业管理项目、网易云爬虫；暑期在北京借贷宝公司实习了两个月。在这些项目中我深入的应用了基础知识，更加的牢固，也学习了怎么在团队中合作开发。非常喜欢去哪儿公司，希望能够胜任这次应聘的岗位。（背了很多遍，当时还是有点慌，不过没失误）\n- 熟悉jdk源码吗？挑一个最熟悉的讲。我讲的hashmap，然后被问new HashMap(-10)是什么，我：不知道...，面试官：new HashMap(10,-2)呢？我：不知道...\n- volatile关键字。回答的一般，没说精确。\n- mybatis，回答的一般，因为用的少，没怎么学过，但是项目中写了。\n- session验证，怎么实现的，拦截器，答上了。\n- 写个Sql语句吧，额，好。在一个表中OID属性列选出重复的元组，写上了。\n- linux了解吗？嗯。用的哪些命令最多。more、less、tail、head，然后是ls，mv等等很多。还问了几个linux命令，回答的一般\n- 咱们写个代码吧。好。那就写个堆排序吧。额，写了大概5分钟，好了。解释一下，解释了。好的。\n- 你表现得不错，为什么来去哪儿。喜欢去哪儿。\n- 你是什么样的人。？？？说了一波，感觉自己是个傻子。面试官：这个傻子。。\n- 你最近有在看什么书吗？《重构》《设计模式》\n- 本来要放我走了，没想到最后还来一个问题。我们有IP黑名单机制，让你用list和set存储这些IP，你选哪个。我选择死亡....当然不能这么说，我选set，因为有HashSet，效率很高，查询时间复杂度O(1)，而list为O(n)；\n</code></pre><p><strong>二面：</strong><br>    答完一面后，让我去604房间等，期间认识一个校友保研北大的，想认识这位大佬，结果5分钟左右被叫去1104。到了房间，看见一位穿格子裤衩的大佬坐在那儿等我，没错，就是兵大佬。我敲了门，他说请进，坐下。</p>\n<pre><code>- 自我介绍：又背了一遍。\n- 诶？我认识你，你是之前拿pass卡的是吧。是。上次那个问题你回去之后有查吗。查了，当时忘了volatile，然后分布式下的同步机制我只知道一致性hash是分布式缓存的，查了一些资料看的很懵，没记住。大佬说也不复杂，就是一些锁。我...是是是，回去再查查。等会又有blog可写了。\n- 你做了很多项目啊，选一个你最熟悉的讲讲。我...又是选一个最熟悉的讲，太棒了，hahah。就是这个项目是我自己写的一个爬虫，巴拉巴拉。嗯，遇到了什么难点，怎么解决的。一个是评论页面需要登录，看了一篇Blog解决过；反爬虫，IP代理以及请求头的伪装等；还有事多线程；还有正则表达式解析等。\n- 等我讲完上面这个，这个老大开始讲起了飞机票部门，我就静静的看大佬说完。\n- 你实习是在借贷宝？对。我有一些之前的同事在里面。是吗，我老大之前是去哪儿的，叫XXX。确定叫XXX？男的女的？男的。不叫某某X吗？哦哦，你说X哥啊，他在我们楼上，经常下来讨论，说话很大声是吧。对，就是他，他是清华毕业的，之前是我带的。我...果然还是你大佬。\n- 聊了一会儿。去604等吧。\n</code></pre><p><strong>三面（HR）：</strong><br>    在604和北大老哥聊了半天，叫上了我。一进门，hr好漂亮，好有气质。聊得好开心，然后愉快的给了offer。</p>\n<p>拿到了心仪的offer，很开心，这段时间很忙很乱，但是也知道了自己有很多不足。之后的求职就回轻松一点，不过这几天还是慢不下来。这段时间就多看看专业书以及框架知识吧。求职真的很累，很漫长的过程，一直被拒的感受真的很难受，但是你必须明白，不管有多难受，你都得坚持。加油！</p>\n","site":{"data":{}},"excerpt":"<p>纪念我的第一个offer，心仪的~<br>","more":"</p>\n<h5 id=\"篇章1：宣讲会拿pass卡\"><a href=\"#篇章1：宣讲会拿pass卡\" class=\"headerlink\" title=\"篇章1：宣讲会拿pass卡\"></a>篇章1：宣讲会拿pass卡</h5><p>时间：9月13日<br>地点：逸夫3阶<br>经过：去哪儿2018校园招聘宣讲长春站——吉林大学，我在华为和去哪儿之间想了一下，毫不犹豫的去了去哪儿，感谢我的决定，让我幸运的拿到了面试直通卡。在hr介绍完qunar之后，技术面试官XXX开始问答环节，答对专业问题可得有限的pass卡。<strong>第一个问题：Java的同步机制有些？</strong>，我勇敢的举手回答：“synchronized和lock锁”，面试官问还有吗？我一时竟没想起volatile关键字，真是代码写的少啊。再问如果在分布式环境下怎么同步呢？我还是没答上，不过还是很幸运的拿到了pass卡，感谢兵哥。等这几天面试笔试过了再具体研究一下Java同步机制吧。</p>\n<h6 id=\"篇章2：面试之一二三\"><a href=\"#篇章2：面试之一二三\" class=\"headerlink\" title=\"篇章2：面试之一二三\"></a>篇章2：面试之一二三</h6><p>时间：9月16日<br>地点：吉大东门卡斯顿酒店<br>经过：有了面试直通卡，我开始加快紧张的复习进程，由于在数据库以及linux命令方面已经忘了很多，赶紧重新捡起来，幸好这些都是基础的命令以及学过的知识，所以在一天就把这些东西都初略的看了一遍。在15日晚上还在慕课上重温了一下SSM框架，很幸运，有一个问题也问到回答上了。<br><strong>一面：</strong><br>    15号晚上睡得很晚，就为了多看几眼框架知识，一大早起来吧mybatis又看了一些，过一会儿发现实在是看不完了，时间也不早了，赶紧洗漱去找同学一起去面试。到了酒店，大概8点55分，短信上通知是9点20，前面还有5个人。等了几分钟感觉有点心慌，就上了个大号，很惊奇竟然心情放松了下来，可能是看的毕导公众号新文章《当熊孩子遇到熊工程师，看谁能斗过谁！》心里竟然乐了。出来3分钟左右就被叫上，“XXX去804房间”。终于，我见到了一面面试官，一位很俊朗的中年男子…（反正不小了对吧，hah）。下面是专业问题，非专业人员请注意跳过：</p>\n<pre><code>- 自我介绍：你好，我叫XXX，XX的X，XX的X，来自革命红区江西，现在是吉林大学计算机学院大四的本科生。我在大学期间比较擅长算法和数据结构，也喜欢捣鼓一些技术和项目，比如企业管理项目、网易云爬虫；暑期在北京借贷宝公司实习了两个月。在这些项目中我深入的应用了基础知识，更加的牢固，也学习了怎么在团队中合作开发。非常喜欢去哪儿公司，希望能够胜任这次应聘的岗位。（背了很多遍，当时还是有点慌，不过没失误）\n- 熟悉jdk源码吗？挑一个最熟悉的讲。我讲的hashmap，然后被问new HashMap(-10)是什么，我：不知道...，面试官：new HashMap(10,-2)呢？我：不知道...\n- volatile关键字。回答的一般，没说精确。\n- mybatis，回答的一般，因为用的少，没怎么学过，但是项目中写了。\n- session验证，怎么实现的，拦截器，答上了。\n- 写个Sql语句吧，额，好。在一个表中OID属性列选出重复的元组，写上了。\n- linux了解吗？嗯。用的哪些命令最多。more、less、tail、head，然后是ls，mv等等很多。还问了几个linux命令，回答的一般\n- 咱们写个代码吧。好。那就写个堆排序吧。额，写了大概5分钟，好了。解释一下，解释了。好的。\n- 你表现得不错，为什么来去哪儿。喜欢去哪儿。\n- 你是什么样的人。？？？说了一波，感觉自己是个傻子。面试官：这个傻子。。\n- 你最近有在看什么书吗？《重构》《设计模式》\n- 本来要放我走了，没想到最后还来一个问题。我们有IP黑名单机制，让你用list和set存储这些IP，你选哪个。我选择死亡....当然不能这么说，我选set，因为有HashSet，效率很高，查询时间复杂度O(1)，而list为O(n)；\n</code></pre><p><strong>二面：</strong><br>    答完一面后，让我去604房间等，期间认识一个校友保研北大的，想认识这位大佬，结果5分钟左右被叫去1104。到了房间，看见一位穿格子裤衩的大佬坐在那儿等我，没错，就是兵大佬。我敲了门，他说请进，坐下。</p>\n<pre><code>- 自我介绍：又背了一遍。\n- 诶？我认识你，你是之前拿pass卡的是吧。是。上次那个问题你回去之后有查吗。查了，当时忘了volatile，然后分布式下的同步机制我只知道一致性hash是分布式缓存的，查了一些资料看的很懵，没记住。大佬说也不复杂，就是一些锁。我...是是是，回去再查查。等会又有blog可写了。\n- 你做了很多项目啊，选一个你最熟悉的讲讲。我...又是选一个最熟悉的讲，太棒了，hahah。就是这个项目是我自己写的一个爬虫，巴拉巴拉。嗯，遇到了什么难点，怎么解决的。一个是评论页面需要登录，看了一篇Blog解决过；反爬虫，IP代理以及请求头的伪装等；还有事多线程；还有正则表达式解析等。\n- 等我讲完上面这个，这个老大开始讲起了飞机票部门，我就静静的看大佬说完。\n- 你实习是在借贷宝？对。我有一些之前的同事在里面。是吗，我老大之前是去哪儿的，叫XXX。确定叫XXX？男的女的？男的。不叫某某X吗？哦哦，你说X哥啊，他在我们楼上，经常下来讨论，说话很大声是吧。对，就是他，他是清华毕业的，之前是我带的。我...果然还是你大佬。\n- 聊了一会儿。去604等吧。\n</code></pre><p><strong>三面（HR）：</strong><br>    在604和北大老哥聊了半天，叫上了我。一进门，hr好漂亮，好有气质。聊得好开心，然后愉快的给了offer。</p>\n<p>拿到了心仪的offer，很开心，这段时间很忙很乱，但是也知道了自己有很多不足。之后的求职就回轻松一点，不过这几天还是慢不下来。这段时间就多看看专业书以及框架知识吧。求职真的很累，很漫长的过程，一直被拒的感受真的很难受，但是你必须明白，不管有多难受，你都得坚持。加油！</p>"},{"toc":true,"title":"指路人，还是引路人","date":"2018-04-10T03:40:09.000Z","_content":"\n![Alt text](https://app.yinxiang.com/shard/s15/res/5c3168dc-9d1c-46ea-9d80-0b519e04a479/1523330153082.png)\n写完几天的博客，就打开v2ex逛贴。首先看到的就是这个贴，关于头条等新闻资讯类应用下架的事件，大家争论的很凶，我浏览的几十条，一半一半。\n<!--more-->\n以下使用MM代指那个。\n\n这些app确实需要管制，如UC标题党、头条等资讯很多垃圾新闻一样。我们需要看到的是优质内容，而不是垃圾文章。以前发文章发书本肯定比现在严格吧，大家看到的都是经过很多编辑审批过的。现在人人都能发表自己的观点，这一点很好，但是2-8原则也能应用在这儿，80%的文章都是垃圾，没有任何营养。各个资讯app审核人员真的过关吗，平台之间抄袭别人的文章不注明出处，随便一个女人一个动作一个喷嚏都能发篇文章然后平台还置顶推送给千千万万的`人`。而`机器学习`各种算法推送的内容可信吗？我喜欢的真的不一定好，这就是人性本善和人性本恶之争了。这些都想说明一点：我们看到的信息内容不够优质，这就需要一个组织来管理审核，甚至立法。\n\n当然，现在MM还能管，但是怎么管，百姓是否认同这么管是最头疼的。我身边最少50%的人已经对MM的满意度低于80%。而不满意的地方主要就是言论的自由，我以MM代称就说明了有多害怕，百姓如果害怕MM，那这个世界就不是我们真正想要的；而这些新闻平台关于MM的文章评论都是一致的隐含式万岁。所以MM不能只是单纯怎么管，还要给理由，墙没有理由，影视没有自由，言论没有自由，阅读没有自由。自由的界限在哪儿。\n","source":"_posts/指路人，还是引路人.md","raw":"---\ntoc: true\ntitle: 指路人，还是引路人\ndate: 2018-04-10 11:40:09\ntags: [杂谈]\n---\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/5c3168dc-9d1c-46ea-9d80-0b519e04a479/1523330153082.png)\n写完几天的博客，就打开v2ex逛贴。首先看到的就是这个贴，关于头条等新闻资讯类应用下架的事件，大家争论的很凶，我浏览的几十条，一半一半。\n<!--more-->\n以下使用MM代指那个。\n\n这些app确实需要管制，如UC标题党、头条等资讯很多垃圾新闻一样。我们需要看到的是优质内容，而不是垃圾文章。以前发文章发书本肯定比现在严格吧，大家看到的都是经过很多编辑审批过的。现在人人都能发表自己的观点，这一点很好，但是2-8原则也能应用在这儿，80%的文章都是垃圾，没有任何营养。各个资讯app审核人员真的过关吗，平台之间抄袭别人的文章不注明出处，随便一个女人一个动作一个喷嚏都能发篇文章然后平台还置顶推送给千千万万的`人`。而`机器学习`各种算法推送的内容可信吗？我喜欢的真的不一定好，这就是人性本善和人性本恶之争了。这些都想说明一点：我们看到的信息内容不够优质，这就需要一个组织来管理审核，甚至立法。\n\n当然，现在MM还能管，但是怎么管，百姓是否认同这么管是最头疼的。我身边最少50%的人已经对MM的满意度低于80%。而不满意的地方主要就是言论的自由，我以MM代称就说明了有多害怕，百姓如果害怕MM，那这个世界就不是我们真正想要的；而这些新闻平台关于MM的文章评论都是一致的隐含式万岁。所以MM不能只是单纯怎么管，还要给理由，墙没有理由，影视没有自由，言论没有自由，阅读没有自由。自由的界限在哪儿。\n","slug":"指路人，还是引路人","published":1,"updated":"2018-08-13T14:28:27.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4n000v6k15v48voov1","content":"<p><img src=\"https://app.yinxiang.com/shard/s15/res/5c3168dc-9d1c-46ea-9d80-0b519e04a479/1523330153082.png\" alt=\"Alt text\"><br>写完几天的博客，就打开v2ex逛贴。首先看到的就是这个贴，关于头条等新闻资讯类应用下架的事件，大家争论的很凶，我浏览的几十条，一半一半。<br><a id=\"more\"></a><br>以下使用MM代指那个。</p>\n<p>这些app确实需要管制，如UC标题党、头条等资讯很多垃圾新闻一样。我们需要看到的是优质内容，而不是垃圾文章。以前发文章发书本肯定比现在严格吧，大家看到的都是经过很多编辑审批过的。现在人人都能发表自己的观点，这一点很好，但是2-8原则也能应用在这儿，80%的文章都是垃圾，没有任何营养。各个资讯app审核人员真的过关吗，平台之间抄袭别人的文章不注明出处，随便一个女人一个动作一个喷嚏都能发篇文章然后平台还置顶推送给千千万万的<code>人</code>。而<code>机器学习</code>各种算法推送的内容可信吗？我喜欢的真的不一定好，这就是人性本善和人性本恶之争了。这些都想说明一点：我们看到的信息内容不够优质，这就需要一个组织来管理审核，甚至立法。</p>\n<p>当然，现在MM还能管，但是怎么管，百姓是否认同这么管是最头疼的。我身边最少50%的人已经对MM的满意度低于80%。而不满意的地方主要就是言论的自由，我以MM代称就说明了有多害怕，百姓如果害怕MM，那这个世界就不是我们真正想要的；而这些新闻平台关于MM的文章评论都是一致的隐含式万岁。所以MM不能只是单纯怎么管，还要给理由，墙没有理由，影视没有自由，言论没有自由，阅读没有自由。自由的界限在哪儿。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://app.yinxiang.com/shard/s15/res/5c3168dc-9d1c-46ea-9d80-0b519e04a479/1523330153082.png\" alt=\"Alt text\"><br>写完几天的博客，就打开v2ex逛贴。首先看到的就是这个贴，关于头条等新闻资讯类应用下架的事件，大家争论的很凶，我浏览的几十条，一半一半。<br>","more":"<br>以下使用MM代指那个。</p>\n<p>这些app确实需要管制，如UC标题党、头条等资讯很多垃圾新闻一样。我们需要看到的是优质内容，而不是垃圾文章。以前发文章发书本肯定比现在严格吧，大家看到的都是经过很多编辑审批过的。现在人人都能发表自己的观点，这一点很好，但是2-8原则也能应用在这儿，80%的文章都是垃圾，没有任何营养。各个资讯app审核人员真的过关吗，平台之间抄袭别人的文章不注明出处，随便一个女人一个动作一个喷嚏都能发篇文章然后平台还置顶推送给千千万万的<code>人</code>。而<code>机器学习</code>各种算法推送的内容可信吗？我喜欢的真的不一定好，这就是人性本善和人性本恶之争了。这些都想说明一点：我们看到的信息内容不够优质，这就需要一个组织来管理审核，甚至立法。</p>\n<p>当然，现在MM还能管，但是怎么管，百姓是否认同这么管是最头疼的。我身边最少50%的人已经对MM的满意度低于80%。而不满意的地方主要就是言论的自由，我以MM代称就说明了有多害怕，百姓如果害怕MM，那这个世界就不是我们真正想要的；而这些新闻平台关于MM的文章评论都是一致的隐含式万岁。所以MM不能只是单纯怎么管，还要给理由，墙没有理由，影视没有自由，言论没有自由，阅读没有自由。自由的界限在哪儿。</p>"},{"title":"起风了","date":"2018-03-30T07:43:52.000Z","_content":"很烦，学不进去，又不敢多玩游戏，难受。\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=461525011&auto=0&height=66\"></iframe>\n","source":"_posts/起风了.md","raw":"---\ntitle: 起风了\ndate: 2018-03-30 15:43:52\ntags: [music]\n---\n很烦，学不进去，又不敢多玩游戏，难受。\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=461525011&auto=0&height=66\"></iframe>\n","slug":"起风了","published":1,"updated":"2018-08-13T14:28:27.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e4o000x6k15kdzwo5rx","content":"<p>很烦，学不进去，又不敢多玩游戏，难受。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=461525011&auto=0&height=66\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<p>很烦，学不进去，又不敢多玩游戏，难受。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=461525011&auto=0&height=66\"></iframe>\n"},{"toc":true,"title":"JSON","date":"2018-03-26T03:24:55.000Z","_content":"\n## json基本概念\njson的基本概念在官网已经解释的很清楚，我肯定没有官网讲的更好，请自行前往[Json官网](http://www.json.org/json-zh.html)查阅。\n<!--more-->\n## java怎么处理json\nJava下常见的Json类库有Gson、JSO-lib和Jackson等，Jackson相对来说比较高效，在项目中主要使用Jackson进行JSON和Java对象转换。转换原理是序列化，序列化在之前已经写过。\n### jackson\n#### 概述\nJackson框架是基于Java平台的一套数据处理工具，被称为“最好的Java Json解析器”。\nJackson框架包含了3个核心库：core, annotations, databind。\nJackson版本： 1.x (目前版本从1.1~1.9)与2.x。1.x与2.x从包的命名上可以看出来，1.x的类库中，包命名以：org.codehaus.jackson.xxx开头，而2.x类库中包命令：com.fastxml.jackson.xxx开头\n#### 准备工作\nJackson有1.x系列和2.x系列，2.x系列有3个jar包需要下载：\njackson-core-2.2.3.jar（核心jar包）\njackson-annotations-2.2.3.jar（该包提供Json注解支持）\njackson-databind-2.2.3.jar\n一个maven依赖就够了\n```xml\n<dependency>\n   <groupId>com.fasterxml.jackson.core</groupId>\n   <artifactId>jackson-databind</artifactId>\n   <version>2.5.3</version>\n</dependency>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/16accc9f-27b7-4be3-a4a4-b4be4e9fd9f5/1522028544170.png)\n\n#### jackson处理json\nJackson提供了三种可选的Json处理方法：\n1. Streaming API：效率最高，开销低、读写速度快，但编程复杂度高\n2. Tree Model：最灵活\n3. Data Binding：最常用\n##### 1. DataBinding处理Json\n**(1)java对象转换成Json**\n```java\npackage json;\n\nimport java.util.Date;\n\n/**\n * JSON序列化和反序列化使用的User类\n * author: jifang\n * date: 18-3-26 上午9:49\n */\n\npublic class User {\n    private String name;\n    private Integer age;\n    private Date birthday;\n    private String email;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", birthday=\" + birthday +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n}\n```\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:52\n */\n\npublic class JavaBeanSerializeToJson {\n    public static void main(String[] args) throws IOException {\n        User user = new User();\n        user.setName(\"james\");\n        user.setAge(33);\n        user.setEmail(\"james@nba.com\");\n        Date date = new Date();\n        user.setBirthday(date);\n\n        /**\n         * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。\n         * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。\n         * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。\n         * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。\n         * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。\n         * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。\n         */\n        ObjectMapper mapper = new ObjectMapper();\n\n        //java对象转JSON\n        //输出结果：{\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"}\n        mapper.writeValue(new File(\"data1-1.json\"),user);\n\n        //Java集合转JSON\n        //输出结果：[{\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"}]\n        List<User> users = new ArrayList<>();\n        users.add(user);\n        mapper.writeValue(new File(\"data1-2.json\"),users);\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * author: jifang\n * date: 18-3-26 上午10:00\n */\n\npublic class JsonDeserializeToJava {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n\n        //Json转换成java对象\n        //输出结果：User{name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'}\n        File json1 = new File(\"data1-1.json\");\n        //当反序列化json时，未知属性会引起的反序列化被打断，这里我们禁用未知属性打断反序列化功能，\n        //因为，例如json里有10个属性，而我们的bean中只定义了2个属性，其它8个属性将被忽略\n        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n        User user = mapper.readValue(json1, User.class);\n        System.out.println(user);\n\n        //Json转换成Java集合\n        //输出结果：[User{name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'}]\n        File json2 = new File(\"data1-2.json\");\n        List<User> users = mapper.readValue(json2, new TypeReference<List<User>>(){});\n        System.out.println(users);\n    }\n}\n\n```\n##### 2. Tree Model处理Json\n**(1)java对象转换成Json**\n这里的`User`类与上面的有所不同，把`email`类型改成`String[]`。\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:11\n */\n\npublic class SerializationExampleTreeModel {\n    public static void main(String[] args) throws IOException {\n        //创建一个节点工厂,为我们提供所有节点\n        JsonNodeFactory factory = new JsonNodeFactory(false);\n        //创建一个json factory来写tree modle为json\n        JsonFactory jsonFactory = new JsonFactory();\n        //创建一个json生成器\n        JsonGenerator generator = jsonFactory.createGenerator(new FileWriter(\"data2.json\"));\n        //注意，默认情况下对象映射器不会指定根节点，下面设根节点为country\n        ObjectMapper mapper = new ObjectMapper();\n        ObjectNode user = factory.objectNode();\n\n        user.put(\"name\",\"james\");\n        user.put(\"age\",33);\n        user.put(\"date\", \"2018-03-26\");\n        ArrayNode email = factory.arrayNode();\n        email.add(\"james@nba.com\").add(\"james@cav.com\");\n        user.set(\"email\",email);\n        mapper.configure(SerializationFeature.INDENT_OUTPUT,true);\n        //输出结果：{\"name\":\"james\",\"age\":33,\"date\":\"2018-03-26\",\"email\":[\"james@nba.com\",\"james@cav.com\"]}\n        mapper.writeTree(generator, user);\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * author: jifang\n * date: 18-3-26 上午10:54\n */\n\npublic class DeserializationExampleTreeModel1 {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        // Jackson提供一个树节点被称为\"JsonNode\",ObjectMapper提供方法来读json作为树的JsonNode根节点\n        JsonNode node = mapper.readTree(new File(\"data2.json\"));\n        // 看看根节点的类型\n        System.out.println(\"node JsonNodeType:\" + node.getNodeType());\n        // 是不是一个容器\n        System.out.println(\"node is container Node ? \" + node.isContainerNode());\n        // 得到所有node节点的子节点名称\n        System.out.println(\"---------得到所有node节点的子节点名称-------------------------\");\n        Iterator<String> fieldNames = node.fieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            System.out.print(fieldName + \" \");\n        }\n        System.out.println(\"\\n-----------------------------------------------------\");\n        // asText的作用是有值返回值，无值返回空字符串\n        JsonNode name = node.get(\"name\");\n        System.out.println(\"name: \" + name.asText() + \"\\t JsonNodeType: \" + name.getNodeType());\n        JsonNode age = node.get(\"age\");\n        System.out.println(\"age: \" + age.asText() + \"\\t JsonNodeType: \" + age.getNodeType());\n        JsonNode date = node.get(\"date\");\n        System.out.println(\"date: \" + date.asText() + \"\\t JsonNodeType: \" + date.getNodeType());\n        JsonNode email = node.get(\"email\");\n        System.out.println(\"email: \" + email + \"\\t JsonNodeType: \" + email.getNodeType());\n    }\n}\n\n```\n再来看一下DeserializationExampleTreeModel2.java,本例中使用JsonNode.path的方法，path方法类似于DeserializationExampleTreeModel1.java中使用的get方法，\n\n但当node不存在时,get方法返回null,而path返回MISSING类型的JsonNode\n```java\npackage json;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午11:07\n */\n\npublic class DeserializationExampleTreeModle2 {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        JsonNode node = mapper.readTree(new File(\"data2.json\"));\n        //path方法获取JsonNode时，当对象不存在时，返回MISSING类型的JsonNode\n        JsonNode missingNode = node.path(\"test\");\n        if (missingNode.isMissingNode()){\n            System.out.println(\"JsonNodeType: \"+missingNode.getNodeType());\n        }\n        System.out.println(\"name: \" + node.path(\"name\").asText());\n        JsonNode email = node.path(\"email\");\n        System.out.println(\"email: \"+email);\n    }\n}\n\n```\n##### 3. Stream处理Json\n**(1)java对象转换成Json**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:02\n */\n\npublic class StreamGeneratorJson {\n    public static void main(String[] args) throws IOException {\n        JsonFactory factory = new JsonFactory();\n        JsonGenerator generator = factory.createGenerator(new FileWriter(new File(\"data3.json\")));\n        generator.writeStartObject();\n        generator.writeFieldName(\"country_id\");\n        generator.writeString(\"China\");\n        generator.writeFieldName(\"provinces\");\n        generator.writeStartArray();\n        generator.writeStartObject();\n        generator.writeStringField(\"name\", \"Shanxi\");\n        generator.writeNumberField(\"population\", 33750000);\n        generator.writeEndObject();\n        generator.writeEndArray();\n        generator.writeEndObject();\n        generator.close();\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午8:51\n */\n\npublic class StreamParseJson {\n\n    public static void main(String[] args) throws IOException {\n        JsonFactory factory = new JsonFactory();\n        JsonParser parser = factory.createParser(new File(\"data3.json\"));\n        while (!parser.isClosed()){\n            JsonToken token = parser.nextToken();\n            if (token ==null)break;\n            if (JsonToken.FIELD_NAME.equals(token)&&\"provinces\".equals(parser.getCurrentName())){\n                token = parser.nextToken();\n                if (!JsonToken.START_ARRAY.equals(token))break;\n                token = parser.nextToken();\n                if (!JsonToken.START_OBJECT.equals(token)){\n                    break;\n                }\n                while (true){\n                    token = parser.nextToken();\n                    if (token ==null){\n                        break;\n                    }\n                    if (JsonToken.FIELD_NAME.equals(token) && \"population\".equals(parser.getCurrentName())){\n                        token = parser.nextToken();\n                        System.out.println(parser.getCurrentName()+\":\"+parser.getIntValue());\n                    }\n                }\n            }\n        }\n    }\n}\n\n```\n## 总结\n引用csdn`博主(java_huashan)`的总结：\n> 上面的例子中，分别用3种方式处理Json，我的体会大致如下：\n> \n> Stream API方式是开销最低、效率最高，但编写代码复杂度也最高，在生成Json时，需要逐步编写符号和字段拼接json,在解析Json时，需要根据token指向也查找json值，生成和解析json都不是很方便，代码可读性也很低。\n> Databinding处理Json是最常用的json处理方式，生成json时，创建相关的java对象，并根据json内容结构把java对象组装起来，最后调用writeValue方法即可生成json,\n> 解析时，就更简单了，直接把json映射到相关的java对象，然后就可以遍历java对象来获取值了。\n> TreeModel处理Json，是以树型结构来生成和解析json，生成json时，根据json内容结构，我们创建不同类型的节点对象，组装这些节点生成json。解析json时，它不需要绑定json到java bean，根据json结构，使用path或get方法轻松查找内容。\n\njson就到这儿，如果大家对数据感兴趣的话还可以查看这篇文章[还在用JSON? Google Protocol Buffers 更快更小 (原理篇)](https://juejin.im/post/5ab08a5f6fb9a028e46e7770)\n> 参考文献\n> [1] [JackSon学习笔记(一)](https://blog.csdn.net/java_huashan/article/details/46375857)\n> [2] [Java下利用Jackson进行JSON解析和序列化](https://www.cnblogs.com/winner-0715/p/6109225.html)\n","source":"_posts/JSON.md","raw":"---\ntoc: true\ntitle: JSON\ndate: 2018-03-26 11:24:55\ntags: [JSON]\n---\n\n## json基本概念\njson的基本概念在官网已经解释的很清楚，我肯定没有官网讲的更好，请自行前往[Json官网](http://www.json.org/json-zh.html)查阅。\n<!--more-->\n## java怎么处理json\nJava下常见的Json类库有Gson、JSO-lib和Jackson等，Jackson相对来说比较高效，在项目中主要使用Jackson进行JSON和Java对象转换。转换原理是序列化，序列化在之前已经写过。\n### jackson\n#### 概述\nJackson框架是基于Java平台的一套数据处理工具，被称为“最好的Java Json解析器”。\nJackson框架包含了3个核心库：core, annotations, databind。\nJackson版本： 1.x (目前版本从1.1~1.9)与2.x。1.x与2.x从包的命名上可以看出来，1.x的类库中，包命名以：org.codehaus.jackson.xxx开头，而2.x类库中包命令：com.fastxml.jackson.xxx开头\n#### 准备工作\nJackson有1.x系列和2.x系列，2.x系列有3个jar包需要下载：\njackson-core-2.2.3.jar（核心jar包）\njackson-annotations-2.2.3.jar（该包提供Json注解支持）\njackson-databind-2.2.3.jar\n一个maven依赖就够了\n```xml\n<dependency>\n   <groupId>com.fasterxml.jackson.core</groupId>\n   <artifactId>jackson-databind</artifactId>\n   <version>2.5.3</version>\n</dependency>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/16accc9f-27b7-4be3-a4a4-b4be4e9fd9f5/1522028544170.png)\n\n#### jackson处理json\nJackson提供了三种可选的Json处理方法：\n1. Streaming API：效率最高，开销低、读写速度快，但编程复杂度高\n2. Tree Model：最灵活\n3. Data Binding：最常用\n##### 1. DataBinding处理Json\n**(1)java对象转换成Json**\n```java\npackage json;\n\nimport java.util.Date;\n\n/**\n * JSON序列化和反序列化使用的User类\n * author: jifang\n * date: 18-3-26 上午9:49\n */\n\npublic class User {\n    private String name;\n    private Integer age;\n    private Date birthday;\n    private String email;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", birthday=\" + birthday +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n}\n```\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:52\n */\n\npublic class JavaBeanSerializeToJson {\n    public static void main(String[] args) throws IOException {\n        User user = new User();\n        user.setName(\"james\");\n        user.setAge(33);\n        user.setEmail(\"james@nba.com\");\n        Date date = new Date();\n        user.setBirthday(date);\n\n        /**\n         * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。\n         * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。\n         * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。\n         * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。\n         * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。\n         * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。\n         */\n        ObjectMapper mapper = new ObjectMapper();\n\n        //java对象转JSON\n        //输出结果：{\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"}\n        mapper.writeValue(new File(\"data1-1.json\"),user);\n\n        //Java集合转JSON\n        //输出结果：[{\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"}]\n        List<User> users = new ArrayList<>();\n        users.add(user);\n        mapper.writeValue(new File(\"data1-2.json\"),users);\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * author: jifang\n * date: 18-3-26 上午10:00\n */\n\npublic class JsonDeserializeToJava {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n\n        //Json转换成java对象\n        //输出结果：User{name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'}\n        File json1 = new File(\"data1-1.json\");\n        //当反序列化json时，未知属性会引起的反序列化被打断，这里我们禁用未知属性打断反序列化功能，\n        //因为，例如json里有10个属性，而我们的bean中只定义了2个属性，其它8个属性将被忽略\n        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n        User user = mapper.readValue(json1, User.class);\n        System.out.println(user);\n\n        //Json转换成Java集合\n        //输出结果：[User{name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'}]\n        File json2 = new File(\"data1-2.json\");\n        List<User> users = mapper.readValue(json2, new TypeReference<List<User>>(){});\n        System.out.println(users);\n    }\n}\n\n```\n##### 2. Tree Model处理Json\n**(1)java对象转换成Json**\n这里的`User`类与上面的有所不同，把`email`类型改成`String[]`。\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.JsonNodeFactory;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:11\n */\n\npublic class SerializationExampleTreeModel {\n    public static void main(String[] args) throws IOException {\n        //创建一个节点工厂,为我们提供所有节点\n        JsonNodeFactory factory = new JsonNodeFactory(false);\n        //创建一个json factory来写tree modle为json\n        JsonFactory jsonFactory = new JsonFactory();\n        //创建一个json生成器\n        JsonGenerator generator = jsonFactory.createGenerator(new FileWriter(\"data2.json\"));\n        //注意，默认情况下对象映射器不会指定根节点，下面设根节点为country\n        ObjectMapper mapper = new ObjectMapper();\n        ObjectNode user = factory.objectNode();\n\n        user.put(\"name\",\"james\");\n        user.put(\"age\",33);\n        user.put(\"date\", \"2018-03-26\");\n        ArrayNode email = factory.arrayNode();\n        email.add(\"james@nba.com\").add(\"james@cav.com\");\n        user.set(\"email\",email);\n        mapper.configure(SerializationFeature.INDENT_OUTPUT,true);\n        //输出结果：{\"name\":\"james\",\"age\":33,\"date\":\"2018-03-26\",\"email\":[\"james@nba.com\",\"james@cav.com\"]}\n        mapper.writeTree(generator, user);\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\n\n/**\n * author: jifang\n * date: 18-3-26 上午10:54\n */\n\npublic class DeserializationExampleTreeModel1 {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        // Jackson提供一个树节点被称为\"JsonNode\",ObjectMapper提供方法来读json作为树的JsonNode根节点\n        JsonNode node = mapper.readTree(new File(\"data2.json\"));\n        // 看看根节点的类型\n        System.out.println(\"node JsonNodeType:\" + node.getNodeType());\n        // 是不是一个容器\n        System.out.println(\"node is container Node ? \" + node.isContainerNode());\n        // 得到所有node节点的子节点名称\n        System.out.println(\"---------得到所有node节点的子节点名称-------------------------\");\n        Iterator<String> fieldNames = node.fieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            System.out.print(fieldName + \" \");\n        }\n        System.out.println(\"\\n-----------------------------------------------------\");\n        // asText的作用是有值返回值，无值返回空字符串\n        JsonNode name = node.get(\"name\");\n        System.out.println(\"name: \" + name.asText() + \"\\t JsonNodeType: \" + name.getNodeType());\n        JsonNode age = node.get(\"age\");\n        System.out.println(\"age: \" + age.asText() + \"\\t JsonNodeType: \" + age.getNodeType());\n        JsonNode date = node.get(\"date\");\n        System.out.println(\"date: \" + date.asText() + \"\\t JsonNodeType: \" + date.getNodeType());\n        JsonNode email = node.get(\"email\");\n        System.out.println(\"email: \" + email + \"\\t JsonNodeType: \" + email.getNodeType());\n    }\n}\n\n```\n再来看一下DeserializationExampleTreeModel2.java,本例中使用JsonNode.path的方法，path方法类似于DeserializationExampleTreeModel1.java中使用的get方法，\n\n但当node不存在时,get方法返回null,而path返回MISSING类型的JsonNode\n```java\npackage json;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午11:07\n */\n\npublic class DeserializationExampleTreeModle2 {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        JsonNode node = mapper.readTree(new File(\"data2.json\"));\n        //path方法获取JsonNode时，当对象不存在时，返回MISSING类型的JsonNode\n        JsonNode missingNode = node.path(\"test\");\n        if (missingNode.isMissingNode()){\n            System.out.println(\"JsonNodeType: \"+missingNode.getNodeType());\n        }\n        System.out.println(\"name: \" + node.path(\"name\").asText());\n        JsonNode email = node.path(\"email\");\n        System.out.println(\"email: \"+email);\n    }\n}\n\n```\n##### 3. Stream处理Json\n**(1)java对象转换成Json**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午9:02\n */\n\npublic class StreamGeneratorJson {\n    public static void main(String[] args) throws IOException {\n        JsonFactory factory = new JsonFactory();\n        JsonGenerator generator = factory.createGenerator(new FileWriter(new File(\"data3.json\")));\n        generator.writeStartObject();\n        generator.writeFieldName(\"country_id\");\n        generator.writeString(\"China\");\n        generator.writeFieldName(\"provinces\");\n        generator.writeStartArray();\n        generator.writeStartObject();\n        generator.writeStringField(\"name\", \"Shanxi\");\n        generator.writeNumberField(\"population\", 33750000);\n        generator.writeEndObject();\n        generator.writeEndArray();\n        generator.writeEndObject();\n        generator.close();\n    }\n}\n\n```\n**(2)Json字符串反序列化为Java对象**\n```java\npackage json;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * author: jifang\n * date: 18-3-26 上午8:51\n */\n\npublic class StreamParseJson {\n\n    public static void main(String[] args) throws IOException {\n        JsonFactory factory = new JsonFactory();\n        JsonParser parser = factory.createParser(new File(\"data3.json\"));\n        while (!parser.isClosed()){\n            JsonToken token = parser.nextToken();\n            if (token ==null)break;\n            if (JsonToken.FIELD_NAME.equals(token)&&\"provinces\".equals(parser.getCurrentName())){\n                token = parser.nextToken();\n                if (!JsonToken.START_ARRAY.equals(token))break;\n                token = parser.nextToken();\n                if (!JsonToken.START_OBJECT.equals(token)){\n                    break;\n                }\n                while (true){\n                    token = parser.nextToken();\n                    if (token ==null){\n                        break;\n                    }\n                    if (JsonToken.FIELD_NAME.equals(token) && \"population\".equals(parser.getCurrentName())){\n                        token = parser.nextToken();\n                        System.out.println(parser.getCurrentName()+\":\"+parser.getIntValue());\n                    }\n                }\n            }\n        }\n    }\n}\n\n```\n## 总结\n引用csdn`博主(java_huashan)`的总结：\n> 上面的例子中，分别用3种方式处理Json，我的体会大致如下：\n> \n> Stream API方式是开销最低、效率最高，但编写代码复杂度也最高，在生成Json时，需要逐步编写符号和字段拼接json,在解析Json时，需要根据token指向也查找json值，生成和解析json都不是很方便，代码可读性也很低。\n> Databinding处理Json是最常用的json处理方式，生成json时，创建相关的java对象，并根据json内容结构把java对象组装起来，最后调用writeValue方法即可生成json,\n> 解析时，就更简单了，直接把json映射到相关的java对象，然后就可以遍历java对象来获取值了。\n> TreeModel处理Json，是以树型结构来生成和解析json，生成json时，根据json内容结构，我们创建不同类型的节点对象，组装这些节点生成json。解析json时，它不需要绑定json到java bean，根据json结构，使用path或get方法轻松查找内容。\n\njson就到这儿，如果大家对数据感兴趣的话还可以查看这篇文章[还在用JSON? Google Protocol Buffers 更快更小 (原理篇)](https://juejin.im/post/5ab08a5f6fb9a028e46e7770)\n> 参考文献\n> [1] [JackSon学习笔记(一)](https://blog.csdn.net/java_huashan/article/details/46375857)\n> [2] [Java下利用Jackson进行JSON解析和序列化](https://www.cnblogs.com/winner-0715/p/6109225.html)\n","slug":"JSON","published":1,"updated":"2018-08-13T14:28:27.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5e002e6k1583kc95o4","content":"<h2 id=\"json基本概念\"><a href=\"#json基本概念\" class=\"headerlink\" title=\"json基本概念\"></a>json基本概念</h2><p>json的基本概念在官网已经解释的很清楚，我肯定没有官网讲的更好，请自行前往<a href=\"http://www.json.org/json-zh.html\" target=\"_blank\" rel=\"noopener\">Json官网</a>查阅。<br><a id=\"more\"></a></p>\n<h2 id=\"java怎么处理json\"><a href=\"#java怎么处理json\" class=\"headerlink\" title=\"java怎么处理json\"></a>java怎么处理json</h2><p>Java下常见的Json类库有Gson、JSO-lib和Jackson等，Jackson相对来说比较高效，在项目中主要使用Jackson进行JSON和Java对象转换。转换原理是序列化，序列化在之前已经写过。</p>\n<h3 id=\"jackson\"><a href=\"#jackson\" class=\"headerlink\" title=\"jackson\"></a>jackson</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Jackson框架是基于Java平台的一套数据处理工具，被称为“最好的Java Json解析器”。<br>Jackson框架包含了3个核心库：core, annotations, databind。<br>Jackson版本： 1.x (目前版本从1.1~1.9)与2.x。1.x与2.x从包的命名上可以看出来，1.x的类库中，包命名以：org.codehaus.jackson.xxx开头，而2.x类库中包命令：com.fastxml.jackson.xxx开头</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>Jackson有1.x系列和2.x系列，2.x系列有3个jar包需要下载：<br>jackson-core-2.2.3.jar（核心jar包）<br>jackson-annotations-2.2.3.jar（该包提供Json注解支持）<br>jackson-databind-2.2.3.jar<br>一个maven依赖就够了<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/16accc9f-27b7-4be3-a4a4-b4be4e9fd9f5/1522028544170.png\" alt=\"Alt text\"></p>\n<h4 id=\"jackson处理json\"><a href=\"#jackson处理json\" class=\"headerlink\" title=\"jackson处理json\"></a>jackson处理json</h4><p>Jackson提供了三种可选的Json处理方法：</p>\n<ol>\n<li>Streaming API：效率最高，开销低、读写速度快，但编程复杂度高</li>\n<li>Tree Model：最灵活</li>\n<li>Data Binding：最常用<h5 id=\"1-DataBinding处理Json\"><a href=\"#1-DataBinding处理Json\" class=\"headerlink\" title=\"1. DataBinding处理Json\"></a>1. DataBinding处理Json</h5><strong>(1)java对象转换成Json</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JSON序列化和反序列化使用的User类</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:49</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date birthday;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirthday</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirthday</span><span class=\"params\">(Date birthday)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">\", birthday=\"</span> + birthday +</span><br><span class=\"line\">                <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:52</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaBeanSerializeToJson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"james\"</span>);</span><br><span class=\"line\">        user.setAge(<span class=\"number\">33</span>);</span><br><span class=\"line\">        user.setEmail(<span class=\"string\">\"james@nba.com\"</span>);</span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        user.setBirthday(date);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</span></span><br><span class=\"line\"><span class=\"comment\">         * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//java对象转JSON</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：&#123;\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"&#125;</span></span><br><span class=\"line\">        mapper.writeValue(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-1.json\"</span>),user);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Java集合转JSON</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：[&#123;\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"&#125;]</span></span><br><span class=\"line\">        List&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        users.add(user);</span><br><span class=\"line\">        mapper.writeValue(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-2.json\"</span>),users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午10:00</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonDeserializeToJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Json转换成java对象</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：User&#123;name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'&#125;</span></span><br><span class=\"line\">        File json1 = <span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-1.json\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当反序列化json时，未知属性会引起的反序列化被打断，这里我们禁用未知属性打断反序列化功能，</span></span><br><span class=\"line\">        <span class=\"comment\">//因为，例如json里有10个属性，而我们的bean中只定义了2个属性，其它8个属性将被忽略</span></span><br><span class=\"line\">        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class=\"line\">        User user = mapper.readValue(json1, User.class);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Json转换成Java集合</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：[User&#123;name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'&#125;]</span></span><br><span class=\"line\">        File json2 = <span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-2.json\"</span>);</span><br><span class=\"line\">        List&lt;User&gt; users = mapper.readValue(json2, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);</span><br><span class=\"line\">        System.out.println(users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-Tree-Model处理Json\"><a href=\"#2-Tree-Model处理Json\" class=\"headerlink\" title=\"2. Tree Model处理Json\"></a>2. Tree Model处理Json</h5><p><strong>(1)java对象转换成Json</strong><br>这里的<code>User</code>类与上面的有所不同，把<code>email</code>类型改成<code>String[]</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.ArrayNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.JsonNodeFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.ObjectNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializationExampleTreeModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个节点工厂,为我们提供所有节点</span></span><br><span class=\"line\">        JsonNodeFactory factory = <span class=\"keyword\">new</span> JsonNodeFactory(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个json factory来写tree modle为json</span></span><br><span class=\"line\">        JsonFactory jsonFactory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个json生成器</span></span><br><span class=\"line\">        JsonGenerator generator = jsonFactory.createGenerator(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//注意，默认情况下对象映射器不会指定根节点，下面设根节点为country</span></span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        ObjectNode user = factory.objectNode();</span><br><span class=\"line\"></span><br><span class=\"line\">        user.put(<span class=\"string\">\"name\"</span>,<span class=\"string\">\"james\"</span>);</span><br><span class=\"line\">        user.put(<span class=\"string\">\"age\"</span>,<span class=\"number\">33</span>);</span><br><span class=\"line\">        user.put(<span class=\"string\">\"date\"</span>, <span class=\"string\">\"2018-03-26\"</span>);</span><br><span class=\"line\">        ArrayNode email = factory.arrayNode();</span><br><span class=\"line\">        email.add(<span class=\"string\">\"james@nba.com\"</span>).add(<span class=\"string\">\"james@cav.com\"</span>);</span><br><span class=\"line\">        user.set(<span class=\"string\">\"email\"</span>,email);</span><br><span class=\"line\">        mapper.configure(SerializationFeature.INDENT_OUTPUT,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//输出结果：&#123;\"name\":\"james\",\"age\":33,\"date\":\"2018-03-26\",\"email\":[\"james@nba.com\",\"james@cav.com\"]&#125;</span></span><br><span class=\"line\">        mapper.writeTree(generator, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午10:54</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializationExampleTreeModel1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        <span class=\"comment\">// Jackson提供一个树节点被称为\"JsonNode\",ObjectMapper提供方法来读json作为树的JsonNode根节点</span></span><br><span class=\"line\">        JsonNode node = mapper.readTree(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 看看根节点的类型</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"node JsonNodeType:\"</span> + node.getNodeType());</span><br><span class=\"line\">        <span class=\"comment\">// 是不是一个容器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"node is container Node ? \"</span> + node.isContainerNode());</span><br><span class=\"line\">        <span class=\"comment\">// 得到所有node节点的子节点名称</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"---------得到所有node节点的子节点名称-------------------------\"</span>);</span><br><span class=\"line\">        Iterator&lt;String&gt; fieldNames = node.fieldNames();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fieldNames.hasNext()) &#123;</span><br><span class=\"line\">            String fieldName = fieldNames.next();</span><br><span class=\"line\">            System.out.print(fieldName + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\\n-----------------------------------------------------\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// asText的作用是有值返回值，无值返回空字符串</span></span><br><span class=\"line\">        JsonNode name = node.get(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + name.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + name.getNodeType());</span><br><span class=\"line\">        JsonNode age = node.get(<span class=\"string\">\"age\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + age.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + age.getNodeType());</span><br><span class=\"line\">        JsonNode date = node.get(<span class=\"string\">\"date\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"date: \"</span> + date.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + date.getNodeType());</span><br><span class=\"line\">        JsonNode email = node.get(<span class=\"string\">\"email\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"email: \"</span> + email + <span class=\"string\">\"\\t JsonNodeType: \"</span> + email.getNodeType());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看一下DeserializationExampleTreeModel2.java,本例中使用JsonNode.path的方法，path方法类似于DeserializationExampleTreeModel1.java中使用的get方法，</p>\n<p>但当node不存在时,get方法返回null,而path返回MISSING类型的JsonNode<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午11:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializationExampleTreeModle2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        JsonNode node = mapper.readTree(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//path方法获取JsonNode时，当对象不存在时，返回MISSING类型的JsonNode</span></span><br><span class=\"line\">        JsonNode missingNode = node.path(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missingNode.isMissingNode())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"JsonNodeType: \"</span>+missingNode.getNodeType());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + node.path(<span class=\"string\">\"name\"</span>).asText());</span><br><span class=\"line\">        JsonNode email = node.path(<span class=\"string\">\"email\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"email: \"</span>+email);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-Stream处理Json\"><a href=\"#3-Stream处理Json\" class=\"headerlink\" title=\"3. Stream处理Json\"></a>3. Stream处理Json</h5><p><strong>(1)java对象转换成Json</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:02</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamGeneratorJson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        JsonFactory factory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        JsonGenerator generator = factory.createGenerator(<span class=\"keyword\">new</span> FileWriter(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data3.json\"</span>)));</span><br><span class=\"line\">        generator.writeStartObject();</span><br><span class=\"line\">        generator.writeFieldName(<span class=\"string\">\"country_id\"</span>);</span><br><span class=\"line\">        generator.writeString(<span class=\"string\">\"China\"</span>);</span><br><span class=\"line\">        generator.writeFieldName(<span class=\"string\">\"provinces\"</span>);</span><br><span class=\"line\">        generator.writeStartArray();</span><br><span class=\"line\">        generator.writeStartObject();</span><br><span class=\"line\">        generator.writeStringField(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Shanxi\"</span>);</span><br><span class=\"line\">        generator.writeNumberField(<span class=\"string\">\"population\"</span>, <span class=\"number\">33750000</span>);</span><br><span class=\"line\">        generator.writeEndObject();</span><br><span class=\"line\">        generator.writeEndArray();</span><br><span class=\"line\">        generator.writeEndObject();</span><br><span class=\"line\">        generator.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonToken;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午8:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamParseJson</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        JsonFactory factory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        JsonParser parser = factory.createParser(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data3.json\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!parser.isClosed())&#123;</span><br><span class=\"line\">            JsonToken token = parser.nextToken();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token ==<span class=\"keyword\">null</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (JsonToken.FIELD_NAME.equals(token)&amp;&amp;<span class=\"string\">\"provinces\"</span>.equals(parser.getCurrentName()))&#123;</span><br><span class=\"line\">                token = parser.nextToken();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!JsonToken.START_ARRAY.equals(token))<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                token = parser.nextToken();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!JsonToken.START_OBJECT.equals(token))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                    token = parser.nextToken();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (token ==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (JsonToken.FIELD_NAME.equals(token) &amp;&amp; <span class=\"string\">\"population\"</span>.equals(parser.getCurrentName()))&#123;</span><br><span class=\"line\">                        token = parser.nextToken();</span><br><span class=\"line\">                        System.out.println(parser.getCurrentName()+<span class=\"string\">\":\"</span>+parser.getIntValue());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>引用csdn<code>博主(java_huashan)</code>的总结：</p>\n<blockquote>\n<p>上面的例子中，分别用3种方式处理Json，我的体会大致如下：</p>\n<p>Stream API方式是开销最低、效率最高，但编写代码复杂度也最高，在生成Json时，需要逐步编写符号和字段拼接json,在解析Json时，需要根据token指向也查找json值，生成和解析json都不是很方便，代码可读性也很低。<br>Databinding处理Json是最常用的json处理方式，生成json时，创建相关的java对象，并根据json内容结构把java对象组装起来，最后调用writeValue方法即可生成json,<br>解析时，就更简单了，直接把json映射到相关的java对象，然后就可以遍历java对象来获取值了。<br>TreeModel处理Json，是以树型结构来生成和解析json，生成json时，根据json内容结构，我们创建不同类型的节点对象，组装这些节点生成json。解析json时，它不需要绑定json到java bean，根据json结构，使用path或get方法轻松查找内容。</p>\n</blockquote>\n<p>json就到这儿，如果大家对数据感兴趣的话还可以查看这篇文章<a href=\"https://juejin.im/post/5ab08a5f6fb9a028e46e7770\" target=\"_blank\" rel=\"noopener\">还在用JSON? Google Protocol Buffers 更快更小 (原理篇)</a></p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://blog.csdn.net/java_huashan/article/details/46375857\" target=\"_blank\" rel=\"noopener\">JackSon学习笔记(一)</a><br>[2] <a href=\"https://www.cnblogs.com/winner-0715/p/6109225.html\" target=\"_blank\" rel=\"noopener\">Java下利用Jackson进行JSON解析和序列化</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"json基本概念\"><a href=\"#json基本概念\" class=\"headerlink\" title=\"json基本概念\"></a>json基本概念</h2><p>json的基本概念在官网已经解释的很清楚，我肯定没有官网讲的更好，请自行前往<a href=\"http://www.json.org/json-zh.html\" target=\"_blank\" rel=\"noopener\">Json官网</a>查阅。<br>","more":"</p>\n<h2 id=\"java怎么处理json\"><a href=\"#java怎么处理json\" class=\"headerlink\" title=\"java怎么处理json\"></a>java怎么处理json</h2><p>Java下常见的Json类库有Gson、JSO-lib和Jackson等，Jackson相对来说比较高效，在项目中主要使用Jackson进行JSON和Java对象转换。转换原理是序列化，序列化在之前已经写过。</p>\n<h3 id=\"jackson\"><a href=\"#jackson\" class=\"headerlink\" title=\"jackson\"></a>jackson</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Jackson框架是基于Java平台的一套数据处理工具，被称为“最好的Java Json解析器”。<br>Jackson框架包含了3个核心库：core, annotations, databind。<br>Jackson版本： 1.x (目前版本从1.1~1.9)与2.x。1.x与2.x从包的命名上可以看出来，1.x的类库中，包命名以：org.codehaus.jackson.xxx开头，而2.x类库中包命令：com.fastxml.jackson.xxx开头</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>Jackson有1.x系列和2.x系列，2.x系列有3个jar包需要下载：<br>jackson-core-2.2.3.jar（核心jar包）<br>jackson-annotations-2.2.3.jar（该包提供Json注解支持）<br>jackson-databind-2.2.3.jar<br>一个maven依赖就够了<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jackson-databind<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/16accc9f-27b7-4be3-a4a4-b4be4e9fd9f5/1522028544170.png\" alt=\"Alt text\"></p>\n<h4 id=\"jackson处理json\"><a href=\"#jackson处理json\" class=\"headerlink\" title=\"jackson处理json\"></a>jackson处理json</h4><p>Jackson提供了三种可选的Json处理方法：</p>\n<ol>\n<li>Streaming API：效率最高，开销低、读写速度快，但编程复杂度高</li>\n<li>Tree Model：最灵活</li>\n<li>Data Binding：最常用<h5 id=\"1-DataBinding处理Json\"><a href=\"#1-DataBinding处理Json\" class=\"headerlink\" title=\"1. DataBinding处理Json\"></a>1. DataBinding处理Json</h5><strong>(1)java对象转换成Json</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JSON序列化和反序列化使用的User类</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:49</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date birthday;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirthday</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirthday</span><span class=\"params\">(Date birthday)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.birthday = birthday;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> email;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"User&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">\", birthday=\"</span> + birthday +</span><br><span class=\"line\">                <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:52</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaBeanSerializeToJson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"james\"</span>);</span><br><span class=\"line\">        user.setAge(<span class=\"number\">33</span>);</span><br><span class=\"line\">        user.setEmail(<span class=\"string\">\"james@nba.com\"</span>);</span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        user.setBirthday(date);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</span></span><br><span class=\"line\"><span class=\"comment\">         * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</span></span><br><span class=\"line\"><span class=\"comment\">         * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//java对象转JSON</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：&#123;\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"&#125;</span></span><br><span class=\"line\">        mapper.writeValue(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-1.json\"</span>),user);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Java集合转JSON</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：[&#123;\"name\":\"james\",\"age\":33,\"birthday\":1522029481531,\"email\":\"james@nba.com\"&#125;]</span></span><br><span class=\"line\">        List&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        users.add(user);</span><br><span class=\"line\">        mapper.writeValue(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-2.json\"</span>),users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午10:00</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonDeserializeToJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Json转换成java对象</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：User&#123;name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'&#125;</span></span><br><span class=\"line\">        File json1 = <span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-1.json\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当反序列化json时，未知属性会引起的反序列化被打断，这里我们禁用未知属性打断反序列化功能，</span></span><br><span class=\"line\">        <span class=\"comment\">//因为，例如json里有10个属性，而我们的bean中只定义了2个属性，其它8个属性将被忽略</span></span><br><span class=\"line\">        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class=\"line\">        User user = mapper.readValue(json1, User.class);</span><br><span class=\"line\">        System.out.println(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Json转换成Java集合</span></span><br><span class=\"line\">        <span class=\"comment\">//输出结果：[User&#123;name='james', age=33, birthday=Mon Mar 26 10:03:22 CST 2018, email='james@nba.com'&#125;]</span></span><br><span class=\"line\">        File json2 = <span class=\"keyword\">new</span> File(<span class=\"string\">\"data1-2.json\"</span>);</span><br><span class=\"line\">        List&lt;User&gt; users = mapper.readValue(json2, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);</span><br><span class=\"line\">        System.out.println(users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-Tree-Model处理Json\"><a href=\"#2-Tree-Model处理Json\" class=\"headerlink\" title=\"2. Tree Model处理Json\"></a>2. Tree Model处理Json</h5><p><strong>(1)java对象转换成Json</strong><br>这里的<code>User</code>类与上面的有所不同，把<code>email</code>类型改成<code>String[]</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.ArrayNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.JsonNodeFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.node.ObjectNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializationExampleTreeModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个节点工厂,为我们提供所有节点</span></span><br><span class=\"line\">        JsonNodeFactory factory = <span class=\"keyword\">new</span> JsonNodeFactory(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个json factory来写tree modle为json</span></span><br><span class=\"line\">        JsonFactory jsonFactory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个json生成器</span></span><br><span class=\"line\">        JsonGenerator generator = jsonFactory.createGenerator(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//注意，默认情况下对象映射器不会指定根节点，下面设根节点为country</span></span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        ObjectNode user = factory.objectNode();</span><br><span class=\"line\"></span><br><span class=\"line\">        user.put(<span class=\"string\">\"name\"</span>,<span class=\"string\">\"james\"</span>);</span><br><span class=\"line\">        user.put(<span class=\"string\">\"age\"</span>,<span class=\"number\">33</span>);</span><br><span class=\"line\">        user.put(<span class=\"string\">\"date\"</span>, <span class=\"string\">\"2018-03-26\"</span>);</span><br><span class=\"line\">        ArrayNode email = factory.arrayNode();</span><br><span class=\"line\">        email.add(<span class=\"string\">\"james@nba.com\"</span>).add(<span class=\"string\">\"james@cav.com\"</span>);</span><br><span class=\"line\">        user.set(<span class=\"string\">\"email\"</span>,email);</span><br><span class=\"line\">        mapper.configure(SerializationFeature.INDENT_OUTPUT,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//输出结果：&#123;\"name\":\"james\",\"age\":33,\"date\":\"2018-03-26\",\"email\":[\"james@nba.com\",\"james@cav.com\"]&#125;</span></span><br><span class=\"line\">        mapper.writeTree(generator, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午10:54</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializationExampleTreeModel1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        <span class=\"comment\">// Jackson提供一个树节点被称为\"JsonNode\",ObjectMapper提供方法来读json作为树的JsonNode根节点</span></span><br><span class=\"line\">        JsonNode node = mapper.readTree(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 看看根节点的类型</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"node JsonNodeType:\"</span> + node.getNodeType());</span><br><span class=\"line\">        <span class=\"comment\">// 是不是一个容器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"node is container Node ? \"</span> + node.isContainerNode());</span><br><span class=\"line\">        <span class=\"comment\">// 得到所有node节点的子节点名称</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"---------得到所有node节点的子节点名称-------------------------\"</span>);</span><br><span class=\"line\">        Iterator&lt;String&gt; fieldNames = node.fieldNames();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fieldNames.hasNext()) &#123;</span><br><span class=\"line\">            String fieldName = fieldNames.next();</span><br><span class=\"line\">            System.out.print(fieldName + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\\n-----------------------------------------------------\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// asText的作用是有值返回值，无值返回空字符串</span></span><br><span class=\"line\">        JsonNode name = node.get(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + name.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + name.getNodeType());</span><br><span class=\"line\">        JsonNode age = node.get(<span class=\"string\">\"age\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + age.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + age.getNodeType());</span><br><span class=\"line\">        JsonNode date = node.get(<span class=\"string\">\"date\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"date: \"</span> + date.asText() + <span class=\"string\">\"\\t JsonNodeType: \"</span> + date.getNodeType());</span><br><span class=\"line\">        JsonNode email = node.get(<span class=\"string\">\"email\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"email: \"</span> + email + <span class=\"string\">\"\\t JsonNodeType: \"</span> + email.getNodeType());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看一下DeserializationExampleTreeModel2.java,本例中使用JsonNode.path的方法，path方法类似于DeserializationExampleTreeModel1.java中使用的get方法，</p>\n<p>但当node不存在时,get方法返回null,而path返回MISSING类型的JsonNode<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午11:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializationExampleTreeModle2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ObjectMapper mapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\">        JsonNode node = mapper.readTree(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data2.json\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//path方法获取JsonNode时，当对象不存在时，返回MISSING类型的JsonNode</span></span><br><span class=\"line\">        JsonNode missingNode = node.path(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (missingNode.isMissingNode())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"JsonNodeType: \"</span>+missingNode.getNodeType());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + node.path(<span class=\"string\">\"name\"</span>).asText());</span><br><span class=\"line\">        JsonNode email = node.path(<span class=\"string\">\"email\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"email: \"</span>+email);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-Stream处理Json\"><a href=\"#3-Stream处理Json\" class=\"headerlink\" title=\"3. Stream处理Json\"></a>3. Stream处理Json</h5><p><strong>(1)java对象转换成Json</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午9:02</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamGeneratorJson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        JsonFactory factory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        JsonGenerator generator = factory.createGenerator(<span class=\"keyword\">new</span> FileWriter(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data3.json\"</span>)));</span><br><span class=\"line\">        generator.writeStartObject();</span><br><span class=\"line\">        generator.writeFieldName(<span class=\"string\">\"country_id\"</span>);</span><br><span class=\"line\">        generator.writeString(<span class=\"string\">\"China\"</span>);</span><br><span class=\"line\">        generator.writeFieldName(<span class=\"string\">\"provinces\"</span>);</span><br><span class=\"line\">        generator.writeStartArray();</span><br><span class=\"line\">        generator.writeStartObject();</span><br><span class=\"line\">        generator.writeStringField(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Shanxi\"</span>);</span><br><span class=\"line\">        generator.writeNumberField(<span class=\"string\">\"population\"</span>, <span class=\"number\">33750000</span>);</span><br><span class=\"line\">        generator.writeEndObject();</span><br><span class=\"line\">        generator.writeEndArray();</span><br><span class=\"line\">        generator.writeEndObject();</span><br><span class=\"line\">        generator.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2)Json字符串反序列化为Java对象</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> json;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.fasterxml.jackson.core.JsonToken;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 上午8:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StreamParseJson</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        JsonFactory factory = <span class=\"keyword\">new</span> JsonFactory();</span><br><span class=\"line\">        JsonParser parser = factory.createParser(<span class=\"keyword\">new</span> File(<span class=\"string\">\"data3.json\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!parser.isClosed())&#123;</span><br><span class=\"line\">            JsonToken token = parser.nextToken();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token ==<span class=\"keyword\">null</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (JsonToken.FIELD_NAME.equals(token)&amp;&amp;<span class=\"string\">\"provinces\"</span>.equals(parser.getCurrentName()))&#123;</span><br><span class=\"line\">                token = parser.nextToken();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!JsonToken.START_ARRAY.equals(token))<span class=\"keyword\">break</span>;</span><br><span class=\"line\">                token = parser.nextToken();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!JsonToken.START_OBJECT.equals(token))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                    token = parser.nextToken();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (token ==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (JsonToken.FIELD_NAME.equals(token) &amp;&amp; <span class=\"string\">\"population\"</span>.equals(parser.getCurrentName()))&#123;</span><br><span class=\"line\">                        token = parser.nextToken();</span><br><span class=\"line\">                        System.out.println(parser.getCurrentName()+<span class=\"string\">\":\"</span>+parser.getIntValue());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>引用csdn<code>博主(java_huashan)</code>的总结：</p>\n<blockquote>\n<p>上面的例子中，分别用3种方式处理Json，我的体会大致如下：</p>\n<p>Stream API方式是开销最低、效率最高，但编写代码复杂度也最高，在生成Json时，需要逐步编写符号和字段拼接json,在解析Json时，需要根据token指向也查找json值，生成和解析json都不是很方便，代码可读性也很低。<br>Databinding处理Json是最常用的json处理方式，生成json时，创建相关的java对象，并根据json内容结构把java对象组装起来，最后调用writeValue方法即可生成json,<br>解析时，就更简单了，直接把json映射到相关的java对象，然后就可以遍历java对象来获取值了。<br>TreeModel处理Json，是以树型结构来生成和解析json，生成json时，根据json内容结构，我们创建不同类型的节点对象，组装这些节点生成json。解析json时，它不需要绑定json到java bean，根据json结构，使用path或get方法轻松查找内容。</p>\n</blockquote>\n<p>json就到这儿，如果大家对数据感兴趣的话还可以查看这篇文章<a href=\"https://juejin.im/post/5ab08a5f6fb9a028e46e7770\" target=\"_blank\" rel=\"noopener\">还在用JSON? Google Protocol Buffers 更快更小 (原理篇)</a></p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://blog.csdn.net/java_huashan/article/details/46375857\" target=\"_blank\" rel=\"noopener\">JackSon学习笔记(一)</a><br>[2] <a href=\"https://www.cnblogs.com/winner-0715/p/6109225.html\" target=\"_blank\" rel=\"noopener\">Java下利用Jackson进行JSON解析和序列化</a></p>\n</blockquote>"},{"toc":true,"title":"JDBC","date":"2018-03-29T07:36:01.000Z","_content":"\n\n## 1. 什么是JDBC？\n\n1996年，Sun公司发布了第一版的Java数据库连接（JDBC）API，使编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找与更新。JDBC自此称为Java类库中最常用的API之一。\n<!--more-->\n概念：\n- SQL：结构化查询语言，是一种特定的目的程序语言，用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。\n- MySQL：原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。\n- JDBC：Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is Java based data access technology and used for Java database connectivity. It is part of the Java Standard Edition platform, from Oracle Corporation. It provides methods to query and update data in a database, and is oriented towards relational databases. A JDBC-to-ODBC bridge enables connections to any ODBC-accessible data source in the Java virtual machine (JVM) host environment.\n\n## 2. JDBC配置\n你需要有一个可获得其JDBC驱动程序的数据库软件。目前这方面有很多出色的软件可供选择，比如IBM DB2、Microsoft SQL Server、MySQL、Oracle和PostgreSQL。在这一节，我会以MySQL为例演示，在下一篇博客，我会介绍H2缓存数据库。\n\n现在，假设你已经安装好了MySQL，有一个名称为`jifang`的`database`，并且有权限对这个数据库增删改查。\n\n### 2.1 数据库URL\n在连接数据库时，我们必须使用各种与数据库类型相关的参数，例如主机名、端口号和数据库名。\n\nJDBC URL一般格式：\n`jdbc:subprotocol:other stuff`\n其中，`subprotocol`（子协议名）用于选择连接到数据库的具体驱动程序。`other stuff`（数据源名）参数的格式随所使用的`subprotocol`不同而不同。如果要了解具体格式，你需要查阅数据库供应商的相关文档。\n\n#### 几种常见的数据库连接\n\n**1. Oracle **\n驱动：`oracle.jdbc.driver.OracleDriver` \nURL：`jdbc:oracle:thin:@host:port:dbname`\nhost：数据库所在的机器的地址； \nport：端口号，默认是1521\n\n**2. MySQL**\n驱动：`com.mysql.jdbc.Driver `\nURL：`jdbc:mysql://host:port/dbname `\nhost：数据库所在的机器的名称； \nport：端口号，默认3306\n\n**3. SQL Server**\n驱动：`com.microsoft.jdbc.sqlserver.SQLServerDriver` \nURL：`jdbc:microsoft:sqlserver://<host><:port>;DatabaseName=<dbname> `\nhost：数据库所在的机器的名称； \nport：端口号，默认是1433\n\n**4. DB2**\n驱动：`com.ibm.db2.jdbc.app.DB2Driver `\nURL：`jdbc:db2://<host><:port>/dbname` \nhost：数据库所在的机器的名称； \nport：端口号，默认是5000\n\n#### MySQL URL格式详解\n\n这里我们主要参考MySQL的URL格式\n`jdbc:mysql://[host][,failoverhost...][:port]/[database][?propertyName1][=propertyValue1][&propertyName2][=propertyValue2]...`\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/7df5d637-a933-43e8-98a6-e539d3b08fba/1522287325072.png)\n\n### 2.2 驱动程序\n你需要获得包含了你所使用的数据库的驱动程序的JAR文件。\n获取方法：\n1. 去官网[https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)载JDBC Driver\n解压之后获取`mysql-connector-java-5.1.46-bin.jar`这个jar包\n2. 使用Maven仓库下载 \n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.6</version>\n</dependency>\n```\n如果使用第二种方式，直接就会放在项目的`classpath`下。如果是第一种，下载好了之后如何安装呢? 把下载 的文件解压后的 `mysql-connector-java-5.1.46-bin.jar`文件 copy到 %JAVA_HOME%/jre/lib/ext 下， %JAVA_HOME就是jdk的安装目录。\n### 2.3 注册驱动器类\n某些JDBC的JAR文件将自动注册驱动器类，在这种情况下，可以跳过这一部分所描述的手动注册步骤。\n\n如果驱动程序JAR文件不支持自动注册，那就需要找出数据库提供商使用的JDBC驱动器类的名字。例如MySQL：\n`com.mysql.jdbc.Driver`\n\n通过使用`DriverManager`，可以使用两种方式来注册驱动器。一种方式是在Java程序中加载加载驱动器类，例如：\n`Class.forName(\"com.mysql.jdbc.Driver\");`\n这条语句将使得驱动器类被加载，由此将执行可以注册驱动器的静态初始化器。\n\n另一种方式是设置jdbc.drivers属性。可以用命令行参数来指定这个属性，例如：\n`java -Djdbc.drivers=com.mysql.jdbc.Driver ProgramName`\n或者在应用中用下面这样的调用来设置系统属性：\n`System.setProperty(\"jdbc.Driver\", \"com.mysql.jdbc.Driver\");`\n\n### 2.4 连接到数据库\n在Java程序中，我们可以在代码中打开一个数据库连接，例如：\n```java\nString url = properties.getProperty(\"jdbc.url\");\nString username = properties.getProperty(\"jdbc.username\");\nString password = properties.getProperty(\"jdbc.password\");\nConnection conn = DriverManager.getConnection(url,username,password);\n```\n驱动管理器遍历所有注册过的驱动程序，以便找到一个能够使用数据库URL中指定的子协议的驱动程序。\n\n### 2.5 执行SQL语句\n\n1. 执行SQL命令之前，首先需要创建一个`Statement`对象，\n`Statement stat = conn.createStatement();`\n2. SQL语句字符串\n`String sql = \"CREATE TABLE Greetings (Message CHAR(20))\"`\n3. 然后调用Statement接口中的`executeUpdate`方法\n`stat.executeUpdate(sql)`\n对于`INSERT DELETE UPDATE`等都使用`executeUpdate`方法，它返回受SQL命令影响的行数。对于`SELECT`使用`executeQuery`方法，它返回一个`ResultSet`类型的对象，可以通过它来每一行地迭代遍历所有查询结果。\n\n**注意：**`ResultSet`接口的迭代协议与java.util.Iterator接口稍有不同。对于`ResultSet`接口，迭代器初始化时被设定在第一行之前的位置，必须调用`next()`方法把它移动到第一行。另外，它没有`hasNext()`方法，我们需要不断地调用`next()`，知道它返回`false`。\n\n`ResultSet`中行的顺序是人任意的，除非你在`sql`使用了`ORDER BY`子句指定排序。\n\n#### **管理连接、语句和结果集** \n每个`Connection`对象都可以创建一个或多个`Statement`对象。同一个`Statement`对象可以用于多个不想干的命令和查阅。但是一个`Statement`对象最多只能有一个打开结果集。\n如果不你信，可以看下面代码：\n```java\n        ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Greetings\");\n        ResultSet resultSet2 = statement.executeQuery(\"SELECT * FROM Greetings\");\n        if (resultSet2.next()){\n            System.out.println(resultSet2.getString(1));\n        }\n        if (resultSet.next()){\n            System.out.println(resultSet.getString(1));\n        }\n```\n结果是：\n```bash\nHello World!sdfsdf\nException in thread \"main\" java.sql.SQLException: Operation not allowed after ResultSet closed\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926)\n\tat com.mysql.jdbc.ResultSetImpl.checkClosed(ResultSetImpl.java:768)\n\tat com.mysql.jdbc.ResultSetImpl.next(ResultSetImpl.java:7008)\n\tat jdbc.MySQLTest.runTest(MySQLTest.java:31)\n\tat jdbc.MySQLTest.main(MySQLTest.java:17)\n\nProcess finished with exit code 1\n```\n也就是说，同一个`Statement`对象会以最后一个打开的`ResultSet`有效，之前打开的都已经关闭了。\n\n**使用完ResultSet、Statement或Connection对象后，应立即调用close方法。这些对象都是用了规模较大的数据结构和数据库存服务器上的有限资源**\n如果Statement对象上有一个打开的结果集，那么调用`statement.close()`方法将自动关闭该结果集。同样的调用Connection类的close方法将关闭该连接上的所有语句。\n下面是完整的代码：\n```java\npackage jdbc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * author: jifang\n * date: 18-3-29 上午9:42\n */\n\npublic class MySQLTest {\n    public static void main(String[] args) throws SQLException {\n        runTest();\n    }\n\n    public static void runTest() throws SQLException {\n        Connection connection = getConnection();\n        Statement statement = connection.createStatement();\n        statement.executeUpdate(\"CREATE TABLE Greetings (Message CHAR(20))\");\n        statement.executeUpdate(\"INSERT INTO Greetings VALUES ('Hello World!sdfsdf')\");\n\n        ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Greetings\");\n        if (resultSet.next()){\n            System.out.println(resultSet.getString(1));\n        }\n\n        statement.executeUpdate(\"DROP TABLE Greetings\");\n    }\n\n    public static Connection getConnection() throws SQLException {\n        Properties properties = new Properties();\n        try {\n            InputStream inputStream = Files.newInputStream(Paths.get(\"src/main/java/jdbc/\", \"database.properties\"));\n            properties.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String drivers = properties.getProperty(\"jdbc.drivers\");\n        if (drivers!=null)System.setProperty(\"jdbc.drivers\",drivers);\n        String url = properties.getProperty(\"jdbc.url\");\n        String username = properties.getProperty(\"jdbc.username\");\n        String password = properties.getProperty(\"jdbc.password\");\n\n        return DriverManager.getConnection(url,username,password);\n    }\n}\n```\n【data.properties】\n```xml\njdbc.drivers=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/jifang\njdbc.username=root\njdbc.password=xjj520520ljf\n```\n\n我们已经了解了怎么使用`Statement`执行sql语句。现在来看看它的大哥。\n\n**PreparedStatement（预备语句）**\n在预备查询语句中，每个宿主变量都用“？”来表示。如果存在一个以上的变量，那么在设置变量值时必须注意“？”的位置。例如我们要查询的SQL为：\n`SELECT * FROM jifang where id = ?`\n在执行预备语句之前，必须使用set方法将变量绑定到实际的值上。\n`preparedStat.setInt(1, 233)`\n第一个参数指的是需要设置的宿主变量的位置，位置1表示第一个“？”。第二个参数是赋予宿主变量的值。\n\n如果想要重用已经执行过的预备查询语句，那么除非使用set方法或调用`clearParameters`方法，否则所有宿主变量的绑定都不会改变。\n一旦为所有变量绑定了具体的值，就可以执行查询操作了。\n\n**注意：**如果查询中涉及用户输入，那就还需要警惕**注入攻击**。因此，只有查询涉及变量时，才应该使用预备语句。\n\n### 后续\n除了以上介绍的内容，还有：\n1. 读写LOB\n2. 获取自动生成键\n3. 可滚动和可更新结果集\n4. 元数据\n等内容，有兴趣可以查阅《Java核心编程卷二》\n\n\n\n\n\n> 参考文献\n> [1] 《Java核心技术卷二》 \n> [2] [几种常见的数据库连接的URL写法](https://blog.csdn.net/u014726937/article/details/52786502)\n> [3] [Mysql JDBC Url参数说明](http://elf8848.iteye.com/blog/1684414)\n\n\n\n","source":"_posts/JDBC.md","raw":"---\ntoc: true\ntitle: JDBC\ndate: 2018-03-29 15:36:01\ntags: [JDBC,事务]\n---\n\n\n## 1. 什么是JDBC？\n\n1996年，Sun公司发布了第一版的Java数据库连接（JDBC）API，使编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找与更新。JDBC自此称为Java类库中最常用的API之一。\n<!--more-->\n概念：\n- SQL：结构化查询语言，是一种特定的目的程序语言，用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。\n- MySQL：原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。\n- JDBC：Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is Java based data access technology and used for Java database connectivity. It is part of the Java Standard Edition platform, from Oracle Corporation. It provides methods to query and update data in a database, and is oriented towards relational databases. A JDBC-to-ODBC bridge enables connections to any ODBC-accessible data source in the Java virtual machine (JVM) host environment.\n\n## 2. JDBC配置\n你需要有一个可获得其JDBC驱动程序的数据库软件。目前这方面有很多出色的软件可供选择，比如IBM DB2、Microsoft SQL Server、MySQL、Oracle和PostgreSQL。在这一节，我会以MySQL为例演示，在下一篇博客，我会介绍H2缓存数据库。\n\n现在，假设你已经安装好了MySQL，有一个名称为`jifang`的`database`，并且有权限对这个数据库增删改查。\n\n### 2.1 数据库URL\n在连接数据库时，我们必须使用各种与数据库类型相关的参数，例如主机名、端口号和数据库名。\n\nJDBC URL一般格式：\n`jdbc:subprotocol:other stuff`\n其中，`subprotocol`（子协议名）用于选择连接到数据库的具体驱动程序。`other stuff`（数据源名）参数的格式随所使用的`subprotocol`不同而不同。如果要了解具体格式，你需要查阅数据库供应商的相关文档。\n\n#### 几种常见的数据库连接\n\n**1. Oracle **\n驱动：`oracle.jdbc.driver.OracleDriver` \nURL：`jdbc:oracle:thin:@host:port:dbname`\nhost：数据库所在的机器的地址； \nport：端口号，默认是1521\n\n**2. MySQL**\n驱动：`com.mysql.jdbc.Driver `\nURL：`jdbc:mysql://host:port/dbname `\nhost：数据库所在的机器的名称； \nport：端口号，默认3306\n\n**3. SQL Server**\n驱动：`com.microsoft.jdbc.sqlserver.SQLServerDriver` \nURL：`jdbc:microsoft:sqlserver://<host><:port>;DatabaseName=<dbname> `\nhost：数据库所在的机器的名称； \nport：端口号，默认是1433\n\n**4. DB2**\n驱动：`com.ibm.db2.jdbc.app.DB2Driver `\nURL：`jdbc:db2://<host><:port>/dbname` \nhost：数据库所在的机器的名称； \nport：端口号，默认是5000\n\n#### MySQL URL格式详解\n\n这里我们主要参考MySQL的URL格式\n`jdbc:mysql://[host][,failoverhost...][:port]/[database][?propertyName1][=propertyValue1][&propertyName2][=propertyValue2]...`\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/7df5d637-a933-43e8-98a6-e539d3b08fba/1522287325072.png)\n\n### 2.2 驱动程序\n你需要获得包含了你所使用的数据库的驱动程序的JAR文件。\n获取方法：\n1. 去官网[https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)载JDBC Driver\n解压之后获取`mysql-connector-java-5.1.46-bin.jar`这个jar包\n2. 使用Maven仓库下载 \n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.6</version>\n</dependency>\n```\n如果使用第二种方式，直接就会放在项目的`classpath`下。如果是第一种，下载好了之后如何安装呢? 把下载 的文件解压后的 `mysql-connector-java-5.1.46-bin.jar`文件 copy到 %JAVA_HOME%/jre/lib/ext 下， %JAVA_HOME就是jdk的安装目录。\n### 2.3 注册驱动器类\n某些JDBC的JAR文件将自动注册驱动器类，在这种情况下，可以跳过这一部分所描述的手动注册步骤。\n\n如果驱动程序JAR文件不支持自动注册，那就需要找出数据库提供商使用的JDBC驱动器类的名字。例如MySQL：\n`com.mysql.jdbc.Driver`\n\n通过使用`DriverManager`，可以使用两种方式来注册驱动器。一种方式是在Java程序中加载加载驱动器类，例如：\n`Class.forName(\"com.mysql.jdbc.Driver\");`\n这条语句将使得驱动器类被加载，由此将执行可以注册驱动器的静态初始化器。\n\n另一种方式是设置jdbc.drivers属性。可以用命令行参数来指定这个属性，例如：\n`java -Djdbc.drivers=com.mysql.jdbc.Driver ProgramName`\n或者在应用中用下面这样的调用来设置系统属性：\n`System.setProperty(\"jdbc.Driver\", \"com.mysql.jdbc.Driver\");`\n\n### 2.4 连接到数据库\n在Java程序中，我们可以在代码中打开一个数据库连接，例如：\n```java\nString url = properties.getProperty(\"jdbc.url\");\nString username = properties.getProperty(\"jdbc.username\");\nString password = properties.getProperty(\"jdbc.password\");\nConnection conn = DriverManager.getConnection(url,username,password);\n```\n驱动管理器遍历所有注册过的驱动程序，以便找到一个能够使用数据库URL中指定的子协议的驱动程序。\n\n### 2.5 执行SQL语句\n\n1. 执行SQL命令之前，首先需要创建一个`Statement`对象，\n`Statement stat = conn.createStatement();`\n2. SQL语句字符串\n`String sql = \"CREATE TABLE Greetings (Message CHAR(20))\"`\n3. 然后调用Statement接口中的`executeUpdate`方法\n`stat.executeUpdate(sql)`\n对于`INSERT DELETE UPDATE`等都使用`executeUpdate`方法，它返回受SQL命令影响的行数。对于`SELECT`使用`executeQuery`方法，它返回一个`ResultSet`类型的对象，可以通过它来每一行地迭代遍历所有查询结果。\n\n**注意：**`ResultSet`接口的迭代协议与java.util.Iterator接口稍有不同。对于`ResultSet`接口，迭代器初始化时被设定在第一行之前的位置，必须调用`next()`方法把它移动到第一行。另外，它没有`hasNext()`方法，我们需要不断地调用`next()`，知道它返回`false`。\n\n`ResultSet`中行的顺序是人任意的，除非你在`sql`使用了`ORDER BY`子句指定排序。\n\n#### **管理连接、语句和结果集** \n每个`Connection`对象都可以创建一个或多个`Statement`对象。同一个`Statement`对象可以用于多个不想干的命令和查阅。但是一个`Statement`对象最多只能有一个打开结果集。\n如果不你信，可以看下面代码：\n```java\n        ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Greetings\");\n        ResultSet resultSet2 = statement.executeQuery(\"SELECT * FROM Greetings\");\n        if (resultSet2.next()){\n            System.out.println(resultSet2.getString(1));\n        }\n        if (resultSet.next()){\n            System.out.println(resultSet.getString(1));\n        }\n```\n结果是：\n```bash\nHello World!sdfsdf\nException in thread \"main\" java.sql.SQLException: Operation not allowed after ResultSet closed\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926)\n\tat com.mysql.jdbc.ResultSetImpl.checkClosed(ResultSetImpl.java:768)\n\tat com.mysql.jdbc.ResultSetImpl.next(ResultSetImpl.java:7008)\n\tat jdbc.MySQLTest.runTest(MySQLTest.java:31)\n\tat jdbc.MySQLTest.main(MySQLTest.java:17)\n\nProcess finished with exit code 1\n```\n也就是说，同一个`Statement`对象会以最后一个打开的`ResultSet`有效，之前打开的都已经关闭了。\n\n**使用完ResultSet、Statement或Connection对象后，应立即调用close方法。这些对象都是用了规模较大的数据结构和数据库存服务器上的有限资源**\n如果Statement对象上有一个打开的结果集，那么调用`statement.close()`方法将自动关闭该结果集。同样的调用Connection类的close方法将关闭该连接上的所有语句。\n下面是完整的代码：\n```java\npackage jdbc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * author: jifang\n * date: 18-3-29 上午9:42\n */\n\npublic class MySQLTest {\n    public static void main(String[] args) throws SQLException {\n        runTest();\n    }\n\n    public static void runTest() throws SQLException {\n        Connection connection = getConnection();\n        Statement statement = connection.createStatement();\n        statement.executeUpdate(\"CREATE TABLE Greetings (Message CHAR(20))\");\n        statement.executeUpdate(\"INSERT INTO Greetings VALUES ('Hello World!sdfsdf')\");\n\n        ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Greetings\");\n        if (resultSet.next()){\n            System.out.println(resultSet.getString(1));\n        }\n\n        statement.executeUpdate(\"DROP TABLE Greetings\");\n    }\n\n    public static Connection getConnection() throws SQLException {\n        Properties properties = new Properties();\n        try {\n            InputStream inputStream = Files.newInputStream(Paths.get(\"src/main/java/jdbc/\", \"database.properties\"));\n            properties.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String drivers = properties.getProperty(\"jdbc.drivers\");\n        if (drivers!=null)System.setProperty(\"jdbc.drivers\",drivers);\n        String url = properties.getProperty(\"jdbc.url\");\n        String username = properties.getProperty(\"jdbc.username\");\n        String password = properties.getProperty(\"jdbc.password\");\n\n        return DriverManager.getConnection(url,username,password);\n    }\n}\n```\n【data.properties】\n```xml\njdbc.drivers=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/jifang\njdbc.username=root\njdbc.password=xjj520520ljf\n```\n\n我们已经了解了怎么使用`Statement`执行sql语句。现在来看看它的大哥。\n\n**PreparedStatement（预备语句）**\n在预备查询语句中，每个宿主变量都用“？”来表示。如果存在一个以上的变量，那么在设置变量值时必须注意“？”的位置。例如我们要查询的SQL为：\n`SELECT * FROM jifang where id = ?`\n在执行预备语句之前，必须使用set方法将变量绑定到实际的值上。\n`preparedStat.setInt(1, 233)`\n第一个参数指的是需要设置的宿主变量的位置，位置1表示第一个“？”。第二个参数是赋予宿主变量的值。\n\n如果想要重用已经执行过的预备查询语句，那么除非使用set方法或调用`clearParameters`方法，否则所有宿主变量的绑定都不会改变。\n一旦为所有变量绑定了具体的值，就可以执行查询操作了。\n\n**注意：**如果查询中涉及用户输入，那就还需要警惕**注入攻击**。因此，只有查询涉及变量时，才应该使用预备语句。\n\n### 后续\n除了以上介绍的内容，还有：\n1. 读写LOB\n2. 获取自动生成键\n3. 可滚动和可更新结果集\n4. 元数据\n等内容，有兴趣可以查阅《Java核心编程卷二》\n\n\n\n\n\n> 参考文献\n> [1] 《Java核心技术卷二》 \n> [2] [几种常见的数据库连接的URL写法](https://blog.csdn.net/u014726937/article/details/52786502)\n> [3] [Mysql JDBC Url参数说明](http://elf8848.iteye.com/blog/1684414)\n\n\n\n","slug":"JDBC","published":1,"updated":"2018-08-13T14:28:27.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5f002f6k15g6ydtl3o","content":"<h2 id=\"1-什么是JDBC？\"><a href=\"#1-什么是JDBC？\" class=\"headerlink\" title=\"1. 什么是JDBC？\"></a>1. 什么是JDBC？</h2><p>1996年，Sun公司发布了第一版的Java数据库连接（JDBC）API，使编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找与更新。JDBC自此称为Java类库中最常用的API之一。<br><a id=\"more\"></a><br>概念：</p>\n<ul>\n<li>SQL：结构化查询语言，是一种特定的目的程序语言，用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。</li>\n<li>MySQL：原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。</li>\n<li>JDBC：Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is Java based data access technology and used for Java database connectivity. It is part of the Java Standard Edition platform, from Oracle Corporation. It provides methods to query and update data in a database, and is oriented towards relational databases. A JDBC-to-ODBC bridge enables connections to any ODBC-accessible data source in the Java virtual machine (JVM) host environment.</li>\n</ul>\n<h2 id=\"2-JDBC配置\"><a href=\"#2-JDBC配置\" class=\"headerlink\" title=\"2. JDBC配置\"></a>2. JDBC配置</h2><p>你需要有一个可获得其JDBC驱动程序的数据库软件。目前这方面有很多出色的软件可供选择，比如IBM DB2、Microsoft SQL Server、MySQL、Oracle和PostgreSQL。在这一节，我会以MySQL为例演示，在下一篇博客，我会介绍H2缓存数据库。</p>\n<p>现在，假设你已经安装好了MySQL，有一个名称为<code>jifang</code>的<code>database</code>，并且有权限对这个数据库增删改查。</p>\n<h3 id=\"2-1-数据库URL\"><a href=\"#2-1-数据库URL\" class=\"headerlink\" title=\"2.1 数据库URL\"></a>2.1 数据库URL</h3><p>在连接数据库时，我们必须使用各种与数据库类型相关的参数，例如主机名、端口号和数据库名。</p>\n<p>JDBC URL一般格式：<br><code>jdbc:subprotocol:other stuff</code><br>其中，<code>subprotocol</code>（子协议名）用于选择连接到数据库的具体驱动程序。<code>other stuff</code>（数据源名）参数的格式随所使用的<code>subprotocol</code>不同而不同。如果要了解具体格式，你需要查阅数据库供应商的相关文档。</p>\n<h4 id=\"几种常见的数据库连接\"><a href=\"#几种常见的数据库连接\" class=\"headerlink\" title=\"几种常见的数据库连接\"></a>几种常见的数据库连接</h4><p><strong>1. Oracle </strong><br>驱动：<code>oracle.jdbc.driver.OracleDriver</code><br>URL：<code>jdbc:oracle:thin:@host:port:dbname</code><br>host：数据库所在的机器的地址；<br>port：端口号，默认是1521</p>\n<p><strong>2. MySQL</strong><br>驱动：<code>com.mysql.jdbc.Driver</code><br>URL：<code>jdbc:mysql://host:port/dbname</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认3306</p>\n<p><strong>3. SQL Server</strong><br>驱动：<code>com.microsoft.jdbc.sqlserver.SQLServerDriver</code><br>URL：<code>jdbc:microsoft:sqlserver://&lt;host&gt;&lt;:port&gt;;DatabaseName=&lt;dbname&gt;</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认是1433</p>\n<p><strong>4. DB2</strong><br>驱动：<code>com.ibm.db2.jdbc.app.DB2Driver</code><br>URL：<code>jdbc:db2://&lt;host&gt;&lt;:port&gt;/dbname</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认是5000</p>\n<h4 id=\"MySQL-URL格式详解\"><a href=\"#MySQL-URL格式详解\" class=\"headerlink\" title=\"MySQL URL格式详解\"></a>MySQL URL格式详解</h4><p>这里我们主要参考MySQL的URL格式<br><code>jdbc:mysql://[host][,failoverhost...][:port]/[database][?propertyName1][=propertyValue1][&amp;propertyName2][=propertyValue2]...</code></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/7df5d637-a933-43e8-98a6-e539d3b08fba/1522287325072.png\" alt=\"Alt text\"></p>\n<h3 id=\"2-2-驱动程序\"><a href=\"#2-2-驱动程序\" class=\"headerlink\" title=\"2.2 驱动程序\"></a>2.2 驱动程序</h3><p>你需要获得包含了你所使用的数据库的驱动程序的JAR文件。<br>获取方法：</p>\n<ol>\n<li>去官网<a href=\"https://dev.mysql.com/downloads/connector/j/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/connector/j/</a>载JDBC Driver<br>解压之后获取<code>mysql-connector-java-5.1.46-bin.jar</code>这个jar包</li>\n<li>使用Maven仓库下载 <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果使用第二种方式，直接就会放在项目的<code>classpath</code>下。如果是第一种，下载好了之后如何安装呢? 把下载 的文件解压后的 <code>mysql-connector-java-5.1.46-bin.jar</code>文件 copy到 %JAVA_HOME%/jre/lib/ext 下， %JAVA_HOME就是jdk的安装目录。</p>\n<h3 id=\"2-3-注册驱动器类\"><a href=\"#2-3-注册驱动器类\" class=\"headerlink\" title=\"2.3 注册驱动器类\"></a>2.3 注册驱动器类</h3><p>某些JDBC的JAR文件将自动注册驱动器类，在这种情况下，可以跳过这一部分所描述的手动注册步骤。</p>\n<p>如果驱动程序JAR文件不支持自动注册，那就需要找出数据库提供商使用的JDBC驱动器类的名字。例如MySQL：<br><code>com.mysql.jdbc.Driver</code></p>\n<p>通过使用<code>DriverManager</code>，可以使用两种方式来注册驱动器。一种方式是在Java程序中加载加载驱动器类，例如：<br><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br>这条语句将使得驱动器类被加载，由此将执行可以注册驱动器的静态初始化器。</p>\n<p>另一种方式是设置jdbc.drivers属性。可以用命令行参数来指定这个属性，例如：<br><code>java -Djdbc.drivers=com.mysql.jdbc.Driver ProgramName</code><br>或者在应用中用下面这样的调用来设置系统属性：<br><code>System.setProperty(&quot;jdbc.Driver&quot;, &quot;com.mysql.jdbc.Driver&quot;);</code></p>\n<h3 id=\"2-4-连接到数据库\"><a href=\"#2-4-连接到数据库\" class=\"headerlink\" title=\"2.4 连接到数据库\"></a>2.4 连接到数据库</h3><p>在Java程序中，我们可以在代码中打开一个数据库连接，例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = properties.getProperty(<span class=\"string\">\"jdbc.url\"</span>);</span><br><span class=\"line\">String username = properties.getProperty(<span class=\"string\">\"jdbc.username\"</span>);</span><br><span class=\"line\">String password = properties.getProperty(<span class=\"string\">\"jdbc.password\"</span>);</span><br><span class=\"line\">Connection conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure></p>\n<p>驱动管理器遍历所有注册过的驱动程序，以便找到一个能够使用数据库URL中指定的子协议的驱动程序。</p>\n<h3 id=\"2-5-执行SQL语句\"><a href=\"#2-5-执行SQL语句\" class=\"headerlink\" title=\"2.5 执行SQL语句\"></a>2.5 执行SQL语句</h3><ol>\n<li>执行SQL命令之前，首先需要创建一个<code>Statement</code>对象，<br><code>Statement stat = conn.createStatement();</code></li>\n<li>SQL语句字符串<br><code>String sql = &quot;CREATE TABLE Greetings (Message CHAR(20))&quot;</code></li>\n<li>然后调用Statement接口中的<code>executeUpdate</code>方法<br><code>stat.executeUpdate(sql)</code><br>对于<code>INSERT DELETE UPDATE</code>等都使用<code>executeUpdate</code>方法，它返回受SQL命令影响的行数。对于<code>SELECT</code>使用<code>executeQuery</code>方法，它返回一个<code>ResultSet</code>类型的对象，可以通过它来每一行地迭代遍历所有查询结果。</li>\n</ol>\n<p><strong>注意：</strong><code>ResultSet</code>接口的迭代协议与java.util.Iterator接口稍有不同。对于<code>ResultSet</code>接口，迭代器初始化时被设定在第一行之前的位置，必须调用<code>next()</code>方法把它移动到第一行。另外，它没有<code>hasNext()</code>方法，我们需要不断地调用<code>next()</code>，知道它返回<code>false</code>。</p>\n<p><code>ResultSet</code>中行的顺序是人任意的，除非你在<code>sql</code>使用了<code>ORDER BY</code>子句指定排序。</p>\n<h4 id=\"管理连接、语句和结果集\"><a href=\"#管理连接、语句和结果集\" class=\"headerlink\" title=\"管理连接、语句和结果集\"></a><strong>管理连接、语句和结果集</strong></h4><p>每个<code>Connection</code>对象都可以创建一个或多个<code>Statement</code>对象。同一个<code>Statement</code>对象可以用于多个不想干的命令和查阅。但是一个<code>Statement</code>对象最多只能有一个打开结果集。<br>如果不你信，可以看下面代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSet resultSet = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\">ResultSet resultSet2 = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (resultSet2.next())&#123;</span><br><span class=\"line\">    System.out.println(resultSet2.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (resultSet.next())&#123;</span><br><span class=\"line\">    System.out.println(resultSet.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World!sdfsdf</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"main\"</span> java.sql.SQLException: Operation not allowed after ResultSet closed</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926)</span><br><span class=\"line\">\tat com.mysql.jdbc.ResultSetImpl.checkClosed(ResultSetImpl.java:768)</span><br><span class=\"line\">\tat com.mysql.jdbc.ResultSetImpl.next(ResultSetImpl.java:7008)</span><br><span class=\"line\">\tat jdbc.MySQLTest.runTest(MySQLTest.java:31)</span><br><span class=\"line\">\tat jdbc.MySQLTest.main(MySQLTest.java:17)</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 1</span><br></pre></td></tr></table></figure></p>\n<p>也就是说，同一个<code>Statement</code>对象会以最后一个打开的<code>ResultSet</code>有效，之前打开的都已经关闭了。</p>\n<p><strong>使用完ResultSet、Statement或Connection对象后，应立即调用close方法。这些对象都是用了规模较大的数据结构和数据库存服务器上的有限资源</strong><br>如果Statement对象上有一个打开的结果集，那么调用<code>statement.close()</code>方法将自动关闭该结果集。同样的调用Connection类的close方法将关闭该连接上的所有语句。<br>下面是完整的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> jdbc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Files;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Paths;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-29 上午9:42</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        runTest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        Connection connection = getConnection();</span><br><span class=\"line\">        Statement statement = connection.createStatement();</span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"CREATE TABLE Greetings (Message CHAR(20))\"</span>);</span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"INSERT INTO Greetings VALUES ('Hello World!sdfsdf')\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ResultSet resultSet = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultSet.next())&#123;</span><br><span class=\"line\">            System.out.println(resultSet.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"DROP TABLE Greetings\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            InputStream inputStream = Files.newInputStream(Paths.get(<span class=\"string\">\"src/main/java/jdbc/\"</span>, <span class=\"string\">\"database.properties\"</span>));</span><br><span class=\"line\">            properties.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String drivers = properties.getProperty(<span class=\"string\">\"jdbc.drivers\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (drivers!=<span class=\"keyword\">null</span>)System.setProperty(<span class=\"string\">\"jdbc.drivers\"</span>,drivers);</span><br><span class=\"line\">        String url = properties.getProperty(<span class=\"string\">\"jdbc.url\"</span>);</span><br><span class=\"line\">        String username = properties.getProperty(<span class=\"string\">\"jdbc.username\"</span>);</span><br><span class=\"line\">        String password = properties.getProperty(<span class=\"string\">\"jdbc.password\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> DriverManager.getConnection(url,username,password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【data.properties】<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.drivers=com.mysql.jdbc.Driver</span><br><span class=\"line\">jdbc.url=jdbc:mysql://localhost:3306/jifang</span><br><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">jdbc.password=xjj520520ljf</span><br></pre></td></tr></table></figure></p>\n<p>我们已经了解了怎么使用<code>Statement</code>执行sql语句。现在来看看它的大哥。</p>\n<p><strong>PreparedStatement（预备语句）</strong><br>在预备查询语句中，每个宿主变量都用“？”来表示。如果存在一个以上的变量，那么在设置变量值时必须注意“？”的位置。例如我们要查询的SQL为：<br><code>SELECT * FROM jifang where id = ?</code><br>在执行预备语句之前，必须使用set方法将变量绑定到实际的值上。<br><code>preparedStat.setInt(1, 233)</code><br>第一个参数指的是需要设置的宿主变量的位置，位置1表示第一个“？”。第二个参数是赋予宿主变量的值。</p>\n<p>如果想要重用已经执行过的预备查询语句，那么除非使用set方法或调用<code>clearParameters</code>方法，否则所有宿主变量的绑定都不会改变。<br>一旦为所有变量绑定了具体的值，就可以执行查询操作了。</p>\n<p><strong>注意：</strong>如果查询中涉及用户输入，那就还需要警惕<strong>注入攻击</strong>。因此，只有查询涉及变量时，才应该使用预备语句。</p>\n<h3 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h3><p>除了以上介绍的内容，还有：</p>\n<ol>\n<li>读写LOB</li>\n<li>获取自动生成键</li>\n<li>可滚动和可更新结果集</li>\n<li>元数据<br>等内容，有兴趣可以查阅《Java核心编程卷二》</li>\n</ol>\n<blockquote>\n<p>参考文献<br>[1] 《Java核心技术卷二》<br>[2] <a href=\"https://blog.csdn.net/u014726937/article/details/52786502\" target=\"_blank\" rel=\"noopener\">几种常见的数据库连接的URL写法</a><br>[3] <a href=\"http://elf8848.iteye.com/blog/1684414\" target=\"_blank\" rel=\"noopener\">Mysql JDBC Url参数说明</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-什么是JDBC？\"><a href=\"#1-什么是JDBC？\" class=\"headerlink\" title=\"1. 什么是JDBC？\"></a>1. 什么是JDBC？</h2><p>1996年，Sun公司发布了第一版的Java数据库连接（JDBC）API，使编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找与更新。JDBC自此称为Java类库中最常用的API之一。<br>","more":"<br>概念：</p>\n<ul>\n<li>SQL：结构化查询语言，是一种特定的目的程序语言，用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。</li>\n<li>MySQL：原本是一个开放源代码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统（Sun Microsystems）收购。2009年，甲骨文公司（Oracle）收购昇阳微系统公司，MySQL成为Oracle旗下产品。</li>\n<li>JDBC：Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is Java based data access technology and used for Java database connectivity. It is part of the Java Standard Edition platform, from Oracle Corporation. It provides methods to query and update data in a database, and is oriented towards relational databases. A JDBC-to-ODBC bridge enables connections to any ODBC-accessible data source in the Java virtual machine (JVM) host environment.</li>\n</ul>\n<h2 id=\"2-JDBC配置\"><a href=\"#2-JDBC配置\" class=\"headerlink\" title=\"2. JDBC配置\"></a>2. JDBC配置</h2><p>你需要有一个可获得其JDBC驱动程序的数据库软件。目前这方面有很多出色的软件可供选择，比如IBM DB2、Microsoft SQL Server、MySQL、Oracle和PostgreSQL。在这一节，我会以MySQL为例演示，在下一篇博客，我会介绍H2缓存数据库。</p>\n<p>现在，假设你已经安装好了MySQL，有一个名称为<code>jifang</code>的<code>database</code>，并且有权限对这个数据库增删改查。</p>\n<h3 id=\"2-1-数据库URL\"><a href=\"#2-1-数据库URL\" class=\"headerlink\" title=\"2.1 数据库URL\"></a>2.1 数据库URL</h3><p>在连接数据库时，我们必须使用各种与数据库类型相关的参数，例如主机名、端口号和数据库名。</p>\n<p>JDBC URL一般格式：<br><code>jdbc:subprotocol:other stuff</code><br>其中，<code>subprotocol</code>（子协议名）用于选择连接到数据库的具体驱动程序。<code>other stuff</code>（数据源名）参数的格式随所使用的<code>subprotocol</code>不同而不同。如果要了解具体格式，你需要查阅数据库供应商的相关文档。</p>\n<h4 id=\"几种常见的数据库连接\"><a href=\"#几种常见的数据库连接\" class=\"headerlink\" title=\"几种常见的数据库连接\"></a>几种常见的数据库连接</h4><p><strong>1. Oracle </strong><br>驱动：<code>oracle.jdbc.driver.OracleDriver</code><br>URL：<code>jdbc:oracle:thin:@host:port:dbname</code><br>host：数据库所在的机器的地址；<br>port：端口号，默认是1521</p>\n<p><strong>2. MySQL</strong><br>驱动：<code>com.mysql.jdbc.Driver</code><br>URL：<code>jdbc:mysql://host:port/dbname</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认3306</p>\n<p><strong>3. SQL Server</strong><br>驱动：<code>com.microsoft.jdbc.sqlserver.SQLServerDriver</code><br>URL：<code>jdbc:microsoft:sqlserver://&lt;host&gt;&lt;:port&gt;;DatabaseName=&lt;dbname&gt;</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认是1433</p>\n<p><strong>4. DB2</strong><br>驱动：<code>com.ibm.db2.jdbc.app.DB2Driver</code><br>URL：<code>jdbc:db2://&lt;host&gt;&lt;:port&gt;/dbname</code><br>host：数据库所在的机器的名称；<br>port：端口号，默认是5000</p>\n<h4 id=\"MySQL-URL格式详解\"><a href=\"#MySQL-URL格式详解\" class=\"headerlink\" title=\"MySQL URL格式详解\"></a>MySQL URL格式详解</h4><p>这里我们主要参考MySQL的URL格式<br><code>jdbc:mysql://[host][,failoverhost...][:port]/[database][?propertyName1][=propertyValue1][&amp;propertyName2][=propertyValue2]...</code></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/7df5d637-a933-43e8-98a6-e539d3b08fba/1522287325072.png\" alt=\"Alt text\"></p>\n<h3 id=\"2-2-驱动程序\"><a href=\"#2-2-驱动程序\" class=\"headerlink\" title=\"2.2 驱动程序\"></a>2.2 驱动程序</h3><p>你需要获得包含了你所使用的数据库的驱动程序的JAR文件。<br>获取方法：</p>\n<ol>\n<li>去官网<a href=\"https://dev.mysql.com/downloads/connector/j/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/connector/j/</a>载JDBC Driver<br>解压之后获取<code>mysql-connector-java-5.1.46-bin.jar</code>这个jar包</li>\n<li>使用Maven仓库下载 <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果使用第二种方式，直接就会放在项目的<code>classpath</code>下。如果是第一种，下载好了之后如何安装呢? 把下载 的文件解压后的 <code>mysql-connector-java-5.1.46-bin.jar</code>文件 copy到 %JAVA_HOME%/jre/lib/ext 下， %JAVA_HOME就是jdk的安装目录。</p>\n<h3 id=\"2-3-注册驱动器类\"><a href=\"#2-3-注册驱动器类\" class=\"headerlink\" title=\"2.3 注册驱动器类\"></a>2.3 注册驱动器类</h3><p>某些JDBC的JAR文件将自动注册驱动器类，在这种情况下，可以跳过这一部分所描述的手动注册步骤。</p>\n<p>如果驱动程序JAR文件不支持自动注册，那就需要找出数据库提供商使用的JDBC驱动器类的名字。例如MySQL：<br><code>com.mysql.jdbc.Driver</code></p>\n<p>通过使用<code>DriverManager</code>，可以使用两种方式来注册驱动器。一种方式是在Java程序中加载加载驱动器类，例如：<br><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br>这条语句将使得驱动器类被加载，由此将执行可以注册驱动器的静态初始化器。</p>\n<p>另一种方式是设置jdbc.drivers属性。可以用命令行参数来指定这个属性，例如：<br><code>java -Djdbc.drivers=com.mysql.jdbc.Driver ProgramName</code><br>或者在应用中用下面这样的调用来设置系统属性：<br><code>System.setProperty(&quot;jdbc.Driver&quot;, &quot;com.mysql.jdbc.Driver&quot;);</code></p>\n<h3 id=\"2-4-连接到数据库\"><a href=\"#2-4-连接到数据库\" class=\"headerlink\" title=\"2.4 连接到数据库\"></a>2.4 连接到数据库</h3><p>在Java程序中，我们可以在代码中打开一个数据库连接，例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = properties.getProperty(<span class=\"string\">\"jdbc.url\"</span>);</span><br><span class=\"line\">String username = properties.getProperty(<span class=\"string\">\"jdbc.username\"</span>);</span><br><span class=\"line\">String password = properties.getProperty(<span class=\"string\">\"jdbc.password\"</span>);</span><br><span class=\"line\">Connection conn = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure></p>\n<p>驱动管理器遍历所有注册过的驱动程序，以便找到一个能够使用数据库URL中指定的子协议的驱动程序。</p>\n<h3 id=\"2-5-执行SQL语句\"><a href=\"#2-5-执行SQL语句\" class=\"headerlink\" title=\"2.5 执行SQL语句\"></a>2.5 执行SQL语句</h3><ol>\n<li>执行SQL命令之前，首先需要创建一个<code>Statement</code>对象，<br><code>Statement stat = conn.createStatement();</code></li>\n<li>SQL语句字符串<br><code>String sql = &quot;CREATE TABLE Greetings (Message CHAR(20))&quot;</code></li>\n<li>然后调用Statement接口中的<code>executeUpdate</code>方法<br><code>stat.executeUpdate(sql)</code><br>对于<code>INSERT DELETE UPDATE</code>等都使用<code>executeUpdate</code>方法，它返回受SQL命令影响的行数。对于<code>SELECT</code>使用<code>executeQuery</code>方法，它返回一个<code>ResultSet</code>类型的对象，可以通过它来每一行地迭代遍历所有查询结果。</li>\n</ol>\n<p><strong>注意：</strong><code>ResultSet</code>接口的迭代协议与java.util.Iterator接口稍有不同。对于<code>ResultSet</code>接口，迭代器初始化时被设定在第一行之前的位置，必须调用<code>next()</code>方法把它移动到第一行。另外，它没有<code>hasNext()</code>方法，我们需要不断地调用<code>next()</code>，知道它返回<code>false</code>。</p>\n<p><code>ResultSet</code>中行的顺序是人任意的，除非你在<code>sql</code>使用了<code>ORDER BY</code>子句指定排序。</p>\n<h4 id=\"管理连接、语句和结果集\"><a href=\"#管理连接、语句和结果集\" class=\"headerlink\" title=\"管理连接、语句和结果集\"></a><strong>管理连接、语句和结果集</strong></h4><p>每个<code>Connection</code>对象都可以创建一个或多个<code>Statement</code>对象。同一个<code>Statement</code>对象可以用于多个不想干的命令和查阅。但是一个<code>Statement</code>对象最多只能有一个打开结果集。<br>如果不你信，可以看下面代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSet resultSet = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\">ResultSet resultSet2 = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (resultSet2.next())&#123;</span><br><span class=\"line\">    System.out.println(resultSet2.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (resultSet.next())&#123;</span><br><span class=\"line\">    System.out.println(resultSet.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World!sdfsdf</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"main\"</span> java.sql.SQLException: Operation not allowed after ResultSet closed</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1055)</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:956)</span><br><span class=\"line\">\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:926)</span><br><span class=\"line\">\tat com.mysql.jdbc.ResultSetImpl.checkClosed(ResultSetImpl.java:768)</span><br><span class=\"line\">\tat com.mysql.jdbc.ResultSetImpl.next(ResultSetImpl.java:7008)</span><br><span class=\"line\">\tat jdbc.MySQLTest.runTest(MySQLTest.java:31)</span><br><span class=\"line\">\tat jdbc.MySQLTest.main(MySQLTest.java:17)</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with <span class=\"built_in\">exit</span> code 1</span><br></pre></td></tr></table></figure></p>\n<p>也就是说，同一个<code>Statement</code>对象会以最后一个打开的<code>ResultSet</code>有效，之前打开的都已经关闭了。</p>\n<p><strong>使用完ResultSet、Statement或Connection对象后，应立即调用close方法。这些对象都是用了规模较大的数据结构和数据库存服务器上的有限资源</strong><br>如果Statement对象上有一个打开的结果集，那么调用<code>statement.close()</code>方法将自动关闭该结果集。同样的调用Connection类的close方法将关闭该连接上的所有语句。<br>下面是完整的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> jdbc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Files;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Paths;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-29 上午9:42</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        runTest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        Connection connection = getConnection();</span><br><span class=\"line\">        Statement statement = connection.createStatement();</span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"CREATE TABLE Greetings (Message CHAR(20))\"</span>);</span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"INSERT INTO Greetings VALUES ('Hello World!sdfsdf')\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ResultSet resultSet = statement.executeQuery(<span class=\"string\">\"SELECT * FROM Greetings\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultSet.next())&#123;</span><br><span class=\"line\">            System.out.println(resultSet.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        statement.executeUpdate(<span class=\"string\">\"DROP TABLE Greetings\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            InputStream inputStream = Files.newInputStream(Paths.get(<span class=\"string\">\"src/main/java/jdbc/\"</span>, <span class=\"string\">\"database.properties\"</span>));</span><br><span class=\"line\">            properties.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String drivers = properties.getProperty(<span class=\"string\">\"jdbc.drivers\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (drivers!=<span class=\"keyword\">null</span>)System.setProperty(<span class=\"string\">\"jdbc.drivers\"</span>,drivers);</span><br><span class=\"line\">        String url = properties.getProperty(<span class=\"string\">\"jdbc.url\"</span>);</span><br><span class=\"line\">        String username = properties.getProperty(<span class=\"string\">\"jdbc.username\"</span>);</span><br><span class=\"line\">        String password = properties.getProperty(<span class=\"string\">\"jdbc.password\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> DriverManager.getConnection(url,username,password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【data.properties】<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.drivers=com.mysql.jdbc.Driver</span><br><span class=\"line\">jdbc.url=jdbc:mysql://localhost:3306/jifang</span><br><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">jdbc.password=xjj520520ljf</span><br></pre></td></tr></table></figure></p>\n<p>我们已经了解了怎么使用<code>Statement</code>执行sql语句。现在来看看它的大哥。</p>\n<p><strong>PreparedStatement（预备语句）</strong><br>在预备查询语句中，每个宿主变量都用“？”来表示。如果存在一个以上的变量，那么在设置变量值时必须注意“？”的位置。例如我们要查询的SQL为：<br><code>SELECT * FROM jifang where id = ?</code><br>在执行预备语句之前，必须使用set方法将变量绑定到实际的值上。<br><code>preparedStat.setInt(1, 233)</code><br>第一个参数指的是需要设置的宿主变量的位置，位置1表示第一个“？”。第二个参数是赋予宿主变量的值。</p>\n<p>如果想要重用已经执行过的预备查询语句，那么除非使用set方法或调用<code>clearParameters</code>方法，否则所有宿主变量的绑定都不会改变。<br>一旦为所有变量绑定了具体的值，就可以执行查询操作了。</p>\n<p><strong>注意：</strong>如果查询中涉及用户输入，那就还需要警惕<strong>注入攻击</strong>。因此，只有查询涉及变量时，才应该使用预备语句。</p>\n<h3 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h3><p>除了以上介绍的内容，还有：</p>\n<ol>\n<li>读写LOB</li>\n<li>获取自动生成键</li>\n<li>可滚动和可更新结果集</li>\n<li>元数据<br>等内容，有兴趣可以查阅《Java核心编程卷二》</li>\n</ol>\n<blockquote>\n<p>参考文献<br>[1] 《Java核心技术卷二》<br>[2] <a href=\"https://blog.csdn.net/u014726937/article/details/52786502\" target=\"_blank\" rel=\"noopener\">几种常见的数据库连接的URL写法</a><br>[3] <a href=\"http://elf8848.iteye.com/blog/1684414\" target=\"_blank\" rel=\"noopener\">Mysql JDBC Url参数说明</a></p>\n</blockquote>"},{"toc":true,"title":"Java注解","date":"2018-04-02T14:35:05.000Z","_content":"\n### 1. 概念\n**注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。**\n<!--more-->\n看完了概念你理解了吗？注解本身并不能影响代码的执行，它能带来的影响是其他tools或Java编译器产生的。在这里我们只需要知道**注解**就相当于一个**标签**。\n\n注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。\n\n### 2. 用法\n注解的使用范围很广泛，我现在只是初步了解了注解的用法。在这儿摘抄一段《Java核心技术卷二》原文：\n>下面是关于注解的一些可能的用法：\n>- 附属文件的自动生成，例如部署描述符或者bean信息类。\n>- 测试、日志、事务语义等代码的自动生成。\n\n### 3. 注解语法\n\n#### 注解定义\n注解是由接口来定义的：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationTest{\n\tint age() default 18;\n\tString name() default \"小明\";\n}\n```\n每个元素声明都具有下面这种形式：\n`type elementName();`\n或者\n`type elementName() default value`\n注解接口中的元素声明实际上是方法声明。一个注解接口的方法不能有任何参数和任何throws语句，并且它们也不能是泛型的。\n注解元素的类型可以是下列之一：\n- Java8种基本类型\n- String\n- Class（具有一个可选的类型参数，例如`Class<? extends MyClass>`）\n- enum 类型\n- 注解类型\n- 由上述类型组成的数组（由数组组成的数组不是合法的元素类型）\n\n既然一个注解元素可以是另一个注解，那么就可以创建出任意复杂的注解。例如：\n`@BugReport(ref=@Reference(id=\"123\"))`\n*注意：在注解中引入循环依赖是一种错误。*\n\n#### 注解使用\n在Java中，注解是当作一个`修饰符`来使用的，它被置于被注解项之前，中间没有分号。（修饰符就是诸如`public`和`static`之类的关键词）。除了方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个像`public`或者`static`这样的修饰符的地方。\n\n```java\n    @AnnotationTest(age = 20, name=\"小红\")\n    public String toString() {\n        return \"test\";\n    }\n```\n有两个特殊的快捷方式可以用来简化注解。\n如果没有指定元素，要么是因为注解中没有任何元素，要么是因为所有元素都是用默认值，那么你就不需要使用圆括号了。例如：\n`@AnnotationTest`\n和下面的注解是一样的\n`@AnnotationTest(age =18, name = \"小明\")`\n这样的注解又称为**标记注解**。\n另外一种快捷方式是**单值注解**。如果一个元素具有特殊的名字`value`，并且没有指定其他元素，那么你就可以忽略掉这个元素名以及等号。例如：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OneValue{\n\tString value();\n}\n```\n那么我们可以将这个注解写成：\n`@OneValue(\"一个\")`\n代替：\n`@OneValue(value = \"一个\")`\n\n一个项可以有多个注解，只要他们属于不同的类型即可。（在JDK1.8以前当注解一个特定项的时候，不能多次使用同一注解类型。但是在1.8之后新增`@Repeatable`注解，可以重复使用）例如\n```java\n@OneValue(\"一\")\n@Onevalue(\"二\")\npublic void test(){}\n```\n就是一种编译期错误。\n如果你一定要多次使用一个注解，那么设计一个注解，它的值是一个由更简单的注解组成的数组：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OneValues{\n\tOnevalue[] OneValues();\n}\n```\n```java\n@Onevalues({@Onevalue(\"一\"), @OneValue(\"二\")})\npublic void test(){}\n```\n\n### 4. 标准注解\nJava SE在java.lang、java.lang.annotation和javax.annotation包中定义了大量的注解接口。其中四个是**元注解**，用于描述注解接口的行为属性，还有一些其他的预置注解方便你注解你的源代码中的项。\n\n#### 元注解\n元注解是什么意思呢？\n\n元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。\n\n如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。\n\n元标签有 `@Retention、@Documented、@Target、@Inherited、@Repeatable` 5 种。\n\n##### @Retention\nRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。\n它的取值如下： \n- RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 \n- RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 \n- RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。\n\n##### @Documented\n顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。\n\n##### @Target\nTarget 是目标的意思，@Target 指定了注解运用的地方。\n\n你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。\n\n类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值\n- ElementType.ANNOTATION_TYPE 可以给一个注解进行注解\n- ElementType.CONSTRUCTOR 可以给构造方法进行注解\n- ElementType.FIELD 可以给属性进行注解\n- ElementType.LOCAL_VARIABLE 可以给局部变量进行注解\n- ElementType.METHOD 可以给方法进行注解\n- ElementType.PACKAGE 可以给一个包进行注解\n- ElementType.PARAMETER 可以给一个方法内的参数进行注解\n- ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举\n\n##### @Inherited\nInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 \n说的比较抽象。代码来解释。\n```java\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\n@interface Test {}\n\n@Test\npublic class A {}\n\npublic class B extends A {}\n```\n注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。\n\n可以这样理解：\n\n老子非常有钱，所以人们给他贴了一张标签叫做富豪。\n\n老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。\n\n老子的孙子长大了，自然也是富豪。\n\n这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。\n【示例】\n```java\nimport java.lang.annotation.*;\n\n@Documented\n@Target(ElementType.TYPE)\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodInfo {\n    public int age() default 20;\n    public String name() default \"小明\";\n}\n```\n```java\n@MethodInfo\npublic class AnnotationExample {\n}\n```\n```java\npublic class InheritedExample extends AnnotationExample {\n}\n```\n【Test.java】\n```java\npackage annotation;\n\n/**\n * author: jifang\n * date: 18-4-2 下午9:51\n */\n\npublic class Test {\n    public static void main(String[] args) {\n        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);\n        System.out.println(\"age: \" + info.age());\n        System.out.println(\"name: \" + info.name());\n    }\n}\n```\n运行`main`方法，得到结果：\n```\nage: 20\nname: 小明\n```\n\n##### @Repeatable\nRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。\n举一个例子你就懂了，可以看这个链接：https://blog.csdn.net/z69183787/article/details/54602994\n\n\n还有一些Java预置的注解如`@Deprecated、@Override、@SuppressWarnings、@SafeVarargs`等，有兴趣可以自行查阅。\n\n### 5. 注解的提取：反射\n\n注解通过反射获取。首先可以通过 Class 对象的 `isAnnotationPresent()` 方法判断它是否应用了某个注解。\n```java\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}\n```\n然后通过 getAnnotation() 方法来获取 Annotation 对象。\n```java\npublic <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}\n```\n或者是 getAnnotations() 方法。\n`public Annotation[] getAnnotations() {}`\n前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。\n\n如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如\n```java\nimport java.lang.annotation.*;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodInfo {\n    public int age() default 20;\n    public String name() default \"小明\";\n}\n```\n```\n@MethodInfo\npublic class AnnotationExample {\n}\n```\n```java\nimport java.lang.annotation.Annotation;\n\n/**\n * author: jifang\n * date: 18-4-2 下午9:51\n */\n\npublic class Test {\n    public static void main(String[] args) {\n        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);\n        System.out.println(\"age: \" + info.age());\n        System.out.println(\"name: \" + info.name());\n        Annotation[] annotations = AnnotationExample.class.getAnnotations();\n        System.out.println(annotations.length);\n    }\n}\n```\n结果：\n```bash\nage: 20\nname: 小明\n1\n```\n需要注意的是，如果一个注解要在运行时被成功提取，那么`@Retention(RetentionPolicy.RUNTIME) `是必须的。\n\n\n### 6. 源码级注解处理\n明天再研究一下补充。\n\n\n> 参考文献\n> [1] [秒懂，Java 注解 （Annotation）你可以这样学](https://blog.csdn.net/briblue/article/details/73824058)\n> [2] [java8 新增的@Repeatable注解](https://blog.csdn.net/z69183787/article/details/54602994)\n> [3] 《Java核心技术卷二》","source":"_posts/Java注解.md","raw":"---\ntoc: true\ntitle: Java注解\ndate: 2018-04-02 22:35:05\ntags: [注解]\n---\n\n### 1. 概念\n**注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。**\n<!--more-->\n看完了概念你理解了吗？注解本身并不能影响代码的执行，它能带来的影响是其他tools或Java编译器产生的。在这里我们只需要知道**注解**就相当于一个**标签**。\n\n注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。\n\n### 2. 用法\n注解的使用范围很广泛，我现在只是初步了解了注解的用法。在这儿摘抄一段《Java核心技术卷二》原文：\n>下面是关于注解的一些可能的用法：\n>- 附属文件的自动生成，例如部署描述符或者bean信息类。\n>- 测试、日志、事务语义等代码的自动生成。\n\n### 3. 注解语法\n\n#### 注解定义\n注解是由接口来定义的：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationTest{\n\tint age() default 18;\n\tString name() default \"小明\";\n}\n```\n每个元素声明都具有下面这种形式：\n`type elementName();`\n或者\n`type elementName() default value`\n注解接口中的元素声明实际上是方法声明。一个注解接口的方法不能有任何参数和任何throws语句，并且它们也不能是泛型的。\n注解元素的类型可以是下列之一：\n- Java8种基本类型\n- String\n- Class（具有一个可选的类型参数，例如`Class<? extends MyClass>`）\n- enum 类型\n- 注解类型\n- 由上述类型组成的数组（由数组组成的数组不是合法的元素类型）\n\n既然一个注解元素可以是另一个注解，那么就可以创建出任意复杂的注解。例如：\n`@BugReport(ref=@Reference(id=\"123\"))`\n*注意：在注解中引入循环依赖是一种错误。*\n\n#### 注解使用\n在Java中，注解是当作一个`修饰符`来使用的，它被置于被注解项之前，中间没有分号。（修饰符就是诸如`public`和`static`之类的关键词）。除了方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个像`public`或者`static`这样的修饰符的地方。\n\n```java\n    @AnnotationTest(age = 20, name=\"小红\")\n    public String toString() {\n        return \"test\";\n    }\n```\n有两个特殊的快捷方式可以用来简化注解。\n如果没有指定元素，要么是因为注解中没有任何元素，要么是因为所有元素都是用默认值，那么你就不需要使用圆括号了。例如：\n`@AnnotationTest`\n和下面的注解是一样的\n`@AnnotationTest(age =18, name = \"小明\")`\n这样的注解又称为**标记注解**。\n另外一种快捷方式是**单值注解**。如果一个元素具有特殊的名字`value`，并且没有指定其他元素，那么你就可以忽略掉这个元素名以及等号。例如：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OneValue{\n\tString value();\n}\n```\n那么我们可以将这个注解写成：\n`@OneValue(\"一个\")`\n代替：\n`@OneValue(value = \"一个\")`\n\n一个项可以有多个注解，只要他们属于不同的类型即可。（在JDK1.8以前当注解一个特定项的时候，不能多次使用同一注解类型。但是在1.8之后新增`@Repeatable`注解，可以重复使用）例如\n```java\n@OneValue(\"一\")\n@Onevalue(\"二\")\npublic void test(){}\n```\n就是一种编译期错误。\n如果你一定要多次使用一个注解，那么设计一个注解，它的值是一个由更简单的注解组成的数组：\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OneValues{\n\tOnevalue[] OneValues();\n}\n```\n```java\n@Onevalues({@Onevalue(\"一\"), @OneValue(\"二\")})\npublic void test(){}\n```\n\n### 4. 标准注解\nJava SE在java.lang、java.lang.annotation和javax.annotation包中定义了大量的注解接口。其中四个是**元注解**，用于描述注解接口的行为属性，还有一些其他的预置注解方便你注解你的源代码中的项。\n\n#### 元注解\n元注解是什么意思呢？\n\n元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。\n\n如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。\n\n元标签有 `@Retention、@Documented、@Target、@Inherited、@Repeatable` 5 种。\n\n##### @Retention\nRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。\n它的取值如下： \n- RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 \n- RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 \n- RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。\n\n##### @Documented\n顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。\n\n##### @Target\nTarget 是目标的意思，@Target 指定了注解运用的地方。\n\n你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。\n\n类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值\n- ElementType.ANNOTATION_TYPE 可以给一个注解进行注解\n- ElementType.CONSTRUCTOR 可以给构造方法进行注解\n- ElementType.FIELD 可以给属性进行注解\n- ElementType.LOCAL_VARIABLE 可以给局部变量进行注解\n- ElementType.METHOD 可以给方法进行注解\n- ElementType.PACKAGE 可以给一个包进行注解\n- ElementType.PARAMETER 可以给一个方法内的参数进行注解\n- ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举\n\n##### @Inherited\nInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 \n说的比较抽象。代码来解释。\n```java\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\n@interface Test {}\n\n@Test\npublic class A {}\n\npublic class B extends A {}\n```\n注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。\n\n可以这样理解：\n\n老子非常有钱，所以人们给他贴了一张标签叫做富豪。\n\n老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。\n\n老子的孙子长大了，自然也是富豪。\n\n这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。\n【示例】\n```java\nimport java.lang.annotation.*;\n\n@Documented\n@Target(ElementType.TYPE)\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodInfo {\n    public int age() default 20;\n    public String name() default \"小明\";\n}\n```\n```java\n@MethodInfo\npublic class AnnotationExample {\n}\n```\n```java\npublic class InheritedExample extends AnnotationExample {\n}\n```\n【Test.java】\n```java\npackage annotation;\n\n/**\n * author: jifang\n * date: 18-4-2 下午9:51\n */\n\npublic class Test {\n    public static void main(String[] args) {\n        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);\n        System.out.println(\"age: \" + info.age());\n        System.out.println(\"name: \" + info.name());\n    }\n}\n```\n运行`main`方法，得到结果：\n```\nage: 20\nname: 小明\n```\n\n##### @Repeatable\nRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。\n举一个例子你就懂了，可以看这个链接：https://blog.csdn.net/z69183787/article/details/54602994\n\n\n还有一些Java预置的注解如`@Deprecated、@Override、@SuppressWarnings、@SafeVarargs`等，有兴趣可以自行查阅。\n\n### 5. 注解的提取：反射\n\n注解通过反射获取。首先可以通过 Class 对象的 `isAnnotationPresent()` 方法判断它是否应用了某个注解。\n```java\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}\n```\n然后通过 getAnnotation() 方法来获取 Annotation 对象。\n```java\npublic <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}\n```\n或者是 getAnnotations() 方法。\n`public Annotation[] getAnnotations() {}`\n前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。\n\n如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如\n```java\nimport java.lang.annotation.*;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodInfo {\n    public int age() default 20;\n    public String name() default \"小明\";\n}\n```\n```\n@MethodInfo\npublic class AnnotationExample {\n}\n```\n```java\nimport java.lang.annotation.Annotation;\n\n/**\n * author: jifang\n * date: 18-4-2 下午9:51\n */\n\npublic class Test {\n    public static void main(String[] args) {\n        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);\n        System.out.println(\"age: \" + info.age());\n        System.out.println(\"name: \" + info.name());\n        Annotation[] annotations = AnnotationExample.class.getAnnotations();\n        System.out.println(annotations.length);\n    }\n}\n```\n结果：\n```bash\nage: 20\nname: 小明\n1\n```\n需要注意的是，如果一个注解要在运行时被成功提取，那么`@Retention(RetentionPolicy.RUNTIME) `是必须的。\n\n\n### 6. 源码级注解处理\n明天再研究一下补充。\n\n\n> 参考文献\n> [1] [秒懂，Java 注解 （Annotation）你可以这样学](https://blog.csdn.net/briblue/article/details/73824058)\n> [2] [java8 新增的@Repeatable注解](https://blog.csdn.net/z69183787/article/details/54602994)\n> [3] 《Java核心技术卷二》","slug":"Java注解","published":1,"updated":"2018-08-13T14:28:27.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5h002h6k15l5pjmrpi","content":"<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p><strong>注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。</strong><br><a id=\"more\"></a><br>看完了概念你理解了吗？注解本身并不能影响代码的执行，它能带来的影响是其他tools或Java编译器产生的。在这里我们只需要知道<strong>注解</strong>就相当于一个<strong>标签</strong>。</p>\n<p>注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><p>注解的使用范围很广泛，我现在只是初步了解了注解的用法。在这儿摘抄一段《Java核心技术卷二》原文：</p>\n<blockquote>\n<p>下面是关于注解的一些可能的用法：</p>\n<ul>\n<li>附属文件的自动生成，例如部署描述符或者bean信息类。</li>\n<li>测试、日志、事务语义等代码的自动生成。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-注解语法\"><a href=\"#3-注解语法\" class=\"headerlink\" title=\"3. 注解语法\"></a>3. 注解语法</h3><h4 id=\"注解定义\"><a href=\"#注解定义\" class=\"headerlink\" title=\"注解定义\"></a>注解定义</h4><p>注解是由接口来定义的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> AnnotationTest&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>每个元素声明都具有下面这种形式：<br><code>type elementName();</code><br>或者<br><code>type elementName() default value</code><br>注解接口中的元素声明实际上是方法声明。一个注解接口的方法不能有任何参数和任何throws语句，并且它们也不能是泛型的。<br>注解元素的类型可以是下列之一：</p>\n<ul>\n<li>Java8种基本类型</li>\n<li>String</li>\n<li>Class（具有一个可选的类型参数，例如<code>Class&lt;? extends MyClass&gt;</code>）</li>\n<li>enum 类型</li>\n<li>注解类型</li>\n<li>由上述类型组成的数组（由数组组成的数组不是合法的元素类型）</li>\n</ul>\n<p>既然一个注解元素可以是另一个注解，那么就可以创建出任意复杂的注解。例如：<br><code>@BugReport(ref=@Reference(id=&quot;123&quot;))</code><br><em>注意：在注解中引入循环依赖是一种错误。</em></p>\n<h4 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h4><p>在Java中，注解是当作一个<code>修饰符</code>来使用的，它被置于被注解项之前，中间没有分号。（修饰符就是诸如<code>public</code>和<code>static</code>之类的关键词）。除了方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个像<code>public</code>或者<code>static</code>这样的修饰符的地方。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AnnotationTest</span>(age = <span class=\"number\">20</span>, name=<span class=\"string\">\"小红\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有两个特殊的快捷方式可以用来简化注解。<br>如果没有指定元素，要么是因为注解中没有任何元素，要么是因为所有元素都是用默认值，那么你就不需要使用圆括号了。例如：<br><code>@AnnotationTest</code><br>和下面的注解是一样的<br><code>@AnnotationTest(age =18, name = &quot;小明&quot;)</code><br>这样的注解又称为<strong>标记注解</strong>。<br>另外一种快捷方式是<strong>单值注解</strong>。如果一个元素具有特殊的名字<code>value</code>，并且没有指定其他元素，那么你就可以忽略掉这个元素名以及等号。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> OneValue&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么我们可以将这个注解写成：<br><code>@OneValue(&quot;一个&quot;)</code><br>代替：<br><code>@OneValue(value = &quot;一个&quot;)</code></p>\n<p>一个项可以有多个注解，只要他们属于不同的类型即可。（在JDK1.8以前当注解一个特定项的时候，不能多次使用同一注解类型。但是在1.8之后新增<code>@Repeatable</code>注解，可以重复使用）例如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@OneValue</span>(<span class=\"string\">\"一\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Onevalue</span>(<span class=\"string\">\"二\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就是一种编译期错误。<br>如果你一定要多次使用一个注解，那么设计一个注解，它的值是一个由更简单的注解组成的数组：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> OneValues&#123;</span><br><span class=\"line\">\tOnevalue[] OneValues();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Onevalues</span>(&#123;<span class=\"meta\">@Onevalue</span>(<span class=\"string\">\"一\"</span>), <span class=\"meta\">@OneValue</span>(<span class=\"string\">\"二\"</span>)&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-标准注解\"><a href=\"#4-标准注解\" class=\"headerlink\" title=\"4. 标准注解\"></a>4. 标准注解</h3><p>Java SE在java.lang、java.lang.annotation和javax.annotation包中定义了大量的注解接口。其中四个是<strong>元注解</strong>，用于描述注解接口的行为属性，还有一些其他的预置注解方便你注解你的源代码中的项。</p>\n<h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解是什么意思呢？</p>\n<p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p>\n<p>如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。</p>\n<p>元标签有 <code>@Retention、@Documented、@Target、@Inherited、@Repeatable</code> 5 种。</p>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。<br>它的取值如下： </p>\n<ul>\n<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 </li>\n<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 </li>\n<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>Target 是目标的意思，@Target 指定了注解运用的地方。</p>\n<p>你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。</p>\n<p>类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值</p>\n<ul>\n<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>\n<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>\n<li>ElementType.FIELD 可以给属性进行注解</li>\n<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>\n<li>ElementType.METHOD 可以给方法进行注解</li>\n<li>ElementType.PACKAGE 可以给一个包进行注解</li>\n<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>\n<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>\n</ul>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。<br>说的比较抽象。代码来解释。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@interface</span> Test &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p>\n<p>可以这样理解：</p>\n<p>老子非常有钱，所以人们给他贴了一张标签叫做富豪。</p>\n<p>老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。</p>\n<p>老子的孙子长大了，自然也是富豪。</p>\n<p>这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。<br>【示例】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MethodInfo &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MethodInfo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationExample</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InheritedExample</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnnotationExample</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>【Test.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-2 下午9:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + info.age());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + info.name());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行<code>main</code>方法，得到结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age: 20</span><br><span class=\"line\">name: 小明</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h5><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。<br>举一个例子你就懂了，可以看这个链接：<a href=\"https://blog.csdn.net/z69183787/article/details/54602994\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/z69183787/article/details/54602994</a></p>\n<p>还有一些Java预置的注解如<code>@Deprecated、@Override、@SuppressWarnings、@SafeVarargs</code>等，有兴趣可以自行查阅。</p>\n<h3 id=\"5-注解的提取：反射\"><a href=\"#5-注解的提取：反射\" class=\"headerlink\" title=\"5. 注解的提取：反射\"></a>5. 注解的提取：反射</h3><p>注解通过反射获取。首先可以通过 Class 对象的 <code>isAnnotationPresent()</code> 方法判断它是否应用了某个注解。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnnotationPresent</span><span class=\"params\">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过 getAnnotation() 方法来获取 Annotation 对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;A extends Annotation&gt; <span class=\"function\">A <span class=\"title\">getAnnotation</span><span class=\"params\">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者是 getAnnotations() 方法。<br><code>public Annotation[] getAnnotations() {}</code><br>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p>\n<p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MethodInfo &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@MethodInfo</span><br><span class=\"line\">public class AnnotationExample &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-2 下午9:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + info.age());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + info.name());</span><br><span class=\"line\">        Annotation[] annotations = AnnotationExample.class.getAnnotations();</span><br><span class=\"line\">        System.out.println(annotations.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age: 20</span><br><span class=\"line\">name: 小明</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，如果一个注解要在运行时被成功提取，那么<code>@Retention(RetentionPolicy.RUNTIME)</code>是必须的。</p>\n<h3 id=\"6-源码级注解处理\"><a href=\"#6-源码级注解处理\" class=\"headerlink\" title=\"6. 源码级注解处理\"></a>6. 源码级注解处理</h3><p>明天再研究一下补充。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://blog.csdn.net/briblue/article/details/73824058\" target=\"_blank\" rel=\"noopener\">秒懂，Java 注解 （Annotation）你可以这样学</a><br>[2] <a href=\"https://blog.csdn.net/z69183787/article/details/54602994\" target=\"_blank\" rel=\"noopener\">java8 新增的@Repeatable注解</a><br>[3] 《Java核心技术卷二》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p><strong>注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。</strong><br>","more":"<br>看完了概念你理解了吗？注解本身并不能影响代码的执行，它能带来的影响是其他tools或Java编译器产生的。在这里我们只需要知道<strong>注解</strong>就相当于一个<strong>标签</strong>。</p>\n<p>注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><p>注解的使用范围很广泛，我现在只是初步了解了注解的用法。在这儿摘抄一段《Java核心技术卷二》原文：</p>\n<blockquote>\n<p>下面是关于注解的一些可能的用法：</p>\n<ul>\n<li>附属文件的自动生成，例如部署描述符或者bean信息类。</li>\n<li>测试、日志、事务语义等代码的自动生成。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-注解语法\"><a href=\"#3-注解语法\" class=\"headerlink\" title=\"3. 注解语法\"></a>3. 注解语法</h3><h4 id=\"注解定义\"><a href=\"#注解定义\" class=\"headerlink\" title=\"注解定义\"></a>注解定义</h4><p>注解是由接口来定义的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> AnnotationTest&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>每个元素声明都具有下面这种形式：<br><code>type elementName();</code><br>或者<br><code>type elementName() default value</code><br>注解接口中的元素声明实际上是方法声明。一个注解接口的方法不能有任何参数和任何throws语句，并且它们也不能是泛型的。<br>注解元素的类型可以是下列之一：</p>\n<ul>\n<li>Java8种基本类型</li>\n<li>String</li>\n<li>Class（具有一个可选的类型参数，例如<code>Class&lt;? extends MyClass&gt;</code>）</li>\n<li>enum 类型</li>\n<li>注解类型</li>\n<li>由上述类型组成的数组（由数组组成的数组不是合法的元素类型）</li>\n</ul>\n<p>既然一个注解元素可以是另一个注解，那么就可以创建出任意复杂的注解。例如：<br><code>@BugReport(ref=@Reference(id=&quot;123&quot;))</code><br><em>注意：在注解中引入循环依赖是一种错误。</em></p>\n<h4 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h4><p>在Java中，注解是当作一个<code>修饰符</code>来使用的，它被置于被注解项之前，中间没有分号。（修饰符就是诸如<code>public</code>和<code>static</code>之类的关键词）。除了方法外，还可以注解类、成员以及局部变量，这些注解可以存在于任何可以放置一个像<code>public</code>或者<code>static</code>这样的修饰符的地方。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AnnotationTest</span>(age = <span class=\"number\">20</span>, name=<span class=\"string\">\"小红\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有两个特殊的快捷方式可以用来简化注解。<br>如果没有指定元素，要么是因为注解中没有任何元素，要么是因为所有元素都是用默认值，那么你就不需要使用圆括号了。例如：<br><code>@AnnotationTest</code><br>和下面的注解是一样的<br><code>@AnnotationTest(age =18, name = &quot;小明&quot;)</code><br>这样的注解又称为<strong>标记注解</strong>。<br>另外一种快捷方式是<strong>单值注解</strong>。如果一个元素具有特殊的名字<code>value</code>，并且没有指定其他元素，那么你就可以忽略掉这个元素名以及等号。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> OneValue&#123;</span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么我们可以将这个注解写成：<br><code>@OneValue(&quot;一个&quot;)</code><br>代替：<br><code>@OneValue(value = &quot;一个&quot;)</code></p>\n<p>一个项可以有多个注解，只要他们属于不同的类型即可。（在JDK1.8以前当注解一个特定项的时候，不能多次使用同一注解类型。但是在1.8之后新增<code>@Repeatable</code>注解，可以重复使用）例如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@OneValue</span>(<span class=\"string\">\"一\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Onevalue</span>(<span class=\"string\">\"二\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就是一种编译期错误。<br>如果你一定要多次使用一个注解，那么设计一个注解，它的值是一个由更简单的注解组成的数组：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> OneValues&#123;</span><br><span class=\"line\">\tOnevalue[] OneValues();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Onevalues</span>(&#123;<span class=\"meta\">@Onevalue</span>(<span class=\"string\">\"一\"</span>), <span class=\"meta\">@OneValue</span>(<span class=\"string\">\"二\"</span>)&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-标准注解\"><a href=\"#4-标准注解\" class=\"headerlink\" title=\"4. 标准注解\"></a>4. 标准注解</h3><p>Java SE在java.lang、java.lang.annotation和javax.annotation包中定义了大量的注解接口。其中四个是<strong>元注解</strong>，用于描述注解接口的行为属性，还有一些其他的预置注解方便你注解你的源代码中的项。</p>\n<h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>元注解是什么意思呢？</p>\n<p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p>\n<p>如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。</p>\n<p>元标签有 <code>@Retention、@Documented、@Target、@Inherited、@Repeatable</code> 5 种。</p>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。<br>它的取值如下： </p>\n<ul>\n<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 </li>\n<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 </li>\n<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>Target 是目标的意思，@Target 指定了注解运用的地方。</p>\n<p>你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。</p>\n<p>类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值</p>\n<ul>\n<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>\n<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>\n<li>ElementType.FIELD 可以给属性进行注解</li>\n<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>\n<li>ElementType.METHOD 可以给方法进行注解</li>\n<li>ElementType.PACKAGE 可以给一个包进行注解</li>\n<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>\n<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>\n</ul>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。<br>说的比较抽象。代码来解释。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@interface</span> Test &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p>\n<p>可以这样理解：</p>\n<p>老子非常有钱，所以人们给他贴了一张标签叫做富豪。</p>\n<p>老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。</p>\n<p>老子的孙子长大了，自然也是富豪。</p>\n<p>这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。<br>【示例】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MethodInfo &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MethodInfo</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationExample</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InheritedExample</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnnotationExample</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>【Test.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-2 下午9:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + info.age());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + info.name());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行<code>main</code>方法，得到结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age: 20</span><br><span class=\"line\">name: 小明</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h5><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。<br>举一个例子你就懂了，可以看这个链接：<a href=\"https://blog.csdn.net/z69183787/article/details/54602994\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/z69183787/article/details/54602994</a></p>\n<p>还有一些Java预置的注解如<code>@Deprecated、@Override、@SuppressWarnings、@SafeVarargs</code>等，有兴趣可以自行查阅。</p>\n<h3 id=\"5-注解的提取：反射\"><a href=\"#5-注解的提取：反射\" class=\"headerlink\" title=\"5. 注解的提取：反射\"></a>5. 注解的提取：反射</h3><p>注解通过反射获取。首先可以通过 Class 对象的 <code>isAnnotationPresent()</code> 方法判断它是否应用了某个注解。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnnotationPresent</span><span class=\"params\">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后通过 getAnnotation() 方法来获取 Annotation 对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;A extends Annotation&gt; <span class=\"function\">A <span class=\"title\">getAnnotation</span><span class=\"params\">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者是 getAnnotations() 方法。<br><code>public Annotation[] getAnnotations() {}</code><br>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p>\n<p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MethodInfo &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"小明\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@MethodInfo</span><br><span class=\"line\">public class AnnotationExample &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-2 下午9:51</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodInfo info = InheritedExample.class.getAnnotation(MethodInfo.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"age: \"</span> + info.age());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name: \"</span> + info.name());</span><br><span class=\"line\">        Annotation[] annotations = AnnotationExample.class.getAnnotations();</span><br><span class=\"line\">        System.out.println(annotations.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age: 20</span><br><span class=\"line\">name: 小明</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，如果一个注解要在运行时被成功提取，那么<code>@Retention(RetentionPolicy.RUNTIME)</code>是必须的。</p>\n<h3 id=\"6-源码级注解处理\"><a href=\"#6-源码级注解处理\" class=\"headerlink\" title=\"6. 源码级注解处理\"></a>6. 源码级注解处理</h3><p>明天再研究一下补充。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://blog.csdn.net/briblue/article/details/73824058\" target=\"_blank\" rel=\"noopener\">秒懂，Java 注解 （Annotation）你可以这样学</a><br>[2] <a href=\"https://blog.csdn.net/z69183787/article/details/54602994\" target=\"_blank\" rel=\"noopener\">java8 新增的@Repeatable注解</a><br>[3] 《Java核心技术卷二》</p>\n</blockquote>"},{"toc":true,"title":"java 序列化(serialization)","date":"2018-03-21T06:22:47.000Z","_content":"\n当你需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但是在面向对象程序中创建的对象很少全部都具有相同的类型。Java语言支持一种称为`对象序列化(object serialization)`的非常通用的机制，它可以将任何对象写出到流中，并在之后将其读回。\n<!--more-->\n\n## 1. 怎么序列化\n对希望在对象流中存储或恢复的所有类都应该实现`Serialization`接口。\n为了保存对象数据，首先需要打开一个`ObjectOutputStream`对象；\n为了读回这些对象，首先需要获得一个`ObjectInputStream`对象。\n\n【例】：\n```\npackage stream;\n\nimport java.io.*;\n\n/**\n * author: jifang\n * date: 18-3-21 上午10:12\n */\n\npublic class SerializationTest {\n    static class Employee implements Serializable{\n        public static final long serialVersionUID = -5088705208352347828L;\n\n        String name;\n        int age;\n        Employee(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"Employee{\" +\n                    \"name='\" + name + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n\n    static class Manager extends Employee{\n\n        Manager(String name, int age) {\n            super(name, age);\n        }\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t// write()\n        read();\n    }\n\n    public static void write() throws IOException {\n        Employee harry = new Employee(\"harry hacker\",19);\n        Manager boss = new Manager(\"carl cracker\",20);\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n        out.writeObject(harry);\n        out.writeObject(boss);\n    }\n\n    public static void read() throws IOException, ClassNotFoundException {\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"employee.txt\"));\n        Employee e1 = (Employee) in.readObject();\n        Employee e2 = (Employee) in.readObject();\n    }\n}\n\n```\n为什么`Employee`要加上`serialization`字段呢？这个在`版本管理`会详细讲，在这里不加也行。\n**注意：** *你只有在写对象时才能用writeObject/readObject方法，对于基本类型值，你需要使用诸如writeInt/readInt或writeDouble/readDouble这样的方法。*\n\n在后台，是ObjectOutputStream在浏览对象的所有域，并存储它们的内容。\n但是，由一种重要的情况需要考虑：当一个对象被多个对象共享，作为它们各自状态的一部分时，会发生什么呢？\n答案是这个对象只被存储一次。让我们看看序列化机制： \n（每个对象都是用一个序列号保存的）\n- 当你遇到的每一个对象引用都关联一个序列号\n- 对于每个对象，当第一次遇到时，保存其对象数据到流中\n- 如果某个对象之前已经保存过了，那么只需要表明它之前的序列号\n- 对于流中的数据，在第一次遇到其序列号时，构建它，并使用流中数据初始化它，然后记录这个序列号和新对象之间的关联\n- 当遇到与之前保存过的相同序列号的对象时，获取这个序列号相关的对象引用\n\n## 2. 对象序列化的文件格式\n这里涉及到枯燥的规范，类似于计算机网络中tcp等报文头格式。（有兴趣可以看《java核心技术 卷二 》P34）\n在这里提一下：当存储一个对象时，其对应的类也必须存储。而在存储这个类信息中有`序列化的版本唯一的ID,它是数据域类型和方法签名的指纹`。\n**指纹**是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后将安全散列算法（SHA）应用与这些数据而获得。\n\n\tSHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸有多大，这种指纹总是20个字节的数据包。它是通过在数据上执行一个灵巧的位操作序列而创建的，这个序列在本质上可以保证无论这些数据以何种方式发生变化，其指纹也都会跟着变化。但是，序列化机制只使用了SHA码的前8个字节作为类的指纹。即便这样，当类的数据域或方法发生变化时，其指纹跟着变化的可能性还是非常大。\n\n对象流拒绝读入具有不同指纹的对象。\n\n## 3. transient\n当某些数据域不可以或不想被序列化时，可以将他们标记成`transient`，瞬时的域在对象被序列化时总是被跳过的。\n**transient使用小结**\n1. 一旦变量被`transient`标记，那么变量将不会被序列化，在之后回复时无法访问。\n2. `transient`只能修饰变量，而不能修饰方法和类。注意，局部变量不可以被`transient`修饰。\n3. 静态变量不管是否被`transient`修饰，都不会被序列化。\n【示例】\n```java\npackage stream;\n\nimport java.io.*;\n\n/**\n * author: jifang\n * date: 18-3-21 下午1:23\n */\n\npublic class TransientTest {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        //        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"user.dat\"));\n//        User user = new User();\n//        user.setVar3(3);\n//        user.setVar2(2);\n//        User.setVar1(1);\n//        objectOutputStream.writeObject(user);\n//        objectOutputStream.flush();\n//        objectOutputStream.close();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"user.dat\"));\n        User user2 = (User) objectInputStream.readObject();\n        System.out.println(user2.getVar3()+\" \"+user2.getVar2());\n    }\n}\n\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n    private static final long serialVersionUID = 8294180014912103005L;\n\n    public static int var1;\n    public  int var2;\n    public int var3;\n\n    public static int getVar1() {\n        return var1;\n    }\n\n    public static void setVar1(int var1) {\n        User.var1 = var1;\n    }\n\n    public int getVar2() {\n        return var2;\n    }\n\n    public void setVar2(int var2) {\n        this.var2 = var2;\n    }\n\n    public int getVar3() {\n        return var3;\n    }\n\n    public void setVar3(int var3) {\n        this.var3 = var3;\n    }\n}\n\n```\n先执行注释掉部分，再执行反序列化，得到结果。\n【输出结果】\n```java\nvar1: 0\nvar2: 2\nvar3: 3\n```\n`var1`反序列化之后为0，很明显，被赋予了默认值。所以这个`static`静态变量没有被序列化。\n\n## 4. 版本管理\n如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题。这就涉及到类的不同版本。\n而当类改变时，相应的指纹也会发生变化，我们上面已经提到，**对象流拒绝读入具有不同指纹的对象。**\n例如上面的示例代码，如果我把`User`类中的`serialVersionUID`注释掉之后再执行，就会出现下面这个异常。\n```java\nException in thread \"main\" java.io.InvalidClassException: stream.User; local class incompatible: stream classdesc serialVersionUID = 8294180014912103005, local class serialVersionUID = -773535447984752566\n\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687)\n\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1880)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1746)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2037)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:428)\n\tat stream.TransientTest.main(TransientTest.java:21)\n```\n如果一个类具有名为`serialVersionUID`的静态数据成员，它就不需要再人工地计算其指纹，而只需直接使用这个值。一旦这个静态数据成员被置于某个类的内部，那么序列化系统就可以读入这个类的对象的不同版本。\n如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。但是如果数据域产生了变化，那么久可能会有问题。例如，旧对象可能比新对象拥有更多或更少的数据域，或者相同名字的数据域的类型不同。那么，对象流在转换时就只能尽力转换成这个类的当前版本。\n它是怎么处理的呢：\n1. 对象流会将这个类当前版本的数据域域流中版本的数据域进行比较，当然，对象流只考虑非`transient`和非`static`数据域。\n2. 如果这两部分数据域之间名字匹配而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型。\n3. 如果流中的对象具有当前版本所没有的数据域，那么对象流就忽略这些额外的数据。\n4. 如果当前版本具有在流化对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（object: null, number: 0, boolean: false）\n\n书中这一章结尾提到了使用序列化来实现clone，但是效率却比实现clonable差很多。好了，java序列化就到这儿，下次见。\n\n> 参考文献\n> [1] [Java transient关键字使用小记](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html)\n>  [2] 《Java核心技术 卷二》\n\n\n\n\n","source":"_posts/java 序列化(serialization).md","raw":"---\ntoc: true\ntitle: java 序列化(serialization)\ndate: 2018-03-21 14:22:47\ntags: [transient,序列化]\n---\n\n当你需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但是在面向对象程序中创建的对象很少全部都具有相同的类型。Java语言支持一种称为`对象序列化(object serialization)`的非常通用的机制，它可以将任何对象写出到流中，并在之后将其读回。\n<!--more-->\n\n## 1. 怎么序列化\n对希望在对象流中存储或恢复的所有类都应该实现`Serialization`接口。\n为了保存对象数据，首先需要打开一个`ObjectOutputStream`对象；\n为了读回这些对象，首先需要获得一个`ObjectInputStream`对象。\n\n【例】：\n```\npackage stream;\n\nimport java.io.*;\n\n/**\n * author: jifang\n * date: 18-3-21 上午10:12\n */\n\npublic class SerializationTest {\n    static class Employee implements Serializable{\n        public static final long serialVersionUID = -5088705208352347828L;\n\n        String name;\n        int age;\n        Employee(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"Employee{\" +\n                    \"name='\" + name + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n\n    static class Manager extends Employee{\n\n        Manager(String name, int age) {\n            super(name, age);\n        }\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\t\t// write()\n        read();\n    }\n\n    public static void write() throws IOException {\n        Employee harry = new Employee(\"harry hacker\",19);\n        Manager boss = new Manager(\"carl cracker\",20);\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n        out.writeObject(harry);\n        out.writeObject(boss);\n    }\n\n    public static void read() throws IOException, ClassNotFoundException {\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"employee.txt\"));\n        Employee e1 = (Employee) in.readObject();\n        Employee e2 = (Employee) in.readObject();\n    }\n}\n\n```\n为什么`Employee`要加上`serialization`字段呢？这个在`版本管理`会详细讲，在这里不加也行。\n**注意：** *你只有在写对象时才能用writeObject/readObject方法，对于基本类型值，你需要使用诸如writeInt/readInt或writeDouble/readDouble这样的方法。*\n\n在后台，是ObjectOutputStream在浏览对象的所有域，并存储它们的内容。\n但是，由一种重要的情况需要考虑：当一个对象被多个对象共享，作为它们各自状态的一部分时，会发生什么呢？\n答案是这个对象只被存储一次。让我们看看序列化机制： \n（每个对象都是用一个序列号保存的）\n- 当你遇到的每一个对象引用都关联一个序列号\n- 对于每个对象，当第一次遇到时，保存其对象数据到流中\n- 如果某个对象之前已经保存过了，那么只需要表明它之前的序列号\n- 对于流中的数据，在第一次遇到其序列号时，构建它，并使用流中数据初始化它，然后记录这个序列号和新对象之间的关联\n- 当遇到与之前保存过的相同序列号的对象时，获取这个序列号相关的对象引用\n\n## 2. 对象序列化的文件格式\n这里涉及到枯燥的规范，类似于计算机网络中tcp等报文头格式。（有兴趣可以看《java核心技术 卷二 》P34）\n在这里提一下：当存储一个对象时，其对应的类也必须存储。而在存储这个类信息中有`序列化的版本唯一的ID,它是数据域类型和方法签名的指纹`。\n**指纹**是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后将安全散列算法（SHA）应用与这些数据而获得。\n\n\tSHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸有多大，这种指纹总是20个字节的数据包。它是通过在数据上执行一个灵巧的位操作序列而创建的，这个序列在本质上可以保证无论这些数据以何种方式发生变化，其指纹也都会跟着变化。但是，序列化机制只使用了SHA码的前8个字节作为类的指纹。即便这样，当类的数据域或方法发生变化时，其指纹跟着变化的可能性还是非常大。\n\n对象流拒绝读入具有不同指纹的对象。\n\n## 3. transient\n当某些数据域不可以或不想被序列化时，可以将他们标记成`transient`，瞬时的域在对象被序列化时总是被跳过的。\n**transient使用小结**\n1. 一旦变量被`transient`标记，那么变量将不会被序列化，在之后回复时无法访问。\n2. `transient`只能修饰变量，而不能修饰方法和类。注意，局部变量不可以被`transient`修饰。\n3. 静态变量不管是否被`transient`修饰，都不会被序列化。\n【示例】\n```java\npackage stream;\n\nimport java.io.*;\n\n/**\n * author: jifang\n * date: 18-3-21 下午1:23\n */\n\npublic class TransientTest {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        //        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"user.dat\"));\n//        User user = new User();\n//        user.setVar3(3);\n//        user.setVar2(2);\n//        User.setVar1(1);\n//        objectOutputStream.writeObject(user);\n//        objectOutputStream.flush();\n//        objectOutputStream.close();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"user.dat\"));\n        User user2 = (User) objectInputStream.readObject();\n        System.out.println(user2.getVar3()+\" \"+user2.getVar2());\n    }\n}\n\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n    private static final long serialVersionUID = 8294180014912103005L;\n\n    public static int var1;\n    public  int var2;\n    public int var3;\n\n    public static int getVar1() {\n        return var1;\n    }\n\n    public static void setVar1(int var1) {\n        User.var1 = var1;\n    }\n\n    public int getVar2() {\n        return var2;\n    }\n\n    public void setVar2(int var2) {\n        this.var2 = var2;\n    }\n\n    public int getVar3() {\n        return var3;\n    }\n\n    public void setVar3(int var3) {\n        this.var3 = var3;\n    }\n}\n\n```\n先执行注释掉部分，再执行反序列化，得到结果。\n【输出结果】\n```java\nvar1: 0\nvar2: 2\nvar3: 3\n```\n`var1`反序列化之后为0，很明显，被赋予了默认值。所以这个`static`静态变量没有被序列化。\n\n## 4. 版本管理\n如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题。这就涉及到类的不同版本。\n而当类改变时，相应的指纹也会发生变化，我们上面已经提到，**对象流拒绝读入具有不同指纹的对象。**\n例如上面的示例代码，如果我把`User`类中的`serialVersionUID`注释掉之后再执行，就会出现下面这个异常。\n```java\nException in thread \"main\" java.io.InvalidClassException: stream.User; local class incompatible: stream classdesc serialVersionUID = 8294180014912103005, local class serialVersionUID = -773535447984752566\n\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687)\n\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1880)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1746)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2037)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:428)\n\tat stream.TransientTest.main(TransientTest.java:21)\n```\n如果一个类具有名为`serialVersionUID`的静态数据成员，它就不需要再人工地计算其指纹，而只需直接使用这个值。一旦这个静态数据成员被置于某个类的内部，那么序列化系统就可以读入这个类的对象的不同版本。\n如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。但是如果数据域产生了变化，那么久可能会有问题。例如，旧对象可能比新对象拥有更多或更少的数据域，或者相同名字的数据域的类型不同。那么，对象流在转换时就只能尽力转换成这个类的当前版本。\n它是怎么处理的呢：\n1. 对象流会将这个类当前版本的数据域域流中版本的数据域进行比较，当然，对象流只考虑非`transient`和非`static`数据域。\n2. 如果这两部分数据域之间名字匹配而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型。\n3. 如果流中的对象具有当前版本所没有的数据域，那么对象流就忽略这些额外的数据。\n4. 如果当前版本具有在流化对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（object: null, number: 0, boolean: false）\n\n书中这一章结尾提到了使用序列化来实现clone，但是效率却比实现clonable差很多。好了，java序列化就到这儿，下次见。\n\n> 参考文献\n> [1] [Java transient关键字使用小记](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html)\n>  [2] 《Java核心技术 卷二》\n\n\n\n\n","slug":"java 序列化(serialization)","published":1,"updated":"2018-08-13T14:28:27.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5i002i6k15ln30bj2n","content":"<p>当你需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但是在面向对象程序中创建的对象很少全部都具有相同的类型。Java语言支持一种称为<code>对象序列化(object serialization)</code>的非常通用的机制，它可以将任何对象写出到流中，并在之后将其读回。<br><a id=\"more\"></a></p>\n<h2 id=\"1-怎么序列化\"><a href=\"#1-怎么序列化\" class=\"headerlink\" title=\"1. 怎么序列化\"></a>1. 怎么序列化</h2><p>对希望在对象流中存储或恢复的所有类都应该实现<code>Serialization</code>接口。<br>为了保存对象数据，首先需要打开一个<code>ObjectOutputStream</code>对象；<br>为了读回这些对象，首先需要获得一个<code>ObjectInputStream</code>对象。</p>\n<p>【例】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package stream;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * author: jifang</span><br><span class=\"line\"> * date: 18-3-21 上午10:12</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public class SerializationTest &#123;</span><br><span class=\"line\">    static class Employee implements Serializable&#123;</span><br><span class=\"line\">        public static final long serialVersionUID = -5088705208352347828L;</span><br><span class=\"line\"></span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        int age;</span><br><span class=\"line\">        Employee(String name, int age) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">            this.age = age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Employee&#123;&quot; +</span><br><span class=\"line\">                    &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                    &quot;, age=&quot; + age +</span><br><span class=\"line\">                    &apos;&#125;&apos;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Manager extends Employee&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Manager(String name, int age) &#123;</span><br><span class=\"line\">            super(name, age);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\t// write()</span><br><span class=\"line\">        read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void write() throws IOException &#123;</span><br><span class=\"line\">        Employee harry = new Employee(&quot;harry hacker&quot;,19);</span><br><span class=\"line\">        Manager boss = new Manager(&quot;carl cracker&quot;,20);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));</span><br><span class=\"line\">        out.writeObject(harry);</span><br><span class=\"line\">        out.writeObject(boss);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void read() throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.txt&quot;));</span><br><span class=\"line\">        Employee e1 = (Employee) in.readObject();</span><br><span class=\"line\">        Employee e2 = (Employee) in.readObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么<code>Employee</code>要加上<code>serialization</code>字段呢？这个在<code>版本管理</code>会详细讲，在这里不加也行。<br><strong>注意：</strong> <em>你只有在写对象时才能用writeObject/readObject方法，对于基本类型值，你需要使用诸如writeInt/readInt或writeDouble/readDouble这样的方法。</em></p>\n<p>在后台，是ObjectOutputStream在浏览对象的所有域，并存储它们的内容。<br>但是，由一种重要的情况需要考虑：当一个对象被多个对象共享，作为它们各自状态的一部分时，会发生什么呢？<br>答案是这个对象只被存储一次。让我们看看序列化机制：<br>（每个对象都是用一个序列号保存的）</p>\n<ul>\n<li>当你遇到的每一个对象引用都关联一个序列号</li>\n<li>对于每个对象，当第一次遇到时，保存其对象数据到流中</li>\n<li>如果某个对象之前已经保存过了，那么只需要表明它之前的序列号</li>\n<li>对于流中的数据，在第一次遇到其序列号时，构建它，并使用流中数据初始化它，然后记录这个序列号和新对象之间的关联</li>\n<li>当遇到与之前保存过的相同序列号的对象时，获取这个序列号相关的对象引用</li>\n</ul>\n<h2 id=\"2-对象序列化的文件格式\"><a href=\"#2-对象序列化的文件格式\" class=\"headerlink\" title=\"2. 对象序列化的文件格式\"></a>2. 对象序列化的文件格式</h2><p>这里涉及到枯燥的规范，类似于计算机网络中tcp等报文头格式。（有兴趣可以看《java核心技术 卷二 》P34）<br>在这里提一下：当存储一个对象时，其对应的类也必须存储。而在存储这个类信息中有<code>序列化的版本唯一的ID,它是数据域类型和方法签名的指纹</code>。<br><strong>指纹</strong>是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后将安全散列算法（SHA）应用与这些数据而获得。</p>\n<pre><code>SHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸有多大，这种指纹总是20个字节的数据包。它是通过在数据上执行一个灵巧的位操作序列而创建的，这个序列在本质上可以保证无论这些数据以何种方式发生变化，其指纹也都会跟着变化。但是，序列化机制只使用了SHA码的前8个字节作为类的指纹。即便这样，当类的数据域或方法发生变化时，其指纹跟着变化的可能性还是非常大。\n</code></pre><p>对象流拒绝读入具有不同指纹的对象。</p>\n<h2 id=\"3-transient\"><a href=\"#3-transient\" class=\"headerlink\" title=\"3. transient\"></a>3. transient</h2><p>当某些数据域不可以或不想被序列化时，可以将他们标记成<code>transient</code>，瞬时的域在对象被序列化时总是被跳过的。<br><strong>transient使用小结</strong></p>\n<ol>\n<li>一旦变量被<code>transient</code>标记，那么变量将不会被序列化，在之后回复时无法访问。</li>\n<li><code>transient</code>只能修饰变量，而不能修饰方法和类。注意，局部变量不可以被<code>transient</code>修饰。</li>\n<li>静态变量不管是否被<code>transient</code>修饰，都不会被序列化。<br>【示例】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-21 下午1:23</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"user.dat\"));</span></span><br><span class=\"line\"><span class=\"comment\">//        User user = new User();</span></span><br><span class=\"line\"><span class=\"comment\">//        user.setVar3(3);</span></span><br><span class=\"line\"><span class=\"comment\">//        user.setVar2(2);</span></span><br><span class=\"line\"><span class=\"comment\">//        User.setVar1(1);</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.writeObject(user);</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.flush();</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.close();</span></span><br><span class=\"line\">        ObjectInputStream objectInputStream = <span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"user.dat\"</span>));</span><br><span class=\"line\">        User user2 = (User) objectInputStream.readObject();</span><br><span class=\"line\">        System.out.println(user2.getVar3()+<span class=\"string\">\" \"</span>+user2.getVar2());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8294180014912103005L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> var1;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">int</span> var2;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> var3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar1</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span> </span>&#123;</span><br><span class=\"line\">        User.var1 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar2</span><span class=\"params\">(<span class=\"keyword\">int</span> var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.var2 = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar3</span><span class=\"params\">(<span class=\"keyword\">int</span> var3)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.var3 = var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先执行注释掉部分，再执行反序列化，得到结果。<br>【输出结果】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var1: <span class=\"number\">0</span></span><br><span class=\"line\">var2: <span class=\"number\">2</span></span><br><span class=\"line\">var3: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p><code>var1</code>反序列化之后为0，很明显，被赋予了默认值。所以这个<code>static</code>静态变量没有被序列化。</p>\n<h2 id=\"4-版本管理\"><a href=\"#4-版本管理\" class=\"headerlink\" title=\"4. 版本管理\"></a>4. 版本管理</h2><p>如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题。这就涉及到类的不同版本。<br>而当类改变时，相应的指纹也会发生变化，我们上面已经提到，<strong>对象流拒绝读入具有不同指纹的对象。</strong><br>例如上面的示例代码，如果我把<code>User</code>类中的<code>serialVersionUID</code>注释掉之后再执行，就会出现下面这个异常。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread \"main\" java.io.InvalidClassException: stream.User; local class incompatible: stream classdesc serialVersionUID = 8294180014912103005, local class serialVersionUID = -773535447984752566</span><br><span class=\"line\">\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class=\"number\">687</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class=\"number\">1880</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class=\"number\">1746</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class=\"number\">2037</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class=\"number\">1568</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class=\"number\">428</span>)</span><br><span class=\"line\">\tat stream.TransientTest.main(TransientTest.java:<span class=\"number\">21</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果一个类具有名为<code>serialVersionUID</code>的静态数据成员，它就不需要再人工地计算其指纹，而只需直接使用这个值。一旦这个静态数据成员被置于某个类的内部，那么序列化系统就可以读入这个类的对象的不同版本。<br>如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。但是如果数据域产生了变化，那么久可能会有问题。例如，旧对象可能比新对象拥有更多或更少的数据域，或者相同名字的数据域的类型不同。那么，对象流在转换时就只能尽力转换成这个类的当前版本。<br>它是怎么处理的呢：</p>\n<ol>\n<li>对象流会将这个类当前版本的数据域域流中版本的数据域进行比较，当然，对象流只考虑非<code>transient</code>和非<code>static</code>数据域。</li>\n<li>如果这两部分数据域之间名字匹配而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型。</li>\n<li>如果流中的对象具有当前版本所没有的数据域，那么对象流就忽略这些额外的数据。</li>\n<li>如果当前版本具有在流化对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（object: null, number: 0, boolean: false）</li>\n</ol>\n<p>书中这一章结尾提到了使用序列化来实现clone，但是效率却比实现clonable差很多。好了，java序列化就到这儿，下次见。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://www.cnblogs.com/lanxuezaipiao/p/3369962.html\" target=\"_blank\" rel=\"noopener\">Java transient关键字使用小记</a><br> [2] 《Java核心技术 卷二》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>当你需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但是在面向对象程序中创建的对象很少全部都具有相同的类型。Java语言支持一种称为<code>对象序列化(object serialization)</code>的非常通用的机制，它可以将任何对象写出到流中，并在之后将其读回。<br>","more":"</p>\n<h2 id=\"1-怎么序列化\"><a href=\"#1-怎么序列化\" class=\"headerlink\" title=\"1. 怎么序列化\"></a>1. 怎么序列化</h2><p>对希望在对象流中存储或恢复的所有类都应该实现<code>Serialization</code>接口。<br>为了保存对象数据，首先需要打开一个<code>ObjectOutputStream</code>对象；<br>为了读回这些对象，首先需要获得一个<code>ObjectInputStream</code>对象。</p>\n<p>【例】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package stream;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * author: jifang</span><br><span class=\"line\"> * date: 18-3-21 上午10:12</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public class SerializationTest &#123;</span><br><span class=\"line\">    static class Employee implements Serializable&#123;</span><br><span class=\"line\">        public static final long serialVersionUID = -5088705208352347828L;</span><br><span class=\"line\"></span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        int age;</span><br><span class=\"line\">        Employee(String name, int age) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">            this.age = age;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Employee&#123;&quot; +</span><br><span class=\"line\">                    &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                    &quot;, age=&quot; + age +</span><br><span class=\"line\">                    &apos;&#125;&apos;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class Manager extends Employee&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Manager(String name, int age) &#123;</span><br><span class=\"line\">            super(name, age);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\t// write()</span><br><span class=\"line\">        read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void write() throws IOException &#123;</span><br><span class=\"line\">        Employee harry = new Employee(&quot;harry hacker&quot;,19);</span><br><span class=\"line\">        Manager boss = new Manager(&quot;carl cracker&quot;,20);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));</span><br><span class=\"line\">        out.writeObject(harry);</span><br><span class=\"line\">        out.writeObject(boss);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void read() throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;employee.txt&quot;));</span><br><span class=\"line\">        Employee e1 = (Employee) in.readObject();</span><br><span class=\"line\">        Employee e2 = (Employee) in.readObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么<code>Employee</code>要加上<code>serialization</code>字段呢？这个在<code>版本管理</code>会详细讲，在这里不加也行。<br><strong>注意：</strong> <em>你只有在写对象时才能用writeObject/readObject方法，对于基本类型值，你需要使用诸如writeInt/readInt或writeDouble/readDouble这样的方法。</em></p>\n<p>在后台，是ObjectOutputStream在浏览对象的所有域，并存储它们的内容。<br>但是，由一种重要的情况需要考虑：当一个对象被多个对象共享，作为它们各自状态的一部分时，会发生什么呢？<br>答案是这个对象只被存储一次。让我们看看序列化机制：<br>（每个对象都是用一个序列号保存的）</p>\n<ul>\n<li>当你遇到的每一个对象引用都关联一个序列号</li>\n<li>对于每个对象，当第一次遇到时，保存其对象数据到流中</li>\n<li>如果某个对象之前已经保存过了，那么只需要表明它之前的序列号</li>\n<li>对于流中的数据，在第一次遇到其序列号时，构建它，并使用流中数据初始化它，然后记录这个序列号和新对象之间的关联</li>\n<li>当遇到与之前保存过的相同序列号的对象时，获取这个序列号相关的对象引用</li>\n</ul>\n<h2 id=\"2-对象序列化的文件格式\"><a href=\"#2-对象序列化的文件格式\" class=\"headerlink\" title=\"2. 对象序列化的文件格式\"></a>2. 对象序列化的文件格式</h2><p>这里涉及到枯燥的规范，类似于计算机网络中tcp等报文头格式。（有兴趣可以看《java核心技术 卷二 》P34）<br>在这里提一下：当存储一个对象时，其对应的类也必须存储。而在存储这个类信息中有<code>序列化的版本唯一的ID,它是数据域类型和方法签名的指纹</code>。<br><strong>指纹</strong>是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后将安全散列算法（SHA）应用与这些数据而获得。</p>\n<pre><code>SHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸有多大，这种指纹总是20个字节的数据包。它是通过在数据上执行一个灵巧的位操作序列而创建的，这个序列在本质上可以保证无论这些数据以何种方式发生变化，其指纹也都会跟着变化。但是，序列化机制只使用了SHA码的前8个字节作为类的指纹。即便这样，当类的数据域或方法发生变化时，其指纹跟着变化的可能性还是非常大。\n</code></pre><p>对象流拒绝读入具有不同指纹的对象。</p>\n<h2 id=\"3-transient\"><a href=\"#3-transient\" class=\"headerlink\" title=\"3. transient\"></a>3. transient</h2><p>当某些数据域不可以或不想被序列化时，可以将他们标记成<code>transient</code>，瞬时的域在对象被序列化时总是被跳过的。<br><strong>transient使用小结</strong></p>\n<ol>\n<li>一旦变量被<code>transient</code>标记，那么变量将不会被序列化，在之后回复时无法访问。</li>\n<li><code>transient</code>只能修饰变量，而不能修饰方法和类。注意，局部变量不可以被<code>transient</code>修饰。</li>\n<li>静态变量不管是否被<code>transient</code>修饰，都不会被序列化。<br>【示例】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-21 下午1:23</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"user.dat\"));</span></span><br><span class=\"line\"><span class=\"comment\">//        User user = new User();</span></span><br><span class=\"line\"><span class=\"comment\">//        user.setVar3(3);</span></span><br><span class=\"line\"><span class=\"comment\">//        user.setVar2(2);</span></span><br><span class=\"line\"><span class=\"comment\">//        User.setVar1(1);</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.writeObject(user);</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.flush();</span></span><br><span class=\"line\"><span class=\"comment\">//        objectOutputStream.close();</span></span><br><span class=\"line\">        ObjectInputStream objectInputStream = <span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"user.dat\"</span>));</span><br><span class=\"line\">        User user2 = (User) objectInputStream.readObject();</span><br><span class=\"line\">        System.out.println(user2.getVar3()+<span class=\"string\">\" \"</span>+user2.getVar2());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8294180014912103005L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> var1;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">int</span> var2;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> var3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar1</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span> </span>&#123;</span><br><span class=\"line\">        User.var1 = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar2</span><span class=\"params\">(<span class=\"keyword\">int</span> var2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.var2 = var2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getVar3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setVar3</span><span class=\"params\">(<span class=\"keyword\">int</span> var3)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.var3 = var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>先执行注释掉部分，再执行反序列化，得到结果。<br>【输出结果】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var1: <span class=\"number\">0</span></span><br><span class=\"line\">var2: <span class=\"number\">2</span></span><br><span class=\"line\">var3: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p><code>var1</code>反序列化之后为0，很明显，被赋予了默认值。所以这个<code>static</code>静态变量没有被序列化。</p>\n<h2 id=\"4-版本管理\"><a href=\"#4-版本管理\" class=\"headerlink\" title=\"4. 版本管理\"></a>4. 版本管理</h2><p>如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题。这就涉及到类的不同版本。<br>而当类改变时，相应的指纹也会发生变化，我们上面已经提到，<strong>对象流拒绝读入具有不同指纹的对象。</strong><br>例如上面的示例代码，如果我把<code>User</code>类中的<code>serialVersionUID</code>注释掉之后再执行，就会出现下面这个异常。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread \"main\" java.io.InvalidClassException: stream.User; local class incompatible: stream classdesc serialVersionUID = 8294180014912103005, local class serialVersionUID = -773535447984752566</span><br><span class=\"line\">\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class=\"number\">687</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class=\"number\">1880</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class=\"number\">1746</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class=\"number\">2037</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class=\"number\">1568</span>)</span><br><span class=\"line\">\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class=\"number\">428</span>)</span><br><span class=\"line\">\tat stream.TransientTest.main(TransientTest.java:<span class=\"number\">21</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果一个类具有名为<code>serialVersionUID</code>的静态数据成员，它就不需要再人工地计算其指纹，而只需直接使用这个值。一旦这个静态数据成员被置于某个类的内部，那么序列化系统就可以读入这个类的对象的不同版本。<br>如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。但是如果数据域产生了变化，那么久可能会有问题。例如，旧对象可能比新对象拥有更多或更少的数据域，或者相同名字的数据域的类型不同。那么，对象流在转换时就只能尽力转换成这个类的当前版本。<br>它是怎么处理的呢：</p>\n<ol>\n<li>对象流会将这个类当前版本的数据域域流中版本的数据域进行比较，当然，对象流只考虑非<code>transient</code>和非<code>static</code>数据域。</li>\n<li>如果这两部分数据域之间名字匹配而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型。</li>\n<li>如果流中的对象具有当前版本所没有的数据域，那么对象流就忽略这些额外的数据。</li>\n<li>如果当前版本具有在流化对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值（object: null, number: 0, boolean: false）</li>\n</ol>\n<p>书中这一章结尾提到了使用序列化来实现clone，但是效率却比实现clonable差很多。好了，java序列化就到这儿，下次见。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://www.cnblogs.com/lanxuezaipiao/p/3369962.html\" target=\"_blank\" rel=\"noopener\">Java transient关键字使用小记</a><br> [2] 《Java核心技术 卷二》</p>\n</blockquote>"},{"toc":true,"title":"《Spring实战》Spring中使用JDBC","date":"2018-04-11T01:45:43.000Z","_content":"\n为了避免持久化的逻辑分散到应用的各个组件中，最好将数据访问的功能放到一个或多个专注于此项任务的组件中。这样的组件通常称为数据访问对象（Data acess  object, DAO）或 Repository。\n<!--more-->\n### 1. 配置数据源\nSpring上下文中配置数据源bean提供了多种方式：\n- 通过JDBC驱动程序定义的数据源\n- 通过JNDI查找数据源配置\n- 连接池的数据源\n\n这里介绍第一和第三种方式。\n#### 通过JDBC驱动程序定义的数据源\n在Spring中,通过JDBC驱动定义数据源是最简单的配置方式。Spring提供了三个这样的数据源类(均位于org.springframework.jdbc.datasource包中)供选择:\n- DriverManagerDataSource:在每个连接请求时都会返回一个新建的连接。与DBCP的BasicDataSource不同,由DriverManagerDataSource提供的连接并没有进行池化管理;\n- SimpleDriverDataSource:与DriverManagerDataSource的工作方式类似,但是它直接使用JDBC驱动,来解决在特定环境下的类加载问题,这样的环境包括OSGi容器;\n- SingleConnectionDataSource:在每个连接请求时都会返回同一个的连接。尽管SingleConnectionDataSource不是严格意义上的连接池数据源,但是你可以将其视为只有一个连接的池。\n这些数据源的配置与DBCP的配置类似。\n```java\n    /**\n     * 基于JDBC驱动的数据源\n     * @return\n     */\n    @Bean\n    public DataSource dataSource(){\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");;\n        return dataSource;\n    }\n```\n与具备池功能的数据源相比,唯一的区别在于这些数据源bean都没有提供连接池功能,所以没有可配置的池相关的属性。\n\n\n#### 使用数据源连接池\n常用的主流开源数据库连接池有C3P0、DBCP、Tomcat Jdbc Pool、BoneCP、Druid等\n\n**C3p0**: 开源的JDBC连接池，实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。单线程，性能较差，适用于小型系统，代码600KB左右。\n\n**DBCP** (Database Connection Pool):由Apache开发的一个Java数据库连接池项目， Jakarta commons-pool对象池机制，Tomcat使用的连接池组件就是DBCP。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar，预先将数据库连接放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完再放回。单线程，并发量低，性能不好，适用于小型系统。\n\n**Druid**：Druid是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能，是一个可用于大数据实时查询和分析的高容错、高性能的开源分布式系统，尤其是当发生代码部署、机器故障以及其他产品系统遇到宕机等情况时，Druid仍能够保持100%正常运行。主要特色：为分析监控设计；快速的交互式查询；高可用；可扩展；Druid是一个开源项目，源码托管在github上。\n\n以DBCP连接池为例：\nJava配置，连接池形式的DataSource Bean可以声明如下：\n```java\n    /**\n     * Druid数据库连接池\n     *\n     * @return\n     */\n    @Bean\n    public DruidDataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        /*dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");*/\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/spittr\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"\");\n        dataSource.setInitialSize(5);\n        dataSource.setMaxActive(10);\n        return dataSource;\n    }\n```\n\n前四个属性是配置BasicDataSource所必需的。属性driverClassName指定了JDBC驱\n动类的全限定类名，需要提前将对应数据库的驱动依赖jar包放置在classpath下。\n注释配置的是H2内存数据库，显式配置的是MySQL数据库。\n\n#### 使用嵌入式的数据源\n**嵌入式数据库（embedded database）**：每次重启应用或运行测试的时候，都能够重新填充测试数据。多用于开发和测试环境，它会预先加载一组测试数据。\n\n**使用jdbc命名空间配置嵌入式数据库**\n```xml\n<jdbc:embedded-database id=\"dataSource\" type=\"H2\">\n\t<jdbc:script localtion=\"classpath:xxx.sql\"/>\n\t<jdbc:script localtion=\"classpath:yyy.sql\"/>\n</jdbc:embedded-database>\n```\n在`<jdbc:embedded-database>`中,我们可以不配置也可以配置多个`<jdbc:script>`元素来搭建数据库。\n\n**使用Java配置嵌入式数据库**\n```java\n    @Bean\n    public DataSource dataSource3(){\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"\")\n                .addScript(\"\")\n                .build();\n    }\n```\n\n#### 使用profile选择数据源\n我们已经学习了多种配置数据源的方式，在正常的开发任务中，我们有不同的环境，也就有不同的数据源。\n\n例如,对于开发期来说,`<jdbc:embedded-database>`元素是很合适的,而在QA环境中,你可能希望使用DBCP的BasicDataSource,在生产部署环境下,可能需要使用`<jee:jndi-lookup>`。\n\n我们之前讨论的装配Bean profile特性恰好用在这儿。\n```java\n    /**\n     * Druid数据库连接池\n     *\n     * @return\n     */\n    @Profile(\"prod\")\n    @Bean\n    public DruidDataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        /*dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");*/\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/spittr\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"\");\n        dataSource.setInitialSize(5);\n        dataSource.setMaxActive(10);\n        return dataSource;\n    }\n\n    /**\n     * 配置Jdbc模板类\n     *\n     * @param druidDataSource\n     * @return\n     */\n    @Bean\n    public JdbcTemplate jdbcTemplate(DruidDataSource druidDataSource) {\n        return new JdbcTemplate(druidDataSource);\n    }\n\n    /**\n     * 基于JDBC驱动的数据源\n     * @return\n     */\n    @Profile(\"qa\")\n    @Bean\n    public DataSource dataSource2(){\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");;\n        return dataSource;\n    }\n\n    /**\n     * 嵌入式数据库\n     * @return\n     */\n    @Profile(\"dev\")\n    @Bean\n    public DataSource dataSource3(){\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"\")\n                .addScript(\"\")\n                .build();\n    }\n```\n\n### 2. 使用JDBC模板\nSpring将数据访问过程中固定的和可变的部分明确划分为两个不同的类：模板(template)和回调(callback)。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。\n\n**繁琐的JDBC代码**\n```java\n    public static void fun() throws SQLException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = getConnection();\n            //操作5（查看李四余额）\n            sql = \"select balance from account where name=?\";\n            pstmt = con.prepareStatement(sql);\n            pstmt.setString(1, \"ls\");\n            ResultSet rs = pstmt.executeQuery();\n            rs.next();\n            double balance = rs.getDouble(1);\n            //如果李四余额为负数，那么回滚到指定保存点\n            if(balance < 0) {\n                System.out.println(\"张三，你上当了！\");\n            }\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            if (!con.isClosed()){\n                con.close();\n            }\n        }\n    }\n```\n可以看到，我们每次都要进行connection创建，statement创建，执行语句，获取结果，一次关闭连接这些样板代码。\n\nSpring将数据访问的样板代码抽象到模板类之中。Spring为JDBC提供了三个模板类供选择：\n- **JdbcTemplate**:最基本的Spring JDBC模板,这个模板支持简单的JDBC数据库访问功能以及**基于索引参数**的查询;\n- **NamedParameterJdbcTemplate**:使用该模板类执行查询时可以将值**以命名参数的形式**绑定到SQL中,而不是使用简单的索引参数;\n- **SimpleJdbcTemplate**:该模板类利用Java 5的一些特性如自动装箱、泛型以及可变参数列表来简化JDBC模板的使用。\n\n以前,在选择哪一个JDBC模板的时候,我们需要仔细权衡。但是从Spring 3.1开始,做这个决定变得容易多了。SimpleJdbcTemplate已经被废弃了,其Java 5的特性被转移到了JdbcTemplate中,并且只有在你需要使用命名参数的时候,才需要使用NamedParameterJdbcTemplate。这样的话,对于大多数的JDBC任务来说,JdbcTemplate就是最好的可选方案。\n\n**配置JdbcTemplate**\n```java\n    @Bean\n    public JdbcTemplate jdbcTemplate(DruidDataSource druidDataSource) {\n        return new JdbcTemplate(druidDataSource);\n    }\n```\n\nJdbcTemplate主要提供一下五类方法：\n- execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\n- update方法：用于执行新增、修改、删除等语句；\n- batchUpdate方法用于执行批处理相关语句；\n- query方法及queryForXXX方法：用于执行查询相关语句；\n- call方法：用于执行存储过程、函数相关语句。\n\n**RowMapper接口**\n我们可以实现RowMapper接口的RowMapper()方法，这个方法会传入ResultSet和包含行号的整数。在实习类中创建自定义对象并填充对应的值。\n\n\n\n> 参考文献\n> [1] 《Spring实战》4th\n> [2] [Spring-jdbc：JdbcTemplate使用简介](https://blog.csdn.net/u013468917/article/details/52217954)\n> [3] [Spring之jdbcTemplate：查询的三种方式（单个值、单个对象、对象集合）](https://www.cnblogs.com/gongxr/p/8053010.html)\n\n","source":"_posts/《Spring实战》Spring中使用JDBC.md","raw":"---\ntoc: true\ntitle: 《Spring实战》Spring中使用JDBC\ndate: 2018-04-11 09:45:43\ntags: [JDBC,DataSource]\n---\n\n为了避免持久化的逻辑分散到应用的各个组件中，最好将数据访问的功能放到一个或多个专注于此项任务的组件中。这样的组件通常称为数据访问对象（Data acess  object, DAO）或 Repository。\n<!--more-->\n### 1. 配置数据源\nSpring上下文中配置数据源bean提供了多种方式：\n- 通过JDBC驱动程序定义的数据源\n- 通过JNDI查找数据源配置\n- 连接池的数据源\n\n这里介绍第一和第三种方式。\n#### 通过JDBC驱动程序定义的数据源\n在Spring中,通过JDBC驱动定义数据源是最简单的配置方式。Spring提供了三个这样的数据源类(均位于org.springframework.jdbc.datasource包中)供选择:\n- DriverManagerDataSource:在每个连接请求时都会返回一个新建的连接。与DBCP的BasicDataSource不同,由DriverManagerDataSource提供的连接并没有进行池化管理;\n- SimpleDriverDataSource:与DriverManagerDataSource的工作方式类似,但是它直接使用JDBC驱动,来解决在特定环境下的类加载问题,这样的环境包括OSGi容器;\n- SingleConnectionDataSource:在每个连接请求时都会返回同一个的连接。尽管SingleConnectionDataSource不是严格意义上的连接池数据源,但是你可以将其视为只有一个连接的池。\n这些数据源的配置与DBCP的配置类似。\n```java\n    /**\n     * 基于JDBC驱动的数据源\n     * @return\n     */\n    @Bean\n    public DataSource dataSource(){\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");;\n        return dataSource;\n    }\n```\n与具备池功能的数据源相比,唯一的区别在于这些数据源bean都没有提供连接池功能,所以没有可配置的池相关的属性。\n\n\n#### 使用数据源连接池\n常用的主流开源数据库连接池有C3P0、DBCP、Tomcat Jdbc Pool、BoneCP、Druid等\n\n**C3p0**: 开源的JDBC连接池，实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。单线程，性能较差，适用于小型系统，代码600KB左右。\n\n**DBCP** (Database Connection Pool):由Apache开发的一个Java数据库连接池项目， Jakarta commons-pool对象池机制，Tomcat使用的连接池组件就是DBCP。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar，预先将数据库连接放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完再放回。单线程，并发量低，性能不好，适用于小型系统。\n\n**Druid**：Druid是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能，是一个可用于大数据实时查询和分析的高容错、高性能的开源分布式系统，尤其是当发生代码部署、机器故障以及其他产品系统遇到宕机等情况时，Druid仍能够保持100%正常运行。主要特色：为分析监控设计；快速的交互式查询；高可用；可扩展；Druid是一个开源项目，源码托管在github上。\n\n以DBCP连接池为例：\nJava配置，连接池形式的DataSource Bean可以声明如下：\n```java\n    /**\n     * Druid数据库连接池\n     *\n     * @return\n     */\n    @Bean\n    public DruidDataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        /*dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");*/\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/spittr\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"\");\n        dataSource.setInitialSize(5);\n        dataSource.setMaxActive(10);\n        return dataSource;\n    }\n```\n\n前四个属性是配置BasicDataSource所必需的。属性driverClassName指定了JDBC驱\n动类的全限定类名，需要提前将对应数据库的驱动依赖jar包放置在classpath下。\n注释配置的是H2内存数据库，显式配置的是MySQL数据库。\n\n#### 使用嵌入式的数据源\n**嵌入式数据库（embedded database）**：每次重启应用或运行测试的时候，都能够重新填充测试数据。多用于开发和测试环境，它会预先加载一组测试数据。\n\n**使用jdbc命名空间配置嵌入式数据库**\n```xml\n<jdbc:embedded-database id=\"dataSource\" type=\"H2\">\n\t<jdbc:script localtion=\"classpath:xxx.sql\"/>\n\t<jdbc:script localtion=\"classpath:yyy.sql\"/>\n</jdbc:embedded-database>\n```\n在`<jdbc:embedded-database>`中,我们可以不配置也可以配置多个`<jdbc:script>`元素来搭建数据库。\n\n**使用Java配置嵌入式数据库**\n```java\n    @Bean\n    public DataSource dataSource3(){\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"\")\n                .addScript(\"\")\n                .build();\n    }\n```\n\n#### 使用profile选择数据源\n我们已经学习了多种配置数据源的方式，在正常的开发任务中，我们有不同的环境，也就有不同的数据源。\n\n例如,对于开发期来说,`<jdbc:embedded-database>`元素是很合适的,而在QA环境中,你可能希望使用DBCP的BasicDataSource,在生产部署环境下,可能需要使用`<jee:jndi-lookup>`。\n\n我们之前讨论的装配Bean profile特性恰好用在这儿。\n```java\n    /**\n     * Druid数据库连接池\n     *\n     * @return\n     */\n    @Profile(\"prod\")\n    @Bean\n    public DruidDataSource dataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        /*dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");*/\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/spittr\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"\");\n        dataSource.setInitialSize(5);\n        dataSource.setMaxActive(10);\n        return dataSource;\n    }\n\n    /**\n     * 配置Jdbc模板类\n     *\n     * @param druidDataSource\n     * @return\n     */\n    @Bean\n    public JdbcTemplate jdbcTemplate(DruidDataSource druidDataSource) {\n        return new JdbcTemplate(druidDataSource);\n    }\n\n    /**\n     * 基于JDBC驱动的数据源\n     * @return\n     */\n    @Profile(\"qa\")\n    @Bean\n    public DataSource dataSource2(){\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:~/test\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");;\n        return dataSource;\n    }\n\n    /**\n     * 嵌入式数据库\n     * @return\n     */\n    @Profile(\"dev\")\n    @Bean\n    public DataSource dataSource3(){\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .addScript(\"\")\n                .addScript(\"\")\n                .build();\n    }\n```\n\n### 2. 使用JDBC模板\nSpring将数据访问过程中固定的和可变的部分明确划分为两个不同的类：模板(template)和回调(callback)。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。\n\n**繁琐的JDBC代码**\n```java\n    public static void fun() throws SQLException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = getConnection();\n            //操作5（查看李四余额）\n            sql = \"select balance from account where name=?\";\n            pstmt = con.prepareStatement(sql);\n            pstmt.setString(1, \"ls\");\n            ResultSet rs = pstmt.executeQuery();\n            rs.next();\n            double balance = rs.getDouble(1);\n            //如果李四余额为负数，那么回滚到指定保存点\n            if(balance < 0) {\n                System.out.println(\"张三，你上当了！\");\n            }\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            if (!con.isClosed()){\n                con.close();\n            }\n        }\n    }\n```\n可以看到，我们每次都要进行connection创建，statement创建，执行语句，获取结果，一次关闭连接这些样板代码。\n\nSpring将数据访问的样板代码抽象到模板类之中。Spring为JDBC提供了三个模板类供选择：\n- **JdbcTemplate**:最基本的Spring JDBC模板,这个模板支持简单的JDBC数据库访问功能以及**基于索引参数**的查询;\n- **NamedParameterJdbcTemplate**:使用该模板类执行查询时可以将值**以命名参数的形式**绑定到SQL中,而不是使用简单的索引参数;\n- **SimpleJdbcTemplate**:该模板类利用Java 5的一些特性如自动装箱、泛型以及可变参数列表来简化JDBC模板的使用。\n\n以前,在选择哪一个JDBC模板的时候,我们需要仔细权衡。但是从Spring 3.1开始,做这个决定变得容易多了。SimpleJdbcTemplate已经被废弃了,其Java 5的特性被转移到了JdbcTemplate中,并且只有在你需要使用命名参数的时候,才需要使用NamedParameterJdbcTemplate。这样的话,对于大多数的JDBC任务来说,JdbcTemplate就是最好的可选方案。\n\n**配置JdbcTemplate**\n```java\n    @Bean\n    public JdbcTemplate jdbcTemplate(DruidDataSource druidDataSource) {\n        return new JdbcTemplate(druidDataSource);\n    }\n```\n\nJdbcTemplate主要提供一下五类方法：\n- execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\n- update方法：用于执行新增、修改、删除等语句；\n- batchUpdate方法用于执行批处理相关语句；\n- query方法及queryForXXX方法：用于执行查询相关语句；\n- call方法：用于执行存储过程、函数相关语句。\n\n**RowMapper接口**\n我们可以实现RowMapper接口的RowMapper()方法，这个方法会传入ResultSet和包含行号的整数。在实习类中创建自定义对象并填充对应的值。\n\n\n\n> 参考文献\n> [1] 《Spring实战》4th\n> [2] [Spring-jdbc：JdbcTemplate使用简介](https://blog.csdn.net/u013468917/article/details/52217954)\n> [3] [Spring之jdbcTemplate：查询的三种方式（单个值、单个对象、对象集合）](https://www.cnblogs.com/gongxr/p/8053010.html)\n\n","slug":"《Spring实战》Spring中使用JDBC","published":1,"updated":"2018-08-13T14:28:27.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5j002j6k159iymfdyi","content":"<p>为了避免持久化的逻辑分散到应用的各个组件中，最好将数据访问的功能放到一个或多个专注于此项任务的组件中。这样的组件通常称为数据访问对象（Data acess  object, DAO）或 Repository。<br><a id=\"more\"></a></p>\n<h3 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h3><p>Spring上下文中配置数据源bean提供了多种方式：</p>\n<ul>\n<li>通过JDBC驱动程序定义的数据源</li>\n<li>通过JNDI查找数据源配置</li>\n<li>连接池的数据源</li>\n</ul>\n<p>这里介绍第一和第三种方式。</p>\n<h4 id=\"通过JDBC驱动程序定义的数据源\"><a href=\"#通过JDBC驱动程序定义的数据源\" class=\"headerlink\" title=\"通过JDBC驱动程序定义的数据源\"></a>通过JDBC驱动程序定义的数据源</h4><p>在Spring中,通过JDBC驱动定义数据源是最简单的配置方式。Spring提供了三个这样的数据源类(均位于org.springframework.jdbc.datasource包中)供选择:</p>\n<ul>\n<li>DriverManagerDataSource:在每个连接请求时都会返回一个新建的连接。与DBCP的BasicDataSource不同,由DriverManagerDataSource提供的连接并没有进行池化管理;</li>\n<li>SimpleDriverDataSource:与DriverManagerDataSource的工作方式类似,但是它直接使用JDBC驱动,来解决在特定环境下的类加载问题,这样的环境包括OSGi容器;</li>\n<li>SingleConnectionDataSource:在每个连接请求时都会返回同一个的连接。尽管SingleConnectionDataSource不是严格意义上的连接池数据源,但是你可以将其视为只有一个连接的池。<br>这些数据源的配置与DBCP的配置类似。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于JDBC驱动的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:h2:~/test\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"sa\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>与具备池功能的数据源相比,唯一的区别在于这些数据源bean都没有提供连接池功能,所以没有可配置的池相关的属性。</p>\n<h4 id=\"使用数据源连接池\"><a href=\"#使用数据源连接池\" class=\"headerlink\" title=\"使用数据源连接池\"></a>使用数据源连接池</h4><p>常用的主流开源数据库连接池有C3P0、DBCP、Tomcat Jdbc Pool、BoneCP、Druid等</p>\n<p><strong>C3p0</strong>: 开源的JDBC连接池，实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。单线程，性能较差，适用于小型系统，代码600KB左右。</p>\n<p><strong>DBCP</strong> (Database Connection Pool):由Apache开发的一个Java数据库连接池项目， Jakarta commons-pool对象池机制，Tomcat使用的连接池组件就是DBCP。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar，预先将数据库连接放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完再放回。单线程，并发量低，性能不好，适用于小型系统。</p>\n<p><strong>Druid</strong>：Druid是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能，是一个可用于大数据实时查询和分析的高容错、高性能的开源分布式系统，尤其是当发生代码部署、机器故障以及其他产品系统遇到宕机等情况时，Druid仍能够保持100%正常运行。主要特色：为分析监控设计；快速的交互式查询；高可用；可扩展；Druid是一个开源项目，源码托管在github上。</p>\n<p>以DBCP连接池为例：<br>Java配置，连接池形式的DataSource Bean可以声明如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Druid数据库连接池</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DruidDataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\">    <span class=\"comment\">/*dataSource.setDriverClassName(\"org.h2.Driver\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUrl(\"jdbc:h2:~/test\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUsername(\"sa\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setPassword(\"\");*/</span></span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/spittr\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataSource.setInitialSize(<span class=\"number\">5</span>);</span><br><span class=\"line\">    dataSource.setMaxActive(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前四个属性是配置BasicDataSource所必需的。属性driverClassName指定了JDBC驱<br>动类的全限定类名，需要提前将对应数据库的驱动依赖jar包放置在classpath下。<br>注释配置的是H2内存数据库，显式配置的是MySQL数据库。</p>\n<h4 id=\"使用嵌入式的数据源\"><a href=\"#使用嵌入式的数据源\" class=\"headerlink\" title=\"使用嵌入式的数据源\"></a>使用嵌入式的数据源</h4><p><strong>嵌入式数据库（embedded database）</strong>：每次重启应用或运行测试的时候，都能够重新填充测试数据。多用于开发和测试环境，它会预先加载一组测试数据。</p>\n<p><strong>使用jdbc命名空间配置嵌入式数据库</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"H2\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"classpath:xxx.sql\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"classpath:yyy.sql\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">jdbc:embedded-database</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在<code>&lt;jdbc:embedded-database&gt;</code>中,我们可以不配置也可以配置多个<code>&lt;jdbc:script&gt;</code>元素来搭建数据库。</p>\n<p><strong>使用Java配置嵌入式数据库</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用profile选择数据源\"><a href=\"#使用profile选择数据源\" class=\"headerlink\" title=\"使用profile选择数据源\"></a>使用profile选择数据源</h4><p>我们已经学习了多种配置数据源的方式，在正常的开发任务中，我们有不同的环境，也就有不同的数据源。</p>\n<p>例如,对于开发期来说,<code>&lt;jdbc:embedded-database&gt;</code>元素是很合适的,而在QA环境中,你可能希望使用DBCP的BasicDataSource,在生产部署环境下,可能需要使用<code>&lt;jee:jndi-lookup&gt;</code>。</p>\n<p>我们之前讨论的装配Bean profile特性恰好用在这儿。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Druid数据库连接池</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"prod\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DruidDataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\">    <span class=\"comment\">/*dataSource.setDriverClassName(\"org.h2.Driver\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUrl(\"jdbc:h2:~/test\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUsername(\"sa\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setPassword(\"\");*/</span></span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/spittr\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataSource.setInitialSize(<span class=\"number\">5</span>);</span><br><span class=\"line\">    dataSource.setMaxActive(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 配置Jdbc模板类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> druidDataSource</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(druidDataSource);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于JDBC驱动的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"qa\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:h2:~/test\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"sa\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 嵌入式数据库</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-使用JDBC模板\"><a href=\"#2-使用JDBC模板\" class=\"headerlink\" title=\"2. 使用JDBC模板\"></a>2. 使用JDBC模板</h3><p>Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类：模板(template)和回调(callback)。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。</p>\n<p><strong>繁琐的JDBC代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        con = getConnection();</span><br><span class=\"line\">        <span class=\"comment\">//操作5（查看李四余额）</span></span><br><span class=\"line\">        sql = <span class=\"string\">\"select balance from account where name=?\"</span>;</span><br><span class=\"line\">        pstmt = con.prepareStatement(sql);</span><br><span class=\"line\">        pstmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">        ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">        rs.next();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> balance = rs.getDouble(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//如果李四余额为负数，那么回滚到指定保存点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(balance &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"张三，你上当了！\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                con.rollback();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!con.isClosed())&#123;</span><br><span class=\"line\">            con.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，我们每次都要进行connection创建，statement创建，执行语句，获取结果，一次关闭连接这些样板代码。</p>\n<p>Spring将数据访问的样板代码抽象到模板类之中。Spring为JDBC提供了三个模板类供选择：</p>\n<ul>\n<li><strong>JdbcTemplate</strong>:最基本的Spring JDBC模板,这个模板支持简单的JDBC数据库访问功能以及<strong>基于索引参数</strong>的查询;</li>\n<li><strong>NamedParameterJdbcTemplate</strong>:使用该模板类执行查询时可以将值<strong>以命名参数的形式</strong>绑定到SQL中,而不是使用简单的索引参数;</li>\n<li><strong>SimpleJdbcTemplate</strong>:该模板类利用Java 5的一些特性如自动装箱、泛型以及可变参数列表来简化JDBC模板的使用。</li>\n</ul>\n<p>以前,在选择哪一个JDBC模板的时候,我们需要仔细权衡。但是从Spring 3.1开始,做这个决定变得容易多了。SimpleJdbcTemplate已经被废弃了,其Java 5的特性被转移到了JdbcTemplate中,并且只有在你需要使用命名参数的时候,才需要使用NamedParameterJdbcTemplate。这样的话,对于大多数的JDBC任务来说,JdbcTemplate就是最好的可选方案。</p>\n<p><strong>配置JdbcTemplate</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(druidDataSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JdbcTemplate主要提供一下五类方法：</p>\n<ul>\n<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>\n<li>update方法：用于执行新增、修改、删除等语句；</li>\n<li>batchUpdate方法用于执行批处理相关语句；</li>\n<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>\n<li>call方法：用于执行存储过程、函数相关语句。</li>\n</ul>\n<p><strong>RowMapper接口</strong><br>我们可以实现RowMapper接口的RowMapper()方法，这个方法会传入ResultSet和包含行号的整数。在实习类中创建自定义对象并填充对应的值。</p>\n<blockquote>\n<p>参考文献<br>[1] 《Spring实战》4th<br>[2] <a href=\"https://blog.csdn.net/u013468917/article/details/52217954\" target=\"_blank\" rel=\"noopener\">Spring-jdbc：JdbcTemplate使用简介</a><br>[3] <a href=\"https://www.cnblogs.com/gongxr/p/8053010.html\" target=\"_blank\" rel=\"noopener\">Spring之jdbcTemplate：查询的三种方式（单个值、单个对象、对象集合）</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>为了避免持久化的逻辑分散到应用的各个组件中，最好将数据访问的功能放到一个或多个专注于此项任务的组件中。这样的组件通常称为数据访问对象（Data acess  object, DAO）或 Repository。<br>","more":"</p>\n<h3 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h3><p>Spring上下文中配置数据源bean提供了多种方式：</p>\n<ul>\n<li>通过JDBC驱动程序定义的数据源</li>\n<li>通过JNDI查找数据源配置</li>\n<li>连接池的数据源</li>\n</ul>\n<p>这里介绍第一和第三种方式。</p>\n<h4 id=\"通过JDBC驱动程序定义的数据源\"><a href=\"#通过JDBC驱动程序定义的数据源\" class=\"headerlink\" title=\"通过JDBC驱动程序定义的数据源\"></a>通过JDBC驱动程序定义的数据源</h4><p>在Spring中,通过JDBC驱动定义数据源是最简单的配置方式。Spring提供了三个这样的数据源类(均位于org.springframework.jdbc.datasource包中)供选择:</p>\n<ul>\n<li>DriverManagerDataSource:在每个连接请求时都会返回一个新建的连接。与DBCP的BasicDataSource不同,由DriverManagerDataSource提供的连接并没有进行池化管理;</li>\n<li>SimpleDriverDataSource:与DriverManagerDataSource的工作方式类似,但是它直接使用JDBC驱动,来解决在特定环境下的类加载问题,这样的环境包括OSGi容器;</li>\n<li>SingleConnectionDataSource:在每个连接请求时都会返回同一个的连接。尽管SingleConnectionDataSource不是严格意义上的连接池数据源,但是你可以将其视为只有一个连接的池。<br>这些数据源的配置与DBCP的配置类似。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于JDBC驱动的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:h2:~/test\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"sa\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>与具备池功能的数据源相比,唯一的区别在于这些数据源bean都没有提供连接池功能,所以没有可配置的池相关的属性。</p>\n<h4 id=\"使用数据源连接池\"><a href=\"#使用数据源连接池\" class=\"headerlink\" title=\"使用数据源连接池\"></a>使用数据源连接池</h4><p>常用的主流开源数据库连接池有C3P0、DBCP、Tomcat Jdbc Pool、BoneCP、Druid等</p>\n<p><strong>C3p0</strong>: 开源的JDBC连接池，实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。单线程，性能较差，适用于小型系统，代码600KB左右。</p>\n<p><strong>DBCP</strong> (Database Connection Pool):由Apache开发的一个Java数据库连接池项目， Jakarta commons-pool对象池机制，Tomcat使用的连接池组件就是DBCP。单独使用dbcp需要3个包：common-dbcp.jar,common-pool.jar,common-collections.jar，预先将数据库连接放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完再放回。单线程，并发量低，性能不好，适用于小型系统。</p>\n<p><strong>Druid</strong>：Druid是Java语言中最好的数据库连接池，Druid能够提供强大的监控和扩展功能，是一个可用于大数据实时查询和分析的高容错、高性能的开源分布式系统，尤其是当发生代码部署、机器故障以及其他产品系统遇到宕机等情况时，Druid仍能够保持100%正常运行。主要特色：为分析监控设计；快速的交互式查询；高可用；可扩展；Druid是一个开源项目，源码托管在github上。</p>\n<p>以DBCP连接池为例：<br>Java配置，连接池形式的DataSource Bean可以声明如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Druid数据库连接池</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DruidDataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\">    <span class=\"comment\">/*dataSource.setDriverClassName(\"org.h2.Driver\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUrl(\"jdbc:h2:~/test\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUsername(\"sa\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setPassword(\"\");*/</span></span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/spittr\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataSource.setInitialSize(<span class=\"number\">5</span>);</span><br><span class=\"line\">    dataSource.setMaxActive(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>前四个属性是配置BasicDataSource所必需的。属性driverClassName指定了JDBC驱<br>动类的全限定类名，需要提前将对应数据库的驱动依赖jar包放置在classpath下。<br>注释配置的是H2内存数据库，显式配置的是MySQL数据库。</p>\n<h4 id=\"使用嵌入式的数据源\"><a href=\"#使用嵌入式的数据源\" class=\"headerlink\" title=\"使用嵌入式的数据源\"></a>使用嵌入式的数据源</h4><p><strong>嵌入式数据库（embedded database）</strong>：每次重启应用或运行测试的时候，都能够重新填充测试数据。多用于开发和测试环境，它会预先加载一组测试数据。</p>\n<p><strong>使用jdbc命名空间配置嵌入式数据库</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jdbc:embedded-database</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"H2\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"classpath:xxx.sql\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">jdbc:script</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"classpath:yyy.sql\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">jdbc:embedded-database</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>在<code>&lt;jdbc:embedded-database&gt;</code>中,我们可以不配置也可以配置多个<code>&lt;jdbc:script&gt;</code>元素来搭建数据库。</p>\n<p><strong>使用Java配置嵌入式数据库</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用profile选择数据源\"><a href=\"#使用profile选择数据源\" class=\"headerlink\" title=\"使用profile选择数据源\"></a>使用profile选择数据源</h4><p>我们已经学习了多种配置数据源的方式，在正常的开发任务中，我们有不同的环境，也就有不同的数据源。</p>\n<p>例如,对于开发期来说,<code>&lt;jdbc:embedded-database&gt;</code>元素是很合适的,而在QA环境中,你可能希望使用DBCP的BasicDataSource,在生产部署环境下,可能需要使用<code>&lt;jee:jndi-lookup&gt;</code>。</p>\n<p>我们之前讨论的装配Bean profile特性恰好用在这儿。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Druid数据库连接池</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"prod\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DruidDataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\">    <span class=\"comment\">/*dataSource.setDriverClassName(\"org.h2.Driver\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUrl(\"jdbc:h2:~/test\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setUsername(\"sa\");</span></span><br><span class=\"line\"><span class=\"comment\">    dataSource.setPassword(\"\");*/</span></span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/spittr\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataSource.setInitialSize(<span class=\"number\">5</span>);</span><br><span class=\"line\">    dataSource.setMaxActive(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 配置Jdbc模板类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> druidDataSource</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(druidDataSource);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于JDBC驱动的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"qa\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">    dataSource.setDriverClassName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">    dataSource.setUrl(<span class=\"string\">\"jdbc:h2:~/test\"</span>);</span><br><span class=\"line\">    dataSource.setUsername(<span class=\"string\">\"sa\"</span>);</span><br><span class=\"line\">    dataSource.setPassword(<span class=\"string\">\"\"</span>);;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 嵌入式数据库</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Profile</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder()</span><br><span class=\"line\">            .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .addScript(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-使用JDBC模板\"><a href=\"#2-使用JDBC模板\" class=\"headerlink\" title=\"2. 使用JDBC模板\"></a>2. 使用JDBC模板</h3><p>Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类：模板(template)和回调(callback)。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。</p>\n<p><strong>繁琐的JDBC代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        con = getConnection();</span><br><span class=\"line\">        <span class=\"comment\">//操作5（查看李四余额）</span></span><br><span class=\"line\">        sql = <span class=\"string\">\"select balance from account where name=?\"</span>;</span><br><span class=\"line\">        pstmt = con.prepareStatement(sql);</span><br><span class=\"line\">        pstmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">        ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">        rs.next();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> balance = rs.getDouble(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//如果李四余额为负数，那么回滚到指定保存点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(balance &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"张三，你上当了！\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                con.rollback();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!con.isClosed())&#123;</span><br><span class=\"line\">            con.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，我们每次都要进行connection创建，statement创建，执行语句，获取结果，一次关闭连接这些样板代码。</p>\n<p>Spring将数据访问的样板代码抽象到模板类之中。Spring为JDBC提供了三个模板类供选择：</p>\n<ul>\n<li><strong>JdbcTemplate</strong>:最基本的Spring JDBC模板,这个模板支持简单的JDBC数据库访问功能以及<strong>基于索引参数</strong>的查询;</li>\n<li><strong>NamedParameterJdbcTemplate</strong>:使用该模板类执行查询时可以将值<strong>以命名参数的形式</strong>绑定到SQL中,而不是使用简单的索引参数;</li>\n<li><strong>SimpleJdbcTemplate</strong>:该模板类利用Java 5的一些特性如自动装箱、泛型以及可变参数列表来简化JDBC模板的使用。</li>\n</ul>\n<p>以前,在选择哪一个JDBC模板的时候,我们需要仔细权衡。但是从Spring 3.1开始,做这个决定变得容易多了。SimpleJdbcTemplate已经被废弃了,其Java 5的特性被转移到了JdbcTemplate中,并且只有在你需要使用命名参数的时候,才需要使用NamedParameterJdbcTemplate。这样的话,对于大多数的JDBC任务来说,JdbcTemplate就是最好的可选方案。</p>\n<p><strong>配置JdbcTemplate</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(druidDataSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>JdbcTemplate主要提供一下五类方法：</p>\n<ul>\n<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>\n<li>update方法：用于执行新增、修改、删除等语句；</li>\n<li>batchUpdate方法用于执行批处理相关语句；</li>\n<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>\n<li>call方法：用于执行存储过程、函数相关语句。</li>\n</ul>\n<p><strong>RowMapper接口</strong><br>我们可以实现RowMapper接口的RowMapper()方法，这个方法会传入ResultSet和包含行号的整数。在实习类中创建自定义对象并填充对应的值。</p>\n<blockquote>\n<p>参考文献<br>[1] 《Spring实战》4th<br>[2] <a href=\"https://blog.csdn.net/u013468917/article/details/52217954\" target=\"_blank\" rel=\"noopener\">Spring-jdbc：JdbcTemplate使用简介</a><br>[3] <a href=\"https://www.cnblogs.com/gongxr/p/8053010.html\" target=\"_blank\" rel=\"noopener\">Spring之jdbcTemplate：查询的三种方式（单个值、单个对象、对象集合）</a></p>\n</blockquote>"},{"toc":true,"title":"《Spring实战》Web中的Spring","date":"2018-04-10T02:58:29.000Z","_content":"\n在上一篇博客中我们简单介绍了如何搭建一个最简单的Spring MVC，现在我们来学习一下Spring的其他Web功能。为了方便学习，我将自己学习时敲下的源码放到了github上：https://github.com/cap-ljf/Spittr\n<!--more-->\n本文内容对应《Spring实战》第二部分 Web中的Spring 内容：\n- JavaConfig配置Spring MVC\n- Spring MVC数据绑定\n- JSR 303数据校验\n- Spring Web视图渲染之Thymeleaf\n- JavaConfig配置自定义Servlet和Filter\n- 文件上传\n- 统一异常处理\n\n\n### 1. JavaConfig配置Spring MVC\n[《Spring实战》搭建Spring MVC](http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/)\n\n### 2. 数据绑定入门\n[[Spring MVC] - SpringMVC的各种参数绑定方式](https://www.cnblogs.com/HD/p/4107674.html)\n[SpringMVC数据绑定入门](https://www.imooc.com/learn/558)\n\n### 3. JSR 303数据校验\n在了解了数据绑定之后，大部分时候我们都需要校验接受到的数据。有种处理校验的方式非常初级，那就是在controller或service方法中添加代码来检查值的合法性，如果值不合法的话，就将注册表单重新显示给用户。但是这样的校验逻辑会弄乱我们的controller方法。从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持（JSR-303）。\n\n使用JSR 303需要两个jar包依赖。\n```xml\n\t\t<!-- JSR303校验 -->\n        <dependency>\n            <groupId>javax.validation</groupId>\n            <artifactId>validation-api</artifactId>\n            <version>2.0.1.Final</version>\n        </dependency>\n        <dependency>\n            <groupId>org.hibernate</groupId>\n            <artifactId>hibernate-validator</artifactId>\n            <version>5.3.6.Final</version>\n        </dependency>\n```\n**Bean Validation中内置的constraint**\n![Alt text](https://app.yinxiang.com/shard/s15/res/e7d4563c-a6bc-4a99-926a-55d052fc28ec/1523324310124.png)\n**Hibernate Validator 附加的 constraint**\n![Alt text](https://app.yinxiang.com/shard/s15/res/9b50d558-e179-465d-818f-ff0a415cf77e/1523324344858.png)\n\n有些时候，你可能需要更复杂的constraint，Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现：\n- 组合现有的 constraint 来生成一个更复杂的 constraint\n```java\n@NotNull\n@Size(min = 5, max = 10)\nprivate String username;\n```\n- 自定义constraint。\n定义的`IntegerRange`注解。自定义constraint注解，message、groups和payload三个属性是必须定义的。\n```java\npackage com.jifang.spittr.annotation;\n\nimport com.jifang.spittr.validator.IntegerRangeValidator;\n\nimport javax.validation.Constraint;\nimport javax.validation.Payload;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = IntegerRangeValidator.class)\npublic @interface IntegerRange {\n    String message() default \"校验失败\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n    int min();\n    int max();\n}\n```\n定义验证类\n```java\npackage com.jifang.spittr.validator;\n\nimport com.jifang.spittr.annotation.IntegerRange;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n/**\n * author: jifang\n * date: 18-4-9 下午11:08\n */\npublic class IntegerRangeValidator implements ConstraintValidator<IntegerRange, Integer> {\n    private Integer min;\n    private Integer max;\n\n    public void initialize(IntegerRange constraintAnnotation) {\n        min = constraintAnnotation.min();\n        max = constraintAnnotation.max();\n    }\n\n    public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) {\n        boolean b = integer > min && integer < max ? true : false;\n        return b;\n    }\n}\n```\nConstraintValidator使用了泛型，有两个类型参数。第一个类型是对应的initialize方法的参数类型（约束注解类型），第二个类型是对应的isValid方法的第一个参数类型。\n\n\n### 4.Spring Web视图渲染之Thymeleaf\n将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。\nSpring自带了13个视图解析器，能够将逻辑视图名转换为物理实现。\n![Alt text](https://app.yinxiang.com/shard/s15/res/eb8d5dab-3036-4eb0-9eb5-a2a40b2b8b14/1523325208325.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/f304df0e-d997-4cfb-aa65-8cca5dcc6a82/1523325213803.png)\n在[上一篇博文](http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/)我们介绍了`InternalResourceViewResolver`将视图解析为JSP。这一次我们使用新的项目`Thymeleaf`来配置实现视图解析。\n```java\n/**\n     * 配置生成模板解析器\n     *\n     * @return\n     */\n    @Bean\n    public TemplateResolver templateResolver() {\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver();\n        templateResolver.setPrefix(\"/WEB-INF/templates/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML5\");\n        return templateResolver;\n    }\n\n    /**\n     * 生成模板引擎并为模板引擎注入模板解析器\n     *\n     * @param templateResolver\n     * @return\n     */\n    @Bean\n    public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    /**\n     * 生成视图解析器并为解析器注入引擎\n     *\n     * @param templateEngine\n     * @return\n     */\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n```\n需要注意的是ThymeleafViewResolver bean中注入了一个对SpringTemplate Engine bean的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎,用来解析模板,并基于这些模板渲染结果。可以看到,我们为其注入了一个TemplateResolver bean的引用。\n\nThymeleaf在很大程度上就是HTML文件,与JSP不同,它没有什么特殊的标签或标签库。要使用Thymeleaf的标签库，需要声明Thymeleaf的命名空间\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" \nxmlns:th=\"http://thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>Spittr</title>\n    <link rel=\"stylesheet\"\n          type=\"text/css\"\n          th:href=\"@{/resources/style.css}\"/>\n</head>\n<body>\n<h1>Welcome to Spitter</h1>\n<a th:href=\"@{/spittles}\">Spittles</a>\n<a th:href=\"@{/spitter/register}\">Register</a>\n<br/>\n<a th:href=\"@{/databind}\">databind</a>\n<a th:href=\"@{/upload}\">upload</a>\n</body>\n</html>\n```\n关于Thymeleaf可以参考\nhttp://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0\n\n### 5.JavaConfig配置自定义Servlet和Filter\n实现了WebApplicationInitializer接口的类会被自动加载。我们可以在`onStartup`中添加自定义的Servlet和Filter。\n```java\npackage com.jifang.spittr.config;\n\nimport com.jifang.spittr.filter.MyFilter;\nimport com.jifang.spittr.servlet.MyServlet;\nimport org.springframework.web.WebApplicationInitializer;\nimport javax.servlet.*;\nimport java.util.EnumSet;\n\n/**\n * 通过实现WebApplicationInitializer来配置额外的Servlet和Filter\n * author: jifang\n * date: 18-4-9 下午3:39\n */\n\npublic class MyServletInitializer implements WebApplicationInitializer {\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        //配置自己的Servlet\n        ServletRegistration.Dynamic myServlet = servletContext.addServlet(\"myServlet\", MyServlet.class);\n        myServlet.setLoadOnStartup(1);\n        myServlet.addMapping(\"/myServlet/*\");\n        //配置自己的Filter\n        FilterRegistration.Dynamic myFilter = servletContext.addFilter(\"myFilter\", MyFilter.class);\n        myFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true, \"myServlet\");\n    }\n}\n```\n\n### 6.文件上传\n一般表单提交所形成的请求结果是很简单的,就是以“&”符分割的多个name-value对。尽管这种编码形式很简单,并且对于典型的基于文本的表单提交也足够满足要求,但是对于传送二进制数据,如上传图片,就显得力不从心了。与之不同的,multipart格式的数据会将一个表单拆分为多个部分(part),每个部分对应一个输入域。在一般的表单输入域中,它所对应的部分中会放置文本型数据,但是如果上传文件的话,它所对应的部分可以是二进制。\n\n#### 6.1 MultiPart形式的数据\nMultipart格式数据会将一个表单拆分为多个部分(part)，每个部分对应一个输入域。在一般的表单输入域中，它对应的部分会放置文本型数据，如果是文件上传形式，它对应的部分可以是二进制。\n#### 6.2 Multipart/form-data请求方式\n示例：\n```\n<form action=\"/spittles/upload.do\" method=\"POST\" th:object=\"${spittr}\" enctype=\"multipart/form-data\">\n    <label>Profile Picture</label>:\n    <input type=\"file\" name=\"profilePicture\" accept=\"image/jpeg,image/png,image/gif\"/><br/>\n    <input type=\"submit\" value=\"save\"/>\n</form>\n```\n#### 6.3 SpringMVC处理Multipart数据\nxml配置可以参考：https://www.cnblogs.com/maying3010/p/6679974.html\n下面介绍JavaConfig配置：\n**配置multipart解析器**\nDispatcherServlet并没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中MultipartResolver策略接口的实现,通过这个实现类来解析multipart请求中的内容。从Spring 3.1开始,Spring内置了两个MultipartResolver的实现供我们选择:\n- CommonsMultipartResolver:使用Jakarta Commons FileUpload解析multipart请求;\n- StandardServletMultipartResolver:依赖于Servlet 3.0对multipart请求的支持(始于Spring 3.1)。\n\n一般来讲,在这两者之间,StandardServletMultipartResolver可能会是优选的方案。它使用Servlet所提供的功能支持,并不需要依赖任何其他的项目。如果我们需要将应用部署到Servlet 3.0之前的容器中,或者还没有使用Spring 3.1或更高版本,那么可能就需要CommonsMultipartResolver了。\n兼容Servlet 3.0的StandardServletMultipartResolver没有构造器参数,也没有要设置的属性。\n```java\n\t@Bean\n    public MultipartResolver multipartResolver() {\n        return new StandardServletMultipartResolver();\n    }\n```\n我们不能在Spring中配置StandardServletMultipartResolver的限制条件，而是要在Servlet中指定multipart的配置。\n\n如果我们采用Servlet初始化类的方式来配置DispatcherServlet的话，这个初始化类应该已经实现了WebApplicationInitializer，那我们可以在`ServletRegistration.Dynamic`上调用`setMultipartConfig()`方法，传入MultipartConfigElement实例。如果我们配置DispatcherServlet的Servlet初始化类继承了AbstractAnnotationConfigDispatcherServletInitializer类的话，那么我们不会直接创建DispatcherServlet实例并将其注册到Servlet上下文中。这样的话,将不会有对Dynamic Servlet registration的引用供我们使用了。但是,我们可以通过重载customizeRegistration()方法(它会得到一个Dynamic作为参数)来配置multipart的具体细节:\n```java\n/**\n     * 配置multipart的具体细节\n     *\n     * @param registration\n     */\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n        registration.setMultipartConfig(new MultipartConfigElement(\"/home/jifang/spittr/uploads\", 2097152, 4194304, 0));\n    }\n```\n除了临时路径的位置,其他的构造器所能接受的参数如下:\n- 上传文件的最大容量(以字节为单位)。默认是没有限制的。\n- 整个multipart请求的最大容量(以字节为单位),不会关心有多少个part以及每个part的大小。默认是没有限制的。\n- 在上传的过程中,如果文件大小达到了一个指定最大容量(以字节为单位),将会写入到临时文件路径中。默认值为0,也就是所有上传的文件都会写入到磁盘上。\n\n**处理multipart请求**\n1. 使用byte[] 数组\n2. 使用上传文件的原始byte比较简单但是功能有限。因此,Spring还提供了MultipartFile接口,它为处理multipart数据提供了内容更为丰富的对象。\n```java\npublic interface MultipartFile extends InputStreamSource {\n    String getName();\n\n    String getOriginalFilename();\n\n    String getContentType();\n\n    boolean isEmpty();\n\n    long getSize();\n\n    byte[] getBytes() throws IOException;\n\n    InputStream getInputStream() throws IOException;\n\n    void transferTo(File var1) throws IOException, IllegalStateException;\n}\n```\n在controller里保存上传的文件\n```java\n@RequestMapping(\"upload.do\")\n    public String upload(@RequestPart(\"profilePicture\") MultipartFile profilePicture) throws IOException {\n        File file = new File(\"/home/jifang/spittr/uploads/\");\n        if (!file.exists() && !file.isDirectory()) {\n            file.mkdir();\n        }\n        profilePicture.transferTo(new File(\"/home/jifang/spittr/uploads/\" + profilePicture.getOriginalFilename()));\n        return \"home\";\n    }\n```\n\n### 7. 异常处理\n不管请求成功或失败，Servlet请求的输出都是一个Servlet相应。异常必须要以某种方式转换为响应。\n\nSpring提供了多种方式将异常转换为响应：\n- 特定的Spring异常将会自动映射为指定的HTTP状态码;\n- 异常上可以添加@ResponseStatus注解,从而将其映射为某一个HTTP状态码;\n- 在方法上可以添加@ExceptionHandler注解,使其用来处理异常。\n\n#### 7.1 将异常对象映射为HTTP状态码（@ResponseStatus）\nSpring默认会将自身抛出的异常自动映射到合适的状态码，如下是一些示例：\n![Alt text](https://app.yinxiang.com/shard/s15/res/df5202a1-79e7-4677-956f-234e1879e86f/1523328457188.png)\n也可以通过@ResponseStatus注解将自定义异常映射为HTTP状态码。\n```java\n@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"Spittle Not Found\")\npublic class SpittleNotFoundException extends RuntimeException {\n}\n```\n在引入@ResponseStatus注解之后,如果控制器方法抛出SpittleNotFoundException异常的话,响应将会具有404状态码,这是因为Spittle Not Found。\n\n#### 7.2 本地处理@ExceptionHandler\n`@ExceptionHandler(SpittleNotFoundException.class)`，当抛出\nSpittleNotFoundException异常的时候,将会委托该方法来处理。\n```java\n\t@ExceptionHandler(SpittleNotFoundException.class)\n    public String spittleNotFoundHandler() {\n        return \"error/spittleNotFound\";\n    }\n```\n这个方法现在只能处理它所属类的方法抛出的异常，如果要处理程序中所有的会抛出该异常的controller，那么可以使用通知（@ControllerAdvice）\n#### 7.3 全局处理@ControllerAdvice\n在带有@ControllerAdvice注解的类中,以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。\n @ControllerAdvice注解本身已经使用了@Component,因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到,就像带有@Component注解的类一样。\n```java\n@ControllerAdvice\npublic class AppWideExceptionHandler {\n    @ExceptionHandler(SpittleNotFoundException.class)\n    public String spittleNotFoundHandler() {\n        return \"error/spittleNotFound\";\n    }\n}\n```\n\n\n> 参考文献\n> [1] [Java数据校验(Bean Validation / JSR303)](https://www.cnblogs.com/pixy/p/5306567.html)\n> [2] 《Spring实战》4th","source":"_posts/《Spring实战》Web中的Spring.md","raw":"---\ntoc: true\ntitle: 《Spring实战》Web中的Spring\ndate: 2018-04-10 10:58:29\ntags: [Spring MVC]\n---\n\n在上一篇博客中我们简单介绍了如何搭建一个最简单的Spring MVC，现在我们来学习一下Spring的其他Web功能。为了方便学习，我将自己学习时敲下的源码放到了github上：https://github.com/cap-ljf/Spittr\n<!--more-->\n本文内容对应《Spring实战》第二部分 Web中的Spring 内容：\n- JavaConfig配置Spring MVC\n- Spring MVC数据绑定\n- JSR 303数据校验\n- Spring Web视图渲染之Thymeleaf\n- JavaConfig配置自定义Servlet和Filter\n- 文件上传\n- 统一异常处理\n\n\n### 1. JavaConfig配置Spring MVC\n[《Spring实战》搭建Spring MVC](http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/)\n\n### 2. 数据绑定入门\n[[Spring MVC] - SpringMVC的各种参数绑定方式](https://www.cnblogs.com/HD/p/4107674.html)\n[SpringMVC数据绑定入门](https://www.imooc.com/learn/558)\n\n### 3. JSR 303数据校验\n在了解了数据绑定之后，大部分时候我们都需要校验接受到的数据。有种处理校验的方式非常初级，那就是在controller或service方法中添加代码来检查值的合法性，如果值不合法的话，就将注册表单重新显示给用户。但是这样的校验逻辑会弄乱我们的controller方法。从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持（JSR-303）。\n\n使用JSR 303需要两个jar包依赖。\n```xml\n\t\t<!-- JSR303校验 -->\n        <dependency>\n            <groupId>javax.validation</groupId>\n            <artifactId>validation-api</artifactId>\n            <version>2.0.1.Final</version>\n        </dependency>\n        <dependency>\n            <groupId>org.hibernate</groupId>\n            <artifactId>hibernate-validator</artifactId>\n            <version>5.3.6.Final</version>\n        </dependency>\n```\n**Bean Validation中内置的constraint**\n![Alt text](https://app.yinxiang.com/shard/s15/res/e7d4563c-a6bc-4a99-926a-55d052fc28ec/1523324310124.png)\n**Hibernate Validator 附加的 constraint**\n![Alt text](https://app.yinxiang.com/shard/s15/res/9b50d558-e179-465d-818f-ff0a415cf77e/1523324344858.png)\n\n有些时候，你可能需要更复杂的constraint，Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现：\n- 组合现有的 constraint 来生成一个更复杂的 constraint\n```java\n@NotNull\n@Size(min = 5, max = 10)\nprivate String username;\n```\n- 自定义constraint。\n定义的`IntegerRange`注解。自定义constraint注解，message、groups和payload三个属性是必须定义的。\n```java\npackage com.jifang.spittr.annotation;\n\nimport com.jifang.spittr.validator.IntegerRangeValidator;\n\nimport javax.validation.Constraint;\nimport javax.validation.Payload;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = IntegerRangeValidator.class)\npublic @interface IntegerRange {\n    String message() default \"校验失败\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n    int min();\n    int max();\n}\n```\n定义验证类\n```java\npackage com.jifang.spittr.validator;\n\nimport com.jifang.spittr.annotation.IntegerRange;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n/**\n * author: jifang\n * date: 18-4-9 下午11:08\n */\npublic class IntegerRangeValidator implements ConstraintValidator<IntegerRange, Integer> {\n    private Integer min;\n    private Integer max;\n\n    public void initialize(IntegerRange constraintAnnotation) {\n        min = constraintAnnotation.min();\n        max = constraintAnnotation.max();\n    }\n\n    public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) {\n        boolean b = integer > min && integer < max ? true : false;\n        return b;\n    }\n}\n```\nConstraintValidator使用了泛型，有两个类型参数。第一个类型是对应的initialize方法的参数类型（约束注解类型），第二个类型是对应的isValid方法的第一个参数类型。\n\n\n### 4.Spring Web视图渲染之Thymeleaf\n将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。\nSpring自带了13个视图解析器，能够将逻辑视图名转换为物理实现。\n![Alt text](https://app.yinxiang.com/shard/s15/res/eb8d5dab-3036-4eb0-9eb5-a2a40b2b8b14/1523325208325.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/f304df0e-d997-4cfb-aa65-8cca5dcc6a82/1523325213803.png)\n在[上一篇博文](http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/)我们介绍了`InternalResourceViewResolver`将视图解析为JSP。这一次我们使用新的项目`Thymeleaf`来配置实现视图解析。\n```java\n/**\n     * 配置生成模板解析器\n     *\n     * @return\n     */\n    @Bean\n    public TemplateResolver templateResolver() {\n        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver();\n        templateResolver.setPrefix(\"/WEB-INF/templates/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML5\");\n        return templateResolver;\n    }\n\n    /**\n     * 生成模板引擎并为模板引擎注入模板解析器\n     *\n     * @param templateResolver\n     * @return\n     */\n    @Bean\n    public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    /**\n     * 生成视图解析器并为解析器注入引擎\n     *\n     * @param templateEngine\n     * @return\n     */\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    }\n```\n需要注意的是ThymeleafViewResolver bean中注入了一个对SpringTemplate Engine bean的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎,用来解析模板,并基于这些模板渲染结果。可以看到,我们为其注入了一个TemplateResolver bean的引用。\n\nThymeleaf在很大程度上就是HTML文件,与JSP不同,它没有什么特殊的标签或标签库。要使用Thymeleaf的标签库，需要声明Thymeleaf的命名空间\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" \nxmlns:th=\"http://thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>Spittr</title>\n    <link rel=\"stylesheet\"\n          type=\"text/css\"\n          th:href=\"@{/resources/style.css}\"/>\n</head>\n<body>\n<h1>Welcome to Spitter</h1>\n<a th:href=\"@{/spittles}\">Spittles</a>\n<a th:href=\"@{/spitter/register}\">Register</a>\n<br/>\n<a th:href=\"@{/databind}\">databind</a>\n<a th:href=\"@{/upload}\">upload</a>\n</body>\n</html>\n```\n关于Thymeleaf可以参考\nhttp://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0\n\n### 5.JavaConfig配置自定义Servlet和Filter\n实现了WebApplicationInitializer接口的类会被自动加载。我们可以在`onStartup`中添加自定义的Servlet和Filter。\n```java\npackage com.jifang.spittr.config;\n\nimport com.jifang.spittr.filter.MyFilter;\nimport com.jifang.spittr.servlet.MyServlet;\nimport org.springframework.web.WebApplicationInitializer;\nimport javax.servlet.*;\nimport java.util.EnumSet;\n\n/**\n * 通过实现WebApplicationInitializer来配置额外的Servlet和Filter\n * author: jifang\n * date: 18-4-9 下午3:39\n */\n\npublic class MyServletInitializer implements WebApplicationInitializer {\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        //配置自己的Servlet\n        ServletRegistration.Dynamic myServlet = servletContext.addServlet(\"myServlet\", MyServlet.class);\n        myServlet.setLoadOnStartup(1);\n        myServlet.addMapping(\"/myServlet/*\");\n        //配置自己的Filter\n        FilterRegistration.Dynamic myFilter = servletContext.addFilter(\"myFilter\", MyFilter.class);\n        myFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), true, \"myServlet\");\n    }\n}\n```\n\n### 6.文件上传\n一般表单提交所形成的请求结果是很简单的,就是以“&”符分割的多个name-value对。尽管这种编码形式很简单,并且对于典型的基于文本的表单提交也足够满足要求,但是对于传送二进制数据,如上传图片,就显得力不从心了。与之不同的,multipart格式的数据会将一个表单拆分为多个部分(part),每个部分对应一个输入域。在一般的表单输入域中,它所对应的部分中会放置文本型数据,但是如果上传文件的话,它所对应的部分可以是二进制。\n\n#### 6.1 MultiPart形式的数据\nMultipart格式数据会将一个表单拆分为多个部分(part)，每个部分对应一个输入域。在一般的表单输入域中，它对应的部分会放置文本型数据，如果是文件上传形式，它对应的部分可以是二进制。\n#### 6.2 Multipart/form-data请求方式\n示例：\n```\n<form action=\"/spittles/upload.do\" method=\"POST\" th:object=\"${spittr}\" enctype=\"multipart/form-data\">\n    <label>Profile Picture</label>:\n    <input type=\"file\" name=\"profilePicture\" accept=\"image/jpeg,image/png,image/gif\"/><br/>\n    <input type=\"submit\" value=\"save\"/>\n</form>\n```\n#### 6.3 SpringMVC处理Multipart数据\nxml配置可以参考：https://www.cnblogs.com/maying3010/p/6679974.html\n下面介绍JavaConfig配置：\n**配置multipart解析器**\nDispatcherServlet并没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中MultipartResolver策略接口的实现,通过这个实现类来解析multipart请求中的内容。从Spring 3.1开始,Spring内置了两个MultipartResolver的实现供我们选择:\n- CommonsMultipartResolver:使用Jakarta Commons FileUpload解析multipart请求;\n- StandardServletMultipartResolver:依赖于Servlet 3.0对multipart请求的支持(始于Spring 3.1)。\n\n一般来讲,在这两者之间,StandardServletMultipartResolver可能会是优选的方案。它使用Servlet所提供的功能支持,并不需要依赖任何其他的项目。如果我们需要将应用部署到Servlet 3.0之前的容器中,或者还没有使用Spring 3.1或更高版本,那么可能就需要CommonsMultipartResolver了。\n兼容Servlet 3.0的StandardServletMultipartResolver没有构造器参数,也没有要设置的属性。\n```java\n\t@Bean\n    public MultipartResolver multipartResolver() {\n        return new StandardServletMultipartResolver();\n    }\n```\n我们不能在Spring中配置StandardServletMultipartResolver的限制条件，而是要在Servlet中指定multipart的配置。\n\n如果我们采用Servlet初始化类的方式来配置DispatcherServlet的话，这个初始化类应该已经实现了WebApplicationInitializer，那我们可以在`ServletRegistration.Dynamic`上调用`setMultipartConfig()`方法，传入MultipartConfigElement实例。如果我们配置DispatcherServlet的Servlet初始化类继承了AbstractAnnotationConfigDispatcherServletInitializer类的话，那么我们不会直接创建DispatcherServlet实例并将其注册到Servlet上下文中。这样的话,将不会有对Dynamic Servlet registration的引用供我们使用了。但是,我们可以通过重载customizeRegistration()方法(它会得到一个Dynamic作为参数)来配置multipart的具体细节:\n```java\n/**\n     * 配置multipart的具体细节\n     *\n     * @param registration\n     */\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n        registration.setMultipartConfig(new MultipartConfigElement(\"/home/jifang/spittr/uploads\", 2097152, 4194304, 0));\n    }\n```\n除了临时路径的位置,其他的构造器所能接受的参数如下:\n- 上传文件的最大容量(以字节为单位)。默认是没有限制的。\n- 整个multipart请求的最大容量(以字节为单位),不会关心有多少个part以及每个part的大小。默认是没有限制的。\n- 在上传的过程中,如果文件大小达到了一个指定最大容量(以字节为单位),将会写入到临时文件路径中。默认值为0,也就是所有上传的文件都会写入到磁盘上。\n\n**处理multipart请求**\n1. 使用byte[] 数组\n2. 使用上传文件的原始byte比较简单但是功能有限。因此,Spring还提供了MultipartFile接口,它为处理multipart数据提供了内容更为丰富的对象。\n```java\npublic interface MultipartFile extends InputStreamSource {\n    String getName();\n\n    String getOriginalFilename();\n\n    String getContentType();\n\n    boolean isEmpty();\n\n    long getSize();\n\n    byte[] getBytes() throws IOException;\n\n    InputStream getInputStream() throws IOException;\n\n    void transferTo(File var1) throws IOException, IllegalStateException;\n}\n```\n在controller里保存上传的文件\n```java\n@RequestMapping(\"upload.do\")\n    public String upload(@RequestPart(\"profilePicture\") MultipartFile profilePicture) throws IOException {\n        File file = new File(\"/home/jifang/spittr/uploads/\");\n        if (!file.exists() && !file.isDirectory()) {\n            file.mkdir();\n        }\n        profilePicture.transferTo(new File(\"/home/jifang/spittr/uploads/\" + profilePicture.getOriginalFilename()));\n        return \"home\";\n    }\n```\n\n### 7. 异常处理\n不管请求成功或失败，Servlet请求的输出都是一个Servlet相应。异常必须要以某种方式转换为响应。\n\nSpring提供了多种方式将异常转换为响应：\n- 特定的Spring异常将会自动映射为指定的HTTP状态码;\n- 异常上可以添加@ResponseStatus注解,从而将其映射为某一个HTTP状态码;\n- 在方法上可以添加@ExceptionHandler注解,使其用来处理异常。\n\n#### 7.1 将异常对象映射为HTTP状态码（@ResponseStatus）\nSpring默认会将自身抛出的异常自动映射到合适的状态码，如下是一些示例：\n![Alt text](https://app.yinxiang.com/shard/s15/res/df5202a1-79e7-4677-956f-234e1879e86f/1523328457188.png)\n也可以通过@ResponseStatus注解将自定义异常映射为HTTP状态码。\n```java\n@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"Spittle Not Found\")\npublic class SpittleNotFoundException extends RuntimeException {\n}\n```\n在引入@ResponseStatus注解之后,如果控制器方法抛出SpittleNotFoundException异常的话,响应将会具有404状态码,这是因为Spittle Not Found。\n\n#### 7.2 本地处理@ExceptionHandler\n`@ExceptionHandler(SpittleNotFoundException.class)`，当抛出\nSpittleNotFoundException异常的时候,将会委托该方法来处理。\n```java\n\t@ExceptionHandler(SpittleNotFoundException.class)\n    public String spittleNotFoundHandler() {\n        return \"error/spittleNotFound\";\n    }\n```\n这个方法现在只能处理它所属类的方法抛出的异常，如果要处理程序中所有的会抛出该异常的controller，那么可以使用通知（@ControllerAdvice）\n#### 7.3 全局处理@ControllerAdvice\n在带有@ControllerAdvice注解的类中,以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。\n @ControllerAdvice注解本身已经使用了@Component,因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到,就像带有@Component注解的类一样。\n```java\n@ControllerAdvice\npublic class AppWideExceptionHandler {\n    @ExceptionHandler(SpittleNotFoundException.class)\n    public String spittleNotFoundHandler() {\n        return \"error/spittleNotFound\";\n    }\n}\n```\n\n\n> 参考文献\n> [1] [Java数据校验(Bean Validation / JSR303)](https://www.cnblogs.com/pixy/p/5306567.html)\n> [2] 《Spring实战》4th","slug":"《Spring实战》Web中的Spring","published":1,"updated":"2018-08-13T14:28:27.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5l002m6k155er0bqng","content":"<p>在上一篇博客中我们简单介绍了如何搭建一个最简单的Spring MVC，现在我们来学习一下Spring的其他Web功能。为了方便学习，我将自己学习时敲下的源码放到了github上：<a href=\"https://github.com/cap-ljf/Spittr\" target=\"_blank\" rel=\"noopener\">https://github.com/cap-ljf/Spittr</a><br><a id=\"more\"></a><br>本文内容对应《Spring实战》第二部分 Web中的Spring 内容：</p>\n<ul>\n<li>JavaConfig配置Spring MVC</li>\n<li>Spring MVC数据绑定</li>\n<li>JSR 303数据校验</li>\n<li>Spring Web视图渲染之Thymeleaf</li>\n<li>JavaConfig配置自定义Servlet和Filter</li>\n<li>文件上传</li>\n<li>统一异常处理</li>\n</ul>\n<h3 id=\"1-JavaConfig配置Spring-MVC\"><a href=\"#1-JavaConfig配置Spring-MVC\" class=\"headerlink\" title=\"1. JavaConfig配置Spring MVC\"></a>1. JavaConfig配置Spring MVC</h3><p><a href=\"http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/\">《Spring实战》搭建Spring MVC</a></p>\n<h3 id=\"2-数据绑定入门\"><a href=\"#2-数据绑定入门\" class=\"headerlink\" title=\"2. 数据绑定入门\"></a>2. 数据绑定入门</h3><p><a href=\"https://www.cnblogs.com/HD/p/4107674.html\" target=\"_blank\" rel=\"noopener\">[Spring MVC] - SpringMVC的各种参数绑定方式</a><br><a href=\"https://www.imooc.com/learn/558\" target=\"_blank\" rel=\"noopener\">SpringMVC数据绑定入门</a></p>\n<h3 id=\"3-JSR-303数据校验\"><a href=\"#3-JSR-303数据校验\" class=\"headerlink\" title=\"3. JSR 303数据校验\"></a>3. JSR 303数据校验</h3><p>在了解了数据绑定之后，大部分时候我们都需要校验接受到的数据。有种处理校验的方式非常初级，那就是在controller或service方法中添加代码来检查值的合法性，如果值不合法的话，就将注册表单重新显示给用户。但是这样的校验逻辑会弄乱我们的controller方法。从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持（JSR-303）。</p>\n<p>使用JSR 303需要两个jar包依赖。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- JSR303校验 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.validation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>validation-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hibernate<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hibernate-validator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.6.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Bean Validation中内置的constraint</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/e7d4563c-a6bc-4a99-926a-55d052fc28ec/1523324310124.png\" alt=\"Alt text\"><br><strong>Hibernate Validator 附加的 constraint</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/9b50d558-e179-465d-818f-ff0a415cf77e/1523324344858.png\" alt=\"Alt text\"></p>\n<p>有些时候，你可能需要更复杂的constraint，Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现：</p>\n<ul>\n<li><p>组合现有的 constraint 来生成一个更复杂的 constraint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NotNull</span></span><br><span class=\"line\"><span class=\"meta\">@Size</span>(min = <span class=\"number\">5</span>, max = <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String username;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义constraint。<br>定义的<code>IntegerRange</code>注解。自定义constraint注解，message、groups和payload三个属性是必须定义的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.validator.IntegerRangeValidator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Constraint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Payload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.FIELD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = IntegerRangeValidator.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> IntegerRange &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"校验失败\"</span>;</span><br><span class=\"line\">    Class&lt;?&gt;[] groups() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    Class&lt;? extends Payload&gt;[] payload() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>定义验证类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.validator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.annotation.IntegerRange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-9 下午11:08</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerRangeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">IntegerRange</span>, <span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer min;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer max;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(IntegerRange constraintAnnotation)</span> </span>&#123;</span><br><span class=\"line\">        min = constraintAnnotation.min();</span><br><span class=\"line\">        max = constraintAnnotation.max();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(Integer integer, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = integer &gt; min &amp;&amp; integer &lt; max ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ConstraintValidator使用了泛型，有两个类型参数。第一个类型是对应的initialize方法的参数类型（约束注解类型），第二个类型是对应的isValid方法的第一个参数类型。</p>\n<h3 id=\"4-Spring-Web视图渲染之Thymeleaf\"><a href=\"#4-Spring-Web视图渲染之Thymeleaf\" class=\"headerlink\" title=\"4.Spring Web视图渲染之Thymeleaf\"></a>4.Spring Web视图渲染之Thymeleaf</h3><p>将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。<br>Spring自带了13个视图解析器，能够将逻辑视图名转换为物理实现。<br><img src=\"https://app.yinxiang.com/shard/s15/res/eb8d5dab-3036-4eb0-9eb5-a2a40b2b8b14/1523325208325.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/f304df0e-d997-4cfb-aa65-8cca5dcc6a82/1523325213803.png\" alt=\"Alt text\"><br>在<a href=\"http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/\">上一篇博文</a>我们介绍了<code>InternalResourceViewResolver</code>将视图解析为JSP。这一次我们使用新的项目<code>Thymeleaf</code>来配置实现视图解析。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置生成模板解析器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TemplateResolver <span class=\"title\">templateResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletContextTemplateResolver templateResolver = <span class=\"keyword\">new</span> ServletContextTemplateResolver();</span><br><span class=\"line\">        templateResolver.setPrefix(<span class=\"string\">\"/WEB-INF/templates/\"</span>);</span><br><span class=\"line\">        templateResolver.setSuffix(<span class=\"string\">\".html\"</span>);</span><br><span class=\"line\">        templateResolver.setTemplateMode(<span class=\"string\">\"HTML5\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> templateResolver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> templateResolver</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SpringTemplateEngine <span class=\"title\">templateEngine</span><span class=\"params\">(TemplateResolver templateResolver)</span> </span>&#123;</span><br><span class=\"line\">        SpringTemplateEngine templateEngine = <span class=\"keyword\">new</span> SpringTemplateEngine();</span><br><span class=\"line\">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> templateEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成视图解析器并为解析器注入引擎</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> templateEngine</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewResolver <span class=\"title\">viewResolver</span><span class=\"params\">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class=\"line\">        ThymeleafViewResolver viewResolver = <span class=\"keyword\">new</span> ThymeleafViewResolver();</span><br><span class=\"line\">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> viewResolver;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是ThymeleafViewResolver bean中注入了一个对SpringTemplate Engine bean的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎,用来解析模板,并基于这些模板渲染结果。可以看到,我们为其注入了一个TemplateResolver bean的引用。</p>\n<p>Thymeleaf在很大程度上就是HTML文件,与JSP不同,它没有什么特殊的标签或标签库。要使用Thymeleaf的标签库，需要声明Thymeleaf的命名空间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; </span><br><span class=\"line\">xmlns:th=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class=\"line\">    &lt;title&gt;Spittr&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot;</span><br><span class=\"line\">          type=&quot;text/css&quot;</span><br><span class=\"line\">          th:href=&quot;@&#123;/resources/style.css&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to Spitter&lt;/h1&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/spittles&#125;&quot;&gt;Spittles&lt;/a&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/spitter/register&#125;&quot;&gt;Register&lt;/a&gt;</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/databind&#125;&quot;&gt;databind&lt;/a&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/upload&#125;&quot;&gt;upload&lt;/a&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>关于Thymeleaf可以参考<br><a href=\"http://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0</a></p>\n<h3 id=\"5-JavaConfig配置自定义Servlet和Filter\"><a href=\"#5-JavaConfig配置自定义Servlet和Filter\" class=\"headerlink\" title=\"5.JavaConfig配置自定义Servlet和Filter\"></a>5.JavaConfig配置自定义Servlet和Filter</h3><p>实现了WebApplicationInitializer接口的类会被自动加载。我们可以在<code>onStartup</code>中添加自定义的Servlet和Filter。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.filter.MyFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.servlet.MyServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.EnumSet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过实现WebApplicationInitializer来配置额外的Servlet和Filter</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-9 下午3:39</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletInitializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebApplicationInitializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//配置自己的Servlet</span></span><br><span class=\"line\">        ServletRegistration.Dynamic myServlet = servletContext.addServlet(<span class=\"string\">\"myServlet\"</span>, MyServlet.class);</span><br><span class=\"line\">        myServlet.setLoadOnStartup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        myServlet.addMapping(<span class=\"string\">\"/myServlet/*\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//配置自己的Filter</span></span><br><span class=\"line\">        FilterRegistration.Dynamic myFilter = servletContext.addFilter(<span class=\"string\">\"myFilter\"</span>, MyFilter.class);</span><br><span class=\"line\">        myFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), <span class=\"keyword\">true</span>, <span class=\"string\">\"myServlet\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6-文件上传\"><a href=\"#6-文件上传\" class=\"headerlink\" title=\"6.文件上传\"></a>6.文件上传</h3><p>一般表单提交所形成的请求结果是很简单的,就是以“&amp;”符分割的多个name-value对。尽管这种编码形式很简单,并且对于典型的基于文本的表单提交也足够满足要求,但是对于传送二进制数据,如上传图片,就显得力不从心了。与之不同的,multipart格式的数据会将一个表单拆分为多个部分(part),每个部分对应一个输入域。在一般的表单输入域中,它所对应的部分中会放置文本型数据,但是如果上传文件的话,它所对应的部分可以是二进制。</p>\n<h4 id=\"6-1-MultiPart形式的数据\"><a href=\"#6-1-MultiPart形式的数据\" class=\"headerlink\" title=\"6.1 MultiPart形式的数据\"></a>6.1 MultiPart形式的数据</h4><p>Multipart格式数据会将一个表单拆分为多个部分(part)，每个部分对应一个输入域。在一般的表单输入域中，它对应的部分会放置文本型数据，如果是文件上传形式，它对应的部分可以是二进制。</p>\n<h4 id=\"6-2-Multipart-form-data请求方式\"><a href=\"#6-2-Multipart-form-data请求方式\" class=\"headerlink\" title=\"6.2 Multipart/form-data请求方式\"></a>6.2 Multipart/form-data请求方式</h4><p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/spittles/upload.do&quot; method=&quot;POST&quot; th:object=&quot;$&#123;spittr&#125;&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class=\"line\">    &lt;label&gt;Profile Picture&lt;/label&gt;:</span><br><span class=\"line\">    &lt;input type=&quot;file&quot; name=&quot;profilePicture&quot; accept=&quot;image/jpeg,image/png,image/gif&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;save&quot;/&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-3-SpringMVC处理Multipart数据\"><a href=\"#6-3-SpringMVC处理Multipart数据\" class=\"headerlink\" title=\"6.3 SpringMVC处理Multipart数据\"></a>6.3 SpringMVC处理Multipart数据</h4><p>xml配置可以参考：<a href=\"https://www.cnblogs.com/maying3010/p/6679974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/maying3010/p/6679974.html</a><br>下面介绍JavaConfig配置：<br><strong>配置multipart解析器</strong><br>DispatcherServlet并没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中MultipartResolver策略接口的实现,通过这个实现类来解析multipart请求中的内容。从Spring 3.1开始,Spring内置了两个MultipartResolver的实现供我们选择:</p>\n<ul>\n<li>CommonsMultipartResolver:使用Jakarta Commons FileUpload解析multipart请求;</li>\n<li>StandardServletMultipartResolver:依赖于Servlet 3.0对multipart请求的支持(始于Spring 3.1)。</li>\n</ul>\n<p>一般来讲,在这两者之间,StandardServletMultipartResolver可能会是优选的方案。它使用Servlet所提供的功能支持,并不需要依赖任何其他的项目。如果我们需要将应用部署到Servlet 3.0之前的容器中,或者还没有使用Spring 3.1或更高版本,那么可能就需要CommonsMultipartResolver了。<br>兼容Servlet 3.0的StandardServletMultipartResolver没有构造器参数,也没有要设置的属性。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> MultipartResolver <span class=\"title\">multipartResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardServletMultipartResolver();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们不能在Spring中配置StandardServletMultipartResolver的限制条件，而是要在Servlet中指定multipart的配置。</p>\n<p>如果我们采用Servlet初始化类的方式来配置DispatcherServlet的话，这个初始化类应该已经实现了WebApplicationInitializer，那我们可以在<code>ServletRegistration.Dynamic</code>上调用<code>setMultipartConfig()</code>方法，传入MultipartConfigElement实例。如果我们配置DispatcherServlet的Servlet初始化类继承了AbstractAnnotationConfigDispatcherServletInitializer类的话，那么我们不会直接创建DispatcherServlet实例并将其注册到Servlet上下文中。这样的话,将不会有对Dynamic Servlet registration的引用供我们使用了。但是,我们可以通过重载customizeRegistration()方法(它会得到一个Dynamic作为参数)来配置multipart的具体细节:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置multipart的具体细节</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> registration</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">customizeRegistration</span><span class=\"params\">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class=\"line\">        registration.setMultipartConfig(<span class=\"keyword\">new</span> MultipartConfigElement(<span class=\"string\">\"/home/jifang/spittr/uploads\"</span>, <span class=\"number\">2097152</span>, <span class=\"number\">4194304</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了临时路径的位置,其他的构造器所能接受的参数如下:</p>\n<ul>\n<li>上传文件的最大容量(以字节为单位)。默认是没有限制的。</li>\n<li>整个multipart请求的最大容量(以字节为单位),不会关心有多少个part以及每个part的大小。默认是没有限制的。</li>\n<li>在上传的过程中,如果文件大小达到了一个指定最大容量(以字节为单位),将会写入到临时文件路径中。默认值为0,也就是所有上传的文件都会写入到磁盘上。</li>\n</ul>\n<p><strong>处理multipart请求</strong></p>\n<ol>\n<li>使用byte[] 数组</li>\n<li>使用上传文件的原始byte比较简单但是功能有限。因此,Spring还提供了MultipartFile接口,它为处理multipart数据提供了内容更为丰富的对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MultipartFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStreamSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getOriginalFilename</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getContentType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getSize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] getBytes() <span class=\"keyword\">throws</span> IOException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InputStream <span class=\"title\">getInputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transferTo</span><span class=\"params\">(File var1)</span> <span class=\"keyword\">throws</span> IOException, IllegalStateException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在controller里保存上传的文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"upload.do\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">upload</span><span class=\"params\">(@RequestPart(<span class=\"string\">\"profilePicture\"</span>)</span> MultipartFile profilePicture) <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/jifang/spittr/uploads/\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists() &amp;&amp; !file.isDirectory()) &#123;</span><br><span class=\"line\">            file.mkdir();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        profilePicture.transferTo(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/jifang/spittr/uploads/\"</span> + profilePicture.getOriginalFilename()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"7-异常处理\"><a href=\"#7-异常处理\" class=\"headerlink\" title=\"7. 异常处理\"></a>7. 异常处理</h3><p>不管请求成功或失败，Servlet请求的输出都是一个Servlet相应。异常必须要以某种方式转换为响应。</p>\n<p>Spring提供了多种方式将异常转换为响应：</p>\n<ul>\n<li>特定的Spring异常将会自动映射为指定的HTTP状态码;</li>\n<li>异常上可以添加@ResponseStatus注解,从而将其映射为某一个HTTP状态码;</li>\n<li>在方法上可以添加@ExceptionHandler注解,使其用来处理异常。</li>\n</ul>\n<h4 id=\"7-1-将异常对象映射为HTTP状态码（-ResponseStatus）\"><a href=\"#7-1-将异常对象映射为HTTP状态码（-ResponseStatus）\" class=\"headerlink\" title=\"7.1 将异常对象映射为HTTP状态码（@ResponseStatus）\"></a>7.1 将异常对象映射为HTTP状态码（@ResponseStatus）</h4><p>Spring默认会将自身抛出的异常自动映射到合适的状态码，如下是一些示例：<br><img src=\"https://app.yinxiang.com/shard/s15/res/df5202a1-79e7-4677-956f-234e1879e86f/1523328457188.png\" alt=\"Alt text\"><br>也可以通过@ResponseStatus注解将自定义异常映射为HTTP状态码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.NOT_FOUND, reason = <span class=\"string\">\"Spittle Not Found\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittleNotFoundException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在引入@ResponseStatus注解之后,如果控制器方法抛出SpittleNotFoundException异常的话,响应将会具有404状态码,这是因为Spittle Not Found。</p>\n<h4 id=\"7-2-本地处理-ExceptionHandler\"><a href=\"#7-2-本地处理-ExceptionHandler\" class=\"headerlink\" title=\"7.2 本地处理@ExceptionHandler\"></a>7.2 本地处理@ExceptionHandler</h4><p><code>@ExceptionHandler(SpittleNotFoundException.class)</code>，当抛出<br>SpittleNotFoundException异常的时候,将会委托该方法来处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(SpittleNotFoundException.class)</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">spittleNotFoundHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"error/spittleNotFound\"</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法现在只能处理它所属类的方法抛出的异常，如果要处理程序中所有的会抛出该异常的controller，那么可以使用通知（@ControllerAdvice）</p>\n<h4 id=\"7-3-全局处理-ControllerAdvice\"><a href=\"#7-3-全局处理-ControllerAdvice\" class=\"headerlink\" title=\"7.3 全局处理@ControllerAdvice\"></a>7.3 全局处理@ControllerAdvice</h4><p>在带有@ControllerAdvice注解的类中,以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。<br> @ControllerAdvice注解本身已经使用了@Component,因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到,就像带有@Component注解的类一样。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppWideExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(SpittleNotFoundException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">spittleNotFoundHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"error/spittleNotFound\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://www.cnblogs.com/pixy/p/5306567.html\" target=\"_blank\" rel=\"noopener\">Java数据校验(Bean Validation / JSR303)</a><br>[2] 《Spring实战》4th</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在上一篇博客中我们简单介绍了如何搭建一个最简单的Spring MVC，现在我们来学习一下Spring的其他Web功能。为了方便学习，我将自己学习时敲下的源码放到了github上：<a href=\"https://github.com/cap-ljf/Spittr\" target=\"_blank\" rel=\"noopener\">https://github.com/cap-ljf/Spittr</a><br>","more":"<br>本文内容对应《Spring实战》第二部分 Web中的Spring 内容：</p>\n<ul>\n<li>JavaConfig配置Spring MVC</li>\n<li>Spring MVC数据绑定</li>\n<li>JSR 303数据校验</li>\n<li>Spring Web视图渲染之Thymeleaf</li>\n<li>JavaConfig配置自定义Servlet和Filter</li>\n<li>文件上传</li>\n<li>统一异常处理</li>\n</ul>\n<h3 id=\"1-JavaConfig配置Spring-MVC\"><a href=\"#1-JavaConfig配置Spring-MVC\" class=\"headerlink\" title=\"1. JavaConfig配置Spring MVC\"></a>1. JavaConfig配置Spring MVC</h3><p><a href=\"http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/\">《Spring实战》搭建Spring MVC</a></p>\n<h3 id=\"2-数据绑定入门\"><a href=\"#2-数据绑定入门\" class=\"headerlink\" title=\"2. 数据绑定入门\"></a>2. 数据绑定入门</h3><p><a href=\"https://www.cnblogs.com/HD/p/4107674.html\" target=\"_blank\" rel=\"noopener\">[Spring MVC] - SpringMVC的各种参数绑定方式</a><br><a href=\"https://www.imooc.com/learn/558\" target=\"_blank\" rel=\"noopener\">SpringMVC数据绑定入门</a></p>\n<h3 id=\"3-JSR-303数据校验\"><a href=\"#3-JSR-303数据校验\" class=\"headerlink\" title=\"3. JSR 303数据校验\"></a>3. JSR 303数据校验</h3><p>在了解了数据绑定之后，大部分时候我们都需要校验接受到的数据。有种处理校验的方式非常初级，那就是在controller或service方法中添加代码来检查值的合法性，如果值不合法的话，就将注册表单重新显示给用户。但是这样的校验逻辑会弄乱我们的controller方法。从Spring3.0开始，在SpringMVC中提供了对Java校验API的支持（JSR-303）。</p>\n<p>使用JSR 303需要两个jar包依赖。<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- JSR303校验 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.validation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>validation-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hibernate<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hibernate-validator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.6.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>Bean Validation中内置的constraint</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/e7d4563c-a6bc-4a99-926a-55d052fc28ec/1523324310124.png\" alt=\"Alt text\"><br><strong>Hibernate Validator 附加的 constraint</strong><br><img src=\"https://app.yinxiang.com/shard/s15/res/9b50d558-e179-465d-818f-ff0a415cf77e/1523324344858.png\" alt=\"Alt text\"></p>\n<p>有些时候，你可能需要更复杂的constraint，Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现：</p>\n<ul>\n<li><p>组合现有的 constraint 来生成一个更复杂的 constraint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NotNull</span></span><br><span class=\"line\"><span class=\"meta\">@Size</span>(min = <span class=\"number\">5</span>, max = <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String username;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义constraint。<br>定义的<code>IntegerRange</code>注解。自定义constraint注解，message、groups和payload三个属性是必须定义的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.annotation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.validator.IntegerRangeValidator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Constraint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Payload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.ElementType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.FIELD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = IntegerRangeValidator.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> IntegerRange &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"校验失败\"</span>;</span><br><span class=\"line\">    Class&lt;?&gt;[] groups() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    Class&lt;? extends Payload&gt;[] payload() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>定义验证类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.validator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.annotation.IntegerRange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-9 下午11:08</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerRangeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">IntegerRange</span>, <span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer min;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer max;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(IntegerRange constraintAnnotation)</span> </span>&#123;</span><br><span class=\"line\">        min = constraintAnnotation.min();</span><br><span class=\"line\">        max = constraintAnnotation.max();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(Integer integer, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = integer &gt; min &amp;&amp; integer &lt; max ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ConstraintValidator使用了泛型，有两个类型参数。第一个类型是对应的initialize方法的参数类型（约束注解类型），第二个类型是对应的isValid方法的第一个参数类型。</p>\n<h3 id=\"4-Spring-Web视图渲染之Thymeleaf\"><a href=\"#4-Spring-Web视图渲染之Thymeleaf\" class=\"headerlink\" title=\"4.Spring Web视图渲染之Thymeleaf\"></a>4.Spring Web视图渲染之Thymeleaf</h3><p>将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC的一个重要特性。<br>Spring自带了13个视图解析器，能够将逻辑视图名转换为物理实现。<br><img src=\"https://app.yinxiang.com/shard/s15/res/eb8d5dab-3036-4eb0-9eb5-a2a40b2b8b14/1523325208325.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/f304df0e-d997-4cfb-aa65-8cca5dcc6a82/1523325213803.png\" alt=\"Alt text\"><br>在<a href=\"http://cap-ljf.top/2018/04/08/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E6%90%AD%E5%BB%BASpring-MVC/\">上一篇博文</a>我们介绍了<code>InternalResourceViewResolver</code>将视图解析为JSP。这一次我们使用新的项目<code>Thymeleaf</code>来配置实现视图解析。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置生成模板解析器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TemplateResolver <span class=\"title\">templateResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletContextTemplateResolver templateResolver = <span class=\"keyword\">new</span> ServletContextTemplateResolver();</span><br><span class=\"line\">        templateResolver.setPrefix(<span class=\"string\">\"/WEB-INF/templates/\"</span>);</span><br><span class=\"line\">        templateResolver.setSuffix(<span class=\"string\">\".html\"</span>);</span><br><span class=\"line\">        templateResolver.setTemplateMode(<span class=\"string\">\"HTML5\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> templateResolver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> templateResolver</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SpringTemplateEngine <span class=\"title\">templateEngine</span><span class=\"params\">(TemplateResolver templateResolver)</span> </span>&#123;</span><br><span class=\"line\">        SpringTemplateEngine templateEngine = <span class=\"keyword\">new</span> SpringTemplateEngine();</span><br><span class=\"line\">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> templateEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 生成视图解析器并为解析器注入引擎</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> templateEngine</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewResolver <span class=\"title\">viewResolver</span><span class=\"params\">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class=\"line\">        ThymeleafViewResolver viewResolver = <span class=\"keyword\">new</span> ThymeleafViewResolver();</span><br><span class=\"line\">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> viewResolver;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是ThymeleafViewResolver bean中注入了一个对SpringTemplate Engine bean的引用。SpringTemplateEngine会在Spring中启用Thymeleaf引擎,用来解析模板,并基于这些模板渲染结果。可以看到,我们为其注入了一个TemplateResolver bean的引用。</p>\n<p>Thymeleaf在很大程度上就是HTML文件,与JSP不同,它没有什么特殊的标签或标签库。要使用Thymeleaf的标签库，需要声明Thymeleaf的命名空间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; </span><br><span class=\"line\">xmlns:th=&quot;http://thymeleaf.org&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class=\"line\">    &lt;title&gt;Spittr&lt;/title&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot;</span><br><span class=\"line\">          type=&quot;text/css&quot;</span><br><span class=\"line\">          th:href=&quot;@&#123;/resources/style.css&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to Spitter&lt;/h1&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/spittles&#125;&quot;&gt;Spittles&lt;/a&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/spitter/register&#125;&quot;&gt;Register&lt;/a&gt;</span><br><span class=\"line\">&lt;br/&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/databind&#125;&quot;&gt;databind&lt;/a&gt;</span><br><span class=\"line\">&lt;a th:href=&quot;@&#123;/upload&#125;&quot;&gt;upload&lt;/a&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>关于Thymeleaf可以参考<br><a href=\"http://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hjwublog/p/5051732.html#autoid-11-0-0</a></p>\n<h3 id=\"5-JavaConfig配置自定义Servlet和Filter\"><a href=\"#5-JavaConfig配置自定义Servlet和Filter\" class=\"headerlink\" title=\"5.JavaConfig配置自定义Servlet和Filter\"></a>5.JavaConfig配置自定义Servlet和Filter</h3><p>实现了WebApplicationInitializer接口的类会被自动加载。我们可以在<code>onStartup</code>中添加自定义的Servlet和Filter。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jifang.spittr.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.filter.MyFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jifang.spittr.servlet.MyServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.EnumSet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过实现WebApplicationInitializer来配置额外的Servlet和Filter</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-4-9 下午3:39</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletInitializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebApplicationInitializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext servletContext)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//配置自己的Servlet</span></span><br><span class=\"line\">        ServletRegistration.Dynamic myServlet = servletContext.addServlet(<span class=\"string\">\"myServlet\"</span>, MyServlet.class);</span><br><span class=\"line\">        myServlet.setLoadOnStartup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        myServlet.addMapping(<span class=\"string\">\"/myServlet/*\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//配置自己的Filter</span></span><br><span class=\"line\">        FilterRegistration.Dynamic myFilter = servletContext.addFilter(<span class=\"string\">\"myFilter\"</span>, MyFilter.class);</span><br><span class=\"line\">        myFilter.addMappingForServletNames(EnumSet.of(DispatcherType.REQUEST), <span class=\"keyword\">true</span>, <span class=\"string\">\"myServlet\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6-文件上传\"><a href=\"#6-文件上传\" class=\"headerlink\" title=\"6.文件上传\"></a>6.文件上传</h3><p>一般表单提交所形成的请求结果是很简单的,就是以“&amp;”符分割的多个name-value对。尽管这种编码形式很简单,并且对于典型的基于文本的表单提交也足够满足要求,但是对于传送二进制数据,如上传图片,就显得力不从心了。与之不同的,multipart格式的数据会将一个表单拆分为多个部分(part),每个部分对应一个输入域。在一般的表单输入域中,它所对应的部分中会放置文本型数据,但是如果上传文件的话,它所对应的部分可以是二进制。</p>\n<h4 id=\"6-1-MultiPart形式的数据\"><a href=\"#6-1-MultiPart形式的数据\" class=\"headerlink\" title=\"6.1 MultiPart形式的数据\"></a>6.1 MultiPart形式的数据</h4><p>Multipart格式数据会将一个表单拆分为多个部分(part)，每个部分对应一个输入域。在一般的表单输入域中，它对应的部分会放置文本型数据，如果是文件上传形式，它对应的部分可以是二进制。</p>\n<h4 id=\"6-2-Multipart-form-data请求方式\"><a href=\"#6-2-Multipart-form-data请求方式\" class=\"headerlink\" title=\"6.2 Multipart/form-data请求方式\"></a>6.2 Multipart/form-data请求方式</h4><p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/spittles/upload.do&quot; method=&quot;POST&quot; th:object=&quot;$&#123;spittr&#125;&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class=\"line\">    &lt;label&gt;Profile Picture&lt;/label&gt;:</span><br><span class=\"line\">    &lt;input type=&quot;file&quot; name=&quot;profilePicture&quot; accept=&quot;image/jpeg,image/png,image/gif&quot;/&gt;&lt;br/&gt;</span><br><span class=\"line\">    &lt;input type=&quot;submit&quot; value=&quot;save&quot;/&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-3-SpringMVC处理Multipart数据\"><a href=\"#6-3-SpringMVC处理Multipart数据\" class=\"headerlink\" title=\"6.3 SpringMVC处理Multipart数据\"></a>6.3 SpringMVC处理Multipart数据</h4><p>xml配置可以参考：<a href=\"https://www.cnblogs.com/maying3010/p/6679974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/maying3010/p/6679974.html</a><br>下面介绍JavaConfig配置：<br><strong>配置multipart解析器</strong><br>DispatcherServlet并没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中MultipartResolver策略接口的实现,通过这个实现类来解析multipart请求中的内容。从Spring 3.1开始,Spring内置了两个MultipartResolver的实现供我们选择:</p>\n<ul>\n<li>CommonsMultipartResolver:使用Jakarta Commons FileUpload解析multipart请求;</li>\n<li>StandardServletMultipartResolver:依赖于Servlet 3.0对multipart请求的支持(始于Spring 3.1)。</li>\n</ul>\n<p>一般来讲,在这两者之间,StandardServletMultipartResolver可能会是优选的方案。它使用Servlet所提供的功能支持,并不需要依赖任何其他的项目。如果我们需要将应用部署到Servlet 3.0之前的容器中,或者还没有使用Spring 3.1或更高版本,那么可能就需要CommonsMultipartResolver了。<br>兼容Servlet 3.0的StandardServletMultipartResolver没有构造器参数,也没有要设置的属性。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> MultipartResolver <span class=\"title\">multipartResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StandardServletMultipartResolver();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们不能在Spring中配置StandardServletMultipartResolver的限制条件，而是要在Servlet中指定multipart的配置。</p>\n<p>如果我们采用Servlet初始化类的方式来配置DispatcherServlet的话，这个初始化类应该已经实现了WebApplicationInitializer，那我们可以在<code>ServletRegistration.Dynamic</code>上调用<code>setMultipartConfig()</code>方法，传入MultipartConfigElement实例。如果我们配置DispatcherServlet的Servlet初始化类继承了AbstractAnnotationConfigDispatcherServletInitializer类的话，那么我们不会直接创建DispatcherServlet实例并将其注册到Servlet上下文中。这样的话,将不会有对Dynamic Servlet registration的引用供我们使用了。但是,我们可以通过重载customizeRegistration()方法(它会得到一个Dynamic作为参数)来配置multipart的具体细节:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 配置multipart的具体细节</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> registration</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">customizeRegistration</span><span class=\"params\">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class=\"line\">        registration.setMultipartConfig(<span class=\"keyword\">new</span> MultipartConfigElement(<span class=\"string\">\"/home/jifang/spittr/uploads\"</span>, <span class=\"number\">2097152</span>, <span class=\"number\">4194304</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了临时路径的位置,其他的构造器所能接受的参数如下:</p>\n<ul>\n<li>上传文件的最大容量(以字节为单位)。默认是没有限制的。</li>\n<li>整个multipart请求的最大容量(以字节为单位),不会关心有多少个part以及每个part的大小。默认是没有限制的。</li>\n<li>在上传的过程中,如果文件大小达到了一个指定最大容量(以字节为单位),将会写入到临时文件路径中。默认值为0,也就是所有上传的文件都会写入到磁盘上。</li>\n</ul>\n<p><strong>处理multipart请求</strong></p>\n<ol>\n<li>使用byte[] 数组</li>\n<li>使用上传文件的原始byte比较简单但是功能有限。因此,Spring还提供了MultipartFile接口,它为处理multipart数据提供了内容更为丰富的对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MultipartFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStreamSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getOriginalFilename</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getContentType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getSize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] getBytes() <span class=\"keyword\">throws</span> IOException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">InputStream <span class=\"title\">getInputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transferTo</span><span class=\"params\">(File var1)</span> <span class=\"keyword\">throws</span> IOException, IllegalStateException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在controller里保存上传的文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"upload.do\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">upload</span><span class=\"params\">(@RequestPart(<span class=\"string\">\"profilePicture\"</span>)</span> MultipartFile profilePicture) <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/jifang/spittr/uploads/\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists() &amp;&amp; !file.isDirectory()) &#123;</span><br><span class=\"line\">            file.mkdir();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        profilePicture.transferTo(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/jifang/spittr/uploads/\"</span> + profilePicture.getOriginalFilename()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"home\"</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"7-异常处理\"><a href=\"#7-异常处理\" class=\"headerlink\" title=\"7. 异常处理\"></a>7. 异常处理</h3><p>不管请求成功或失败，Servlet请求的输出都是一个Servlet相应。异常必须要以某种方式转换为响应。</p>\n<p>Spring提供了多种方式将异常转换为响应：</p>\n<ul>\n<li>特定的Spring异常将会自动映射为指定的HTTP状态码;</li>\n<li>异常上可以添加@ResponseStatus注解,从而将其映射为某一个HTTP状态码;</li>\n<li>在方法上可以添加@ExceptionHandler注解,使其用来处理异常。</li>\n</ul>\n<h4 id=\"7-1-将异常对象映射为HTTP状态码（-ResponseStatus）\"><a href=\"#7-1-将异常对象映射为HTTP状态码（-ResponseStatus）\" class=\"headerlink\" title=\"7.1 将异常对象映射为HTTP状态码（@ResponseStatus）\"></a>7.1 将异常对象映射为HTTP状态码（@ResponseStatus）</h4><p>Spring默认会将自身抛出的异常自动映射到合适的状态码，如下是一些示例：<br><img src=\"https://app.yinxiang.com/shard/s15/res/df5202a1-79e7-4677-956f-234e1879e86f/1523328457188.png\" alt=\"Alt text\"><br>也可以通过@ResponseStatus注解将自定义异常映射为HTTP状态码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.NOT_FOUND, reason = <span class=\"string\">\"Spittle Not Found\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpittleNotFoundException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在引入@ResponseStatus注解之后,如果控制器方法抛出SpittleNotFoundException异常的话,响应将会具有404状态码,这是因为Spittle Not Found。</p>\n<h4 id=\"7-2-本地处理-ExceptionHandler\"><a href=\"#7-2-本地处理-ExceptionHandler\" class=\"headerlink\" title=\"7.2 本地处理@ExceptionHandler\"></a>7.2 本地处理@ExceptionHandler</h4><p><code>@ExceptionHandler(SpittleNotFoundException.class)</code>，当抛出<br>SpittleNotFoundException异常的时候,将会委托该方法来处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span>(SpittleNotFoundException.class)</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">spittleNotFoundHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"error/spittleNotFound\"</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法现在只能处理它所属类的方法抛出的异常，如果要处理程序中所有的会抛出该异常的controller，那么可以使用通知（@ControllerAdvice）</p>\n<h4 id=\"7-3-全局处理-ControllerAdvice\"><a href=\"#7-3-全局处理-ControllerAdvice\" class=\"headerlink\" title=\"7.3 全局处理@ControllerAdvice\"></a>7.3 全局处理@ControllerAdvice</h4><p>在带有@ControllerAdvice注解的类中,以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。<br> @ControllerAdvice注解本身已经使用了@Component,因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到,就像带有@Component注解的类一样。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppWideExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(SpittleNotFoundException.class)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">spittleNotFoundHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"error/spittleNotFound\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"https://www.cnblogs.com/pixy/p/5306567.html\" target=\"_blank\" rel=\"noopener\">Java数据校验(Bean Validation / JSR303)</a><br>[2] 《Spring实战》4th</p>\n</blockquote>"},{"toc":true,"title":"《Spring实战》装配bean","date":"2018-04-03T15:16:31.000Z","_content":"\n创建应用对象之间协作关系的行为（类的依赖）通常称为装配（wiring），这也是依赖注入的本质。\n<!--more-->\n### 1. Spring配置的可选方案\n在 Spring 中装配 bean 有多种方式。Spring 容器负责创建应用程序中的 bean 并通过 DI 来协调这些对象之间的关系。但是,作为开发人员,你需要告诉 Spring 要创\n建哪些 bean 并且如何将其装配在一起。当描述 bean 如何进行装配时, Spring 具有非常大的灵活性,它提供了三种主要的装配机制:\n- 在XMl中进行显示配置\n- 在Java中进行显示配置\n- 隐式的bean发现机制和自动装配\n\nSpring 的配置风格是可以互相搭配的,所以你可以选择使用 XML 装配一些 bean ,使用 Spring 基于 Java 的配置( JavaConfig )来装配另一些 bean ,而将剩余的bean 让 Spring 去自动发现。\n\n**即便如此,我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置 bean 的时候(比如,有些源码不是由你来维护的,而当你需要为这些代码配置 bean 的时候),我推荐使用类型安全并且比 XML 更加强大的 JavaConfig 。最后,只有当你想要使用便利的 XML命名空间,并且在 JavaConfig 中没有同样的实现时,才应该使用 XML 。**\n\n### 2. 自动化装配Bean（隐式）\n#### 2.1 创建可被发现的Bean\n尽管你会发现这些显式装配技术非常有用,但是在便利性方面,最强大的还是 Spring 的自动化配置。如果 Spring 能够进行自动化装配的话,那何苦还要显式地将这些 bean 装配在一起呢?\n\nSpring从两个角度来实现自动化装配：\n- 组件扫描（component scanning）: Spring会自动发现应用上下文中所创建的Bean\n- 自动装配（autowiring）: Spring自动满足bean之间的依赖\n\n组件扫描和自动装配组合在一起就能发挥出强大的威力,它们能够将你的显式配置降低到最少。\n\n`@component`：这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。\n\n不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找带有`@component`注解的类，并为其创建bean。\n\n有两种方式启用组件扫描：\n1. @ComponentScan 注解启用了组件扫描\n```java\n@Configuration\n@ComponentScan\npublic class CDPlayerConfig{\n}\n```\n类 CDPlayerConfig 通过 Java 代码定义了 Spring 的装配规则。\n`@ComponentScan`：这个注解能够在Spring中启用组件扫描。如果没有其他配置的话, @ComponentScan 默认会扫描与配置类相同的包。\n2. 通过XML启用组件扫描\n使用 Spring context 命名空间的 <context:component-scan> 元素。\n```\n<context:component-scan base-package=\"soundsystem\"/>\n```\n`context:component-scan> `元素会有与`@ComponentScan `注解相对应的属性和子元素。\n\n**测试组件扫描能够发现`CompactDisc`**\n```\n@Run\n```\n使用了 Spring 的 `SpringJUnit4ClassRunner` ,以便在测试开始的时候自动创建 Spring 的应用上下文。\n`@ContextConfiguration`会告诉它需要在CDPlayerConfig中加载配置。\n\n#### 2.2 为组件扫描的bean命名\nSpring 应用上下文中所有的 bean 都会给定一个 ID 。在前面的例子中,尽管我们没有明确地为 SgtPeppers bean 设置 ID ,但 Spring 会根据类名为其指定一个 ID 。具体来讲,这个 bean 所给定的 ID 为 sgtPeppers ,也就是将类名的第一个字母变为小写。\n\n如果想为这个 bean 设置不同的 ID ,你所要做的就是将期望的 ID 作为值传递给 @Component 注解。比如：\n```java\n@Component(\"longlyHeartsClub\")\npublic class SgtPeppers implements CompactDisc{\n...\n}\n```\n也可以使用`@Named`注解替代`@component`，但是建议使用`@component`\n#### 2.3 设置组件扫描的基础包\n`@ComponentScan(\"soundsystem\")`\n`@ComponentScan(basePackages=\"soundsystem\")`\n`@ComponentScan(basePackages={\"soundsystem\",\"video\"})`\n`@ComponentScan(basePackageClasses={CDplayer.class,DVDPlayer.class})`\n\n#### 2.4 通过为 bean 添加注解实现自动装配\n简单来说,自动装配就是让 Spring 自动满足 bean 依赖的一种方法,在满足依赖的过程中,会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean 。为了声明要进行自动装配,我们可以借助 Spring 的 @Autowired 注解。\n\n`@Autowired`：这个注解可以用在类的任何方法上。这表明当这行某个方法时Spring会创建参数对应的Bean。进行依赖注入。它也可以用在类变量上，这样就相当于是使用在该类变量的`setter`方法上。\n\n不管是构造器、 Setter 方法还是其他的方法, Spring 都会尝试满足方法参数上所声明的依赖。假如有且只有一个 bean 匹配依赖需求的话,那么这个 bean 将会被装配进来。\n\n如果没有匹配的 bean ,那么在应用上下文创建的时候, Spring 会抛出一个异常。为了避免异常的出现,你可以将 @Autowired 的 required 属性设置为 false 。将 required 属性设置为 false 时, Spring 会尝试执行自动装配,但是如果没有匹配的 bean 的话, Spring 将会让这个 bean 处于未装配的状态。但是,把 required 属性设置为 false 时,你需要谨慎对待。如果在你的代码中没有进行 null 检查的话,这个处于未装配状态的属性有可能会出现 NullPointerException 。\n\n如果有多个 bean 都能满足依赖关系的话, Spring 将会抛出一个异常,表明没有明确指定要选择哪个 bean 进行自动装配。\n\n`@Inject` 和 `@Autowired`有相同的功能。\n\n### 3. 通过Java代码装配bean\n尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式,但有时候自动化配置的方案行不通,因此需要明确配置 Spring 。比如说,你想要将第三方库中的组件装配到你的应用中,在这种情况下,是没有办法在它的类上添\n加 @Component 和 @Autowired 注解的,因此就不能使用自动化装配的方案了。\n\n#### 3.1 创建配置类\n\n创建 JavaConfig 类的关键在于为其添加 @Configuration 注解, @Configuration 注解表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。\n`@Configuration`:表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。\n\n#### 3.2 声明简单的bean\n要在 JavaConfig 中声明 bean ,我们需要编写一个方法,这个方法会创建所需类型的实例,然后给这个方法添加 @Bean 注解。例如：\n```java\n@Bean\n  public CompactDisc compactDisc() {\n    return new SgtPeppers();\n  }\n```\n`@Bean`： 注解会告诉 Spring 这个方法将会返回一个对象,该对象要注册为 Spring 应用上下文中的 bean 。方法体中包含了最终产生 bean 实例的逻辑。\n\n默认情况下, bean 的 ID 与带有 @Bean 注解的方法名是一样的。在本例中, bean 的名字将会是 sgtPeppers 。如果你想为其设置成一个不同的名字的话,那么可以重命名该方法,也可以通过 name 属性指定一个不同的名字:\n```java\n  @Bean(name=\"othername\")\n  public CompactDisc compactDisc() {\n    return new SgtPeppers();\n  }\n```\n\n#### 3.3 借助JavaConfig实现注入\n我们前面所声明的 CompactDisc bean 是非常简单的,它自身没有其他的依赖。但现在,我们需要声明 CDPlayerbean ,它依赖于 CompactDisc 。在 JavaConfig 中,要如何将它们装配在一起呢?\n1. 引用创建 bean 的方法\n```java\n@Bean\n  public CDPlayer cdPlayer() {\n    return new CDPlayer(compactDisc());\n  }\n```\n因为`compactDisc()`方法添加了`@Bean`注解，Spring会拦截所有对它的调用，并确保直接返回该方法所创建的bean。而不是每次都对其进行实际的调用。（即bean都是单例）\n\n可以看到,通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式:\n```java\n  @Bean\n  public CDPlayer cdPlayer(CompactDisc compactDisc) {\n    return new CDPlayer(compactDisc);\n  }\n```\n\n### 4. 通过XML装配bean\n尽管Spring长期以来确实与XML有着关联,但现在需要明确的是,XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动化配置和基于Java的配置,XML不应该再是你的第一选择了。\n\n不过,鉴于已经存在那么多基于XML的Spring配置,所以理解如何在Spring中使用XML还是很重要的。但是,我希望本节的内容只是用来帮助你维护已有的XML配置,在完成新的Spring工作时,希望你会使用自动化配置和JavaConfig。\n\n#### 4.1 创建XML配置规范\n在使用XML为Spring装配bean之前,你需要创建一个新的配置规范。在使用avaConfig的时候,这意味着要创建一个带有@Configuration注解的类,而在XML配置中,这意味着要创建一个XML文件,并且要以`<beans>`元素为根。\n![Alt text](https://app.yinxiang.com/shard/s15/res/3447fe93-de26-4eb3-b358-7bc65b51e8c1/1522765974699.png)\n\n#### 4.2 声明一个简单的`<bean>`\n`<bean>`元素元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明`CompactDisc` bean:\n`<bean class=\"soundsystem.SgtPeppers\" />`\n这里声明了一个很简单的bean,创建这个bean的类通过class属性来指定的,并且要使用全限定的类名。\n\n因为没有明确给定ID,所以这个bean将会根据全限定类名来进行命名。在本例中,bean的ID将会是“soundsystem.SgtPeppers#0”。其中,“#0”是一个计数的形式,用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers,并且没有明确进行标识,那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。\n\n尽管自动化的bean命名方式非常方便,但如果你要稍后引用它的话,那自动产生的名字就没有多大的用处了。因此,通常来讲更好的办法是借助id属性,为每个bean设置一个你自己选择的名字:\n`<bean id=\"compactDisc\" class=\"soundsystem.SgtPeppers\" />`\n\n#### 4.3 借助构造器注入初始化bean\n在Spring XML配置中,只有一种声明bean的方式:使用`<bean>`元素并指定class属性。Spring会从这里获取必要的信息来创建bean。但是,在XML中声明DI时,会有多种可选的配置方案和风格。具体到构造器注入,有两种基本的配置方案可供选择：\n- `<constructor-arg>`元素\n- 使用Spring 3.0所引入的c-命名空间\n\n**构造器注入bean引用**\n```xml\n<bean id=\"cdPlayer\" class=\"soundsystem.cdPlayer\">\n\t<constructor-arg ref=\"compactDisc\" />\n</bean>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/4259a7f5-f0b6-4863-93ff-b508cdf8d824/1522766746766.png)\n\n使用`<constructor-arg>`元素进行构造器参数的注入\n\n#### 4.4 设置属性\n`<property>`元素为属性的Setter方法所提供的功能与`<constructor-arg>`元素为构造器所提供的功能是一样的。\n![Alt text](https://app.yinxiang.com/shard/s15/res/b365723c-f3c5-43d7-934e-088cd6a472f0/1522767233977.png)\n\n### 5. 导入和混合配置\n在典型的Spring应用中,我们可能会同时使用自动化和显式配置。即便你更喜欢通过\nJavaConfig实现显式配置,但有的时候XML却是最佳的方案。\n\n**关于混合配置,第一件需要了解的事情就是在自动装配时,它并不在意要装配的bean来自哪里。自动装配的时候会考虑到Spring容器中所有的bean,不管它是在JavaConfig或XML中声明的还是通过组件扫描获取到的。**\n\n#### 5.1 在JavaConfig中引用XML配置\n\n1. `A` JavaConfig类导入 `B` JavaConfig类：使用`@Import`注解导入。\n```java\n@Configuration\n@Import(CDPlayerConfig.class)\n@ImportResource(\"classpath:cd-config.xml\")\npublic class SoundSystemConfig {\n}\n```\n2. 在JavaConfig中引用XML配置，使用`@ImportResource`注解，示例同上。\n\n#### 5.2 在XML配置中引用JavaConfig\n1. 两个XML配置文件。使用`<import resource=\"\">`标签\n`<import resource=\"cdplayer-config.xml\"/>`\n2. 在XML配置中引用JavaConfig。使用`<bean>`标签。\n`<bean class=\"soundsystem.CDconfig\" />`\n\n好了。在这一个博客中我们看到了在Spring中装配bean的三种方式：自动化配置、基于Java的显示配置和基于XML的显示配置。\n\n建议使用自动化配置或JavaConfig配置，如果你是在维护一个旧系统，这里也介绍了如何进行混合配置。明天见。\n\n\n","source":"_posts/《Spring实战》装配bean.md","raw":"---\ntoc: true\ntitle: 《Spring实战》装配bean\ndate: 2018-04-03 23:16:31\ntags: [Spring]\n---\n\n创建应用对象之间协作关系的行为（类的依赖）通常称为装配（wiring），这也是依赖注入的本质。\n<!--more-->\n### 1. Spring配置的可选方案\n在 Spring 中装配 bean 有多种方式。Spring 容器负责创建应用程序中的 bean 并通过 DI 来协调这些对象之间的关系。但是,作为开发人员,你需要告诉 Spring 要创\n建哪些 bean 并且如何将其装配在一起。当描述 bean 如何进行装配时, Spring 具有非常大的灵活性,它提供了三种主要的装配机制:\n- 在XMl中进行显示配置\n- 在Java中进行显示配置\n- 隐式的bean发现机制和自动装配\n\nSpring 的配置风格是可以互相搭配的,所以你可以选择使用 XML 装配一些 bean ,使用 Spring 基于 Java 的配置( JavaConfig )来装配另一些 bean ,而将剩余的bean 让 Spring 去自动发现。\n\n**即便如此,我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置 bean 的时候(比如,有些源码不是由你来维护的,而当你需要为这些代码配置 bean 的时候),我推荐使用类型安全并且比 XML 更加强大的 JavaConfig 。最后,只有当你想要使用便利的 XML命名空间,并且在 JavaConfig 中没有同样的实现时,才应该使用 XML 。**\n\n### 2. 自动化装配Bean（隐式）\n#### 2.1 创建可被发现的Bean\n尽管你会发现这些显式装配技术非常有用,但是在便利性方面,最强大的还是 Spring 的自动化配置。如果 Spring 能够进行自动化装配的话,那何苦还要显式地将这些 bean 装配在一起呢?\n\nSpring从两个角度来实现自动化装配：\n- 组件扫描（component scanning）: Spring会自动发现应用上下文中所创建的Bean\n- 自动装配（autowiring）: Spring自动满足bean之间的依赖\n\n组件扫描和自动装配组合在一起就能发挥出强大的威力,它们能够将你的显式配置降低到最少。\n\n`@component`：这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。\n\n不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找带有`@component`注解的类，并为其创建bean。\n\n有两种方式启用组件扫描：\n1. @ComponentScan 注解启用了组件扫描\n```java\n@Configuration\n@ComponentScan\npublic class CDPlayerConfig{\n}\n```\n类 CDPlayerConfig 通过 Java 代码定义了 Spring 的装配规则。\n`@ComponentScan`：这个注解能够在Spring中启用组件扫描。如果没有其他配置的话, @ComponentScan 默认会扫描与配置类相同的包。\n2. 通过XML启用组件扫描\n使用 Spring context 命名空间的 <context:component-scan> 元素。\n```\n<context:component-scan base-package=\"soundsystem\"/>\n```\n`context:component-scan> `元素会有与`@ComponentScan `注解相对应的属性和子元素。\n\n**测试组件扫描能够发现`CompactDisc`**\n```\n@Run\n```\n使用了 Spring 的 `SpringJUnit4ClassRunner` ,以便在测试开始的时候自动创建 Spring 的应用上下文。\n`@ContextConfiguration`会告诉它需要在CDPlayerConfig中加载配置。\n\n#### 2.2 为组件扫描的bean命名\nSpring 应用上下文中所有的 bean 都会给定一个 ID 。在前面的例子中,尽管我们没有明确地为 SgtPeppers bean 设置 ID ,但 Spring 会根据类名为其指定一个 ID 。具体来讲,这个 bean 所给定的 ID 为 sgtPeppers ,也就是将类名的第一个字母变为小写。\n\n如果想为这个 bean 设置不同的 ID ,你所要做的就是将期望的 ID 作为值传递给 @Component 注解。比如：\n```java\n@Component(\"longlyHeartsClub\")\npublic class SgtPeppers implements CompactDisc{\n...\n}\n```\n也可以使用`@Named`注解替代`@component`，但是建议使用`@component`\n#### 2.3 设置组件扫描的基础包\n`@ComponentScan(\"soundsystem\")`\n`@ComponentScan(basePackages=\"soundsystem\")`\n`@ComponentScan(basePackages={\"soundsystem\",\"video\"})`\n`@ComponentScan(basePackageClasses={CDplayer.class,DVDPlayer.class})`\n\n#### 2.4 通过为 bean 添加注解实现自动装配\n简单来说,自动装配就是让 Spring 自动满足 bean 依赖的一种方法,在满足依赖的过程中,会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean 。为了声明要进行自动装配,我们可以借助 Spring 的 @Autowired 注解。\n\n`@Autowired`：这个注解可以用在类的任何方法上。这表明当这行某个方法时Spring会创建参数对应的Bean。进行依赖注入。它也可以用在类变量上，这样就相当于是使用在该类变量的`setter`方法上。\n\n不管是构造器、 Setter 方法还是其他的方法, Spring 都会尝试满足方法参数上所声明的依赖。假如有且只有一个 bean 匹配依赖需求的话,那么这个 bean 将会被装配进来。\n\n如果没有匹配的 bean ,那么在应用上下文创建的时候, Spring 会抛出一个异常。为了避免异常的出现,你可以将 @Autowired 的 required 属性设置为 false 。将 required 属性设置为 false 时, Spring 会尝试执行自动装配,但是如果没有匹配的 bean 的话, Spring 将会让这个 bean 处于未装配的状态。但是,把 required 属性设置为 false 时,你需要谨慎对待。如果在你的代码中没有进行 null 检查的话,这个处于未装配状态的属性有可能会出现 NullPointerException 。\n\n如果有多个 bean 都能满足依赖关系的话, Spring 将会抛出一个异常,表明没有明确指定要选择哪个 bean 进行自动装配。\n\n`@Inject` 和 `@Autowired`有相同的功能。\n\n### 3. 通过Java代码装配bean\n尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式,但有时候自动化配置的方案行不通,因此需要明确配置 Spring 。比如说,你想要将第三方库中的组件装配到你的应用中,在这种情况下,是没有办法在它的类上添\n加 @Component 和 @Autowired 注解的,因此就不能使用自动化装配的方案了。\n\n#### 3.1 创建配置类\n\n创建 JavaConfig 类的关键在于为其添加 @Configuration 注解, @Configuration 注解表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。\n`@Configuration`:表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。\n\n#### 3.2 声明简单的bean\n要在 JavaConfig 中声明 bean ,我们需要编写一个方法,这个方法会创建所需类型的实例,然后给这个方法添加 @Bean 注解。例如：\n```java\n@Bean\n  public CompactDisc compactDisc() {\n    return new SgtPeppers();\n  }\n```\n`@Bean`： 注解会告诉 Spring 这个方法将会返回一个对象,该对象要注册为 Spring 应用上下文中的 bean 。方法体中包含了最终产生 bean 实例的逻辑。\n\n默认情况下, bean 的 ID 与带有 @Bean 注解的方法名是一样的。在本例中, bean 的名字将会是 sgtPeppers 。如果你想为其设置成一个不同的名字的话,那么可以重命名该方法,也可以通过 name 属性指定一个不同的名字:\n```java\n  @Bean(name=\"othername\")\n  public CompactDisc compactDisc() {\n    return new SgtPeppers();\n  }\n```\n\n#### 3.3 借助JavaConfig实现注入\n我们前面所声明的 CompactDisc bean 是非常简单的,它自身没有其他的依赖。但现在,我们需要声明 CDPlayerbean ,它依赖于 CompactDisc 。在 JavaConfig 中,要如何将它们装配在一起呢?\n1. 引用创建 bean 的方法\n```java\n@Bean\n  public CDPlayer cdPlayer() {\n    return new CDPlayer(compactDisc());\n  }\n```\n因为`compactDisc()`方法添加了`@Bean`注解，Spring会拦截所有对它的调用，并确保直接返回该方法所创建的bean。而不是每次都对其进行实际的调用。（即bean都是单例）\n\n可以看到,通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式:\n```java\n  @Bean\n  public CDPlayer cdPlayer(CompactDisc compactDisc) {\n    return new CDPlayer(compactDisc);\n  }\n```\n\n### 4. 通过XML装配bean\n尽管Spring长期以来确实与XML有着关联,但现在需要明确的是,XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动化配置和基于Java的配置,XML不应该再是你的第一选择了。\n\n不过,鉴于已经存在那么多基于XML的Spring配置,所以理解如何在Spring中使用XML还是很重要的。但是,我希望本节的内容只是用来帮助你维护已有的XML配置,在完成新的Spring工作时,希望你会使用自动化配置和JavaConfig。\n\n#### 4.1 创建XML配置规范\n在使用XML为Spring装配bean之前,你需要创建一个新的配置规范。在使用avaConfig的时候,这意味着要创建一个带有@Configuration注解的类,而在XML配置中,这意味着要创建一个XML文件,并且要以`<beans>`元素为根。\n![Alt text](https://app.yinxiang.com/shard/s15/res/3447fe93-de26-4eb3-b358-7bc65b51e8c1/1522765974699.png)\n\n#### 4.2 声明一个简单的`<bean>`\n`<bean>`元素元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明`CompactDisc` bean:\n`<bean class=\"soundsystem.SgtPeppers\" />`\n这里声明了一个很简单的bean,创建这个bean的类通过class属性来指定的,并且要使用全限定的类名。\n\n因为没有明确给定ID,所以这个bean将会根据全限定类名来进行命名。在本例中,bean的ID将会是“soundsystem.SgtPeppers#0”。其中,“#0”是一个计数的形式,用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers,并且没有明确进行标识,那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。\n\n尽管自动化的bean命名方式非常方便,但如果你要稍后引用它的话,那自动产生的名字就没有多大的用处了。因此,通常来讲更好的办法是借助id属性,为每个bean设置一个你自己选择的名字:\n`<bean id=\"compactDisc\" class=\"soundsystem.SgtPeppers\" />`\n\n#### 4.3 借助构造器注入初始化bean\n在Spring XML配置中,只有一种声明bean的方式:使用`<bean>`元素并指定class属性。Spring会从这里获取必要的信息来创建bean。但是,在XML中声明DI时,会有多种可选的配置方案和风格。具体到构造器注入,有两种基本的配置方案可供选择：\n- `<constructor-arg>`元素\n- 使用Spring 3.0所引入的c-命名空间\n\n**构造器注入bean引用**\n```xml\n<bean id=\"cdPlayer\" class=\"soundsystem.cdPlayer\">\n\t<constructor-arg ref=\"compactDisc\" />\n</bean>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/4259a7f5-f0b6-4863-93ff-b508cdf8d824/1522766746766.png)\n\n使用`<constructor-arg>`元素进行构造器参数的注入\n\n#### 4.4 设置属性\n`<property>`元素为属性的Setter方法所提供的功能与`<constructor-arg>`元素为构造器所提供的功能是一样的。\n![Alt text](https://app.yinxiang.com/shard/s15/res/b365723c-f3c5-43d7-934e-088cd6a472f0/1522767233977.png)\n\n### 5. 导入和混合配置\n在典型的Spring应用中,我们可能会同时使用自动化和显式配置。即便你更喜欢通过\nJavaConfig实现显式配置,但有的时候XML却是最佳的方案。\n\n**关于混合配置,第一件需要了解的事情就是在自动装配时,它并不在意要装配的bean来自哪里。自动装配的时候会考虑到Spring容器中所有的bean,不管它是在JavaConfig或XML中声明的还是通过组件扫描获取到的。**\n\n#### 5.1 在JavaConfig中引用XML配置\n\n1. `A` JavaConfig类导入 `B` JavaConfig类：使用`@Import`注解导入。\n```java\n@Configuration\n@Import(CDPlayerConfig.class)\n@ImportResource(\"classpath:cd-config.xml\")\npublic class SoundSystemConfig {\n}\n```\n2. 在JavaConfig中引用XML配置，使用`@ImportResource`注解，示例同上。\n\n#### 5.2 在XML配置中引用JavaConfig\n1. 两个XML配置文件。使用`<import resource=\"\">`标签\n`<import resource=\"cdplayer-config.xml\"/>`\n2. 在XML配置中引用JavaConfig。使用`<bean>`标签。\n`<bean class=\"soundsystem.CDconfig\" />`\n\n好了。在这一个博客中我们看到了在Spring中装配bean的三种方式：自动化配置、基于Java的显示配置和基于XML的显示配置。\n\n建议使用自动化配置或JavaConfig配置，如果你是在维护一个旧系统，这里也介绍了如何进行混合配置。明天见。\n\n\n","slug":"《Spring实战》装配bean","published":1,"updated":"2018-08-13T14:28:27.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5m002n6k15j2excd34","content":"<p>创建应用对象之间协作关系的行为（类的依赖）通常称为装配（wiring），这也是依赖注入的本质。<br><a id=\"more\"></a></p>\n<h3 id=\"1-Spring配置的可选方案\"><a href=\"#1-Spring配置的可选方案\" class=\"headerlink\" title=\"1. Spring配置的可选方案\"></a>1. Spring配置的可选方案</h3><p>在 Spring 中装配 bean 有多种方式。Spring 容器负责创建应用程序中的 bean 并通过 DI 来协调这些对象之间的关系。但是,作为开发人员,你需要告诉 Spring 要创<br>建哪些 bean 并且如何将其装配在一起。当描述 bean 如何进行装配时, Spring 具有非常大的灵活性,它提供了三种主要的装配机制:</p>\n<ul>\n<li>在XMl中进行显示配置</li>\n<li>在Java中进行显示配置</li>\n<li>隐式的bean发现机制和自动装配</li>\n</ul>\n<p>Spring 的配置风格是可以互相搭配的,所以你可以选择使用 XML 装配一些 bean ,使用 Spring 基于 Java 的配置( JavaConfig )来装配另一些 bean ,而将剩余的bean 让 Spring 去自动发现。</p>\n<p><strong>即便如此,我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置 bean 的时候(比如,有些源码不是由你来维护的,而当你需要为这些代码配置 bean 的时候),我推荐使用类型安全并且比 XML 更加强大的 JavaConfig 。最后,只有当你想要使用便利的 XML命名空间,并且在 JavaConfig 中没有同样的实现时,才应该使用 XML 。</strong></p>\n<h3 id=\"2-自动化装配Bean（隐式）\"><a href=\"#2-自动化装配Bean（隐式）\" class=\"headerlink\" title=\"2. 自动化装配Bean（隐式）\"></a>2. 自动化装配Bean（隐式）</h3><h4 id=\"2-1-创建可被发现的Bean\"><a href=\"#2-1-创建可被发现的Bean\" class=\"headerlink\" title=\"2.1 创建可被发现的Bean\"></a>2.1 创建可被发现的Bean</h4><p>尽管你会发现这些显式装配技术非常有用,但是在便利性方面,最强大的还是 Spring 的自动化配置。如果 Spring 能够进行自动化装配的话,那何苦还要显式地将这些 bean 装配在一起呢?</p>\n<p>Spring从两个角度来实现自动化装配：</p>\n<ul>\n<li>组件扫描（component scanning）: Spring会自动发现应用上下文中所创建的Bean</li>\n<li>自动装配（autowiring）: Spring自动满足bean之间的依赖</li>\n</ul>\n<p>组件扫描和自动装配组合在一起就能发挥出强大的威力,它们能够将你的显式配置降低到最少。</p>\n<p><code>@component</code>：这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p>\n<p>不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找带有<code>@component</code>注解的类，并为其创建bean。</p>\n<p>有两种方式启用组件扫描：</p>\n<ol>\n<li>@ComponentScan 注解启用了组件扫描<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>类 CDPlayerConfig 通过 Java 代码定义了 Spring 的装配规则。<br><code>@ComponentScan</code>：这个注解能够在Spring中启用组件扫描。如果没有其他配置的话, @ComponentScan 默认会扫描与配置类相同的包。</p>\n<ol>\n<li>通过XML启用组件扫描<br>使用 Spring context 命名空间的 <a href=\"context:component-scan\" target=\"_blank\" rel=\"noopener\">context:component-scan</a> 元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>context:component-scan&gt;</code>元素会有与<code>@ComponentScan</code>注解相对应的属性和子元素。</p>\n<p><strong>测试组件扫描能够发现<code>CompactDisc</code></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Run</span><br></pre></td></tr></table></figure></p>\n<p>使用了 Spring 的 <code>SpringJUnit4ClassRunner</code> ,以便在测试开始的时候自动创建 Spring 的应用上下文。<br><code>@ContextConfiguration</code>会告诉它需要在CDPlayerConfig中加载配置。</p>\n<h4 id=\"2-2-为组件扫描的bean命名\"><a href=\"#2-2-为组件扫描的bean命名\" class=\"headerlink\" title=\"2.2 为组件扫描的bean命名\"></a>2.2 为组件扫描的bean命名</h4><p>Spring 应用上下文中所有的 bean 都会给定一个 ID 。在前面的例子中,尽管我们没有明确地为 SgtPeppers bean 设置 ID ,但 Spring 会根据类名为其指定一个 ID 。具体来讲,这个 bean 所给定的 ID 为 sgtPeppers ,也就是将类名的第一个字母变为小写。</p>\n<p>如果想为这个 bean 设置不同的 ID ,你所要做的就是将期望的 ID 作为值传递给 @Component 注解。比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"longlyHeartsClub\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用<code>@Named</code>注解替代<code>@component</code>，但是建议使用<code>@component</code></p>\n<h4 id=\"2-3-设置组件扫描的基础包\"><a href=\"#2-3-设置组件扫描的基础包\" class=\"headerlink\" title=\"2.3 设置组件扫描的基础包\"></a>2.3 设置组件扫描的基础包</h4><p><code>@ComponentScan(&quot;soundsystem&quot;)</code><br><code>@ComponentScan(basePackages=&quot;soundsystem&quot;)</code><br><code>@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})</code><br><code>@ComponentScan(basePackageClasses={CDplayer.class,DVDPlayer.class})</code></p>\n<h4 id=\"2-4-通过为-bean-添加注解实现自动装配\"><a href=\"#2-4-通过为-bean-添加注解实现自动装配\" class=\"headerlink\" title=\"2.4 通过为 bean 添加注解实现自动装配\"></a>2.4 通过为 bean 添加注解实现自动装配</h4><p>简单来说,自动装配就是让 Spring 自动满足 bean 依赖的一种方法,在满足依赖的过程中,会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean 。为了声明要进行自动装配,我们可以借助 Spring 的 @Autowired 注解。</p>\n<p><code>@Autowired</code>：这个注解可以用在类的任何方法上。这表明当这行某个方法时Spring会创建参数对应的Bean。进行依赖注入。它也可以用在类变量上，这样就相当于是使用在该类变量的<code>setter</code>方法上。</p>\n<p>不管是构造器、 Setter 方法还是其他的方法, Spring 都会尝试满足方法参数上所声明的依赖。假如有且只有一个 bean 匹配依赖需求的话,那么这个 bean 将会被装配进来。</p>\n<p>如果没有匹配的 bean ,那么在应用上下文创建的时候, Spring 会抛出一个异常。为了避免异常的出现,你可以将 @Autowired 的 required 属性设置为 false 。将 required 属性设置为 false 时, Spring 会尝试执行自动装配,但是如果没有匹配的 bean 的话, Spring 将会让这个 bean 处于未装配的状态。但是,把 required 属性设置为 false 时,你需要谨慎对待。如果在你的代码中没有进行 null 检查的话,这个处于未装配状态的属性有可能会出现 NullPointerException 。</p>\n<p>如果有多个 bean 都能满足依赖关系的话, Spring 将会抛出一个异常,表明没有明确指定要选择哪个 bean 进行自动装配。</p>\n<p><code>@Inject</code> 和 <code>@Autowired</code>有相同的功能。</p>\n<h3 id=\"3-通过Java代码装配bean\"><a href=\"#3-通过Java代码装配bean\" class=\"headerlink\" title=\"3. 通过Java代码装配bean\"></a>3. 通过Java代码装配bean</h3><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式,但有时候自动化配置的方案行不通,因此需要明确配置 Spring 。比如说,你想要将第三方库中的组件装配到你的应用中,在这种情况下,是没有办法在它的类上添<br>加 @Component 和 @Autowired 注解的,因此就不能使用自动化装配的方案了。</p>\n<h4 id=\"3-1-创建配置类\"><a href=\"#3-1-创建配置类\" class=\"headerlink\" title=\"3.1 创建配置类\"></a>3.1 创建配置类</h4><p>创建 JavaConfig 类的关键在于为其添加 @Configuration 注解, @Configuration 注解表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。<br><code>@Configuration</code>:表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。</p>\n<h4 id=\"3-2-声明简单的bean\"><a href=\"#3-2-声明简单的bean\" class=\"headerlink\" title=\"3.2 声明简单的bean\"></a>3.2 声明简单的bean</h4><p>要在 JavaConfig 中声明 bean ,我们需要编写一个方法,这个方法会创建所需类型的实例,然后给这个方法添加 @Bean 注解。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">compactDisc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>@Bean</code>： 注解会告诉 Spring 这个方法将会返回一个对象,该对象要注册为 Spring 应用上下文中的 bean 。方法体中包含了最终产生 bean 实例的逻辑。</p>\n<p>默认情况下, bean 的 ID 与带有 @Bean 注解的方法名是一样的。在本例中, bean 的名字将会是 sgtPeppers 。如果你想为其设置成一个不同的名字的话,那么可以重命名该方法,也可以通过 name 属性指定一个不同的名字:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"othername\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">compactDisc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-3-借助JavaConfig实现注入\"><a href=\"#3-3-借助JavaConfig实现注入\" class=\"headerlink\" title=\"3.3 借助JavaConfig实现注入\"></a>3.3 借助JavaConfig实现注入</h4><p>我们前面所声明的 CompactDisc bean 是非常简单的,它自身没有其他的依赖。但现在,我们需要声明 CDPlayerbean ,它依赖于 CompactDisc 。在 JavaConfig 中,要如何将它们装配在一起呢?</p>\n<ol>\n<li>引用创建 bean 的方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>因为<code>compactDisc()</code>方法添加了<code>@Bean</code>注解，Spring会拦截所有对它的调用，并确保直接返回该方法所创建的bean。而不是每次都对其进行实际的调用。（即bean都是单例）</p>\n<p>可以看到,通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-通过XML装配bean\"><a href=\"#4-通过XML装配bean\" class=\"headerlink\" title=\"4. 通过XML装配bean\"></a>4. 通过XML装配bean</h3><p>尽管Spring长期以来确实与XML有着关联,但现在需要明确的是,XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动化配置和基于Java的配置,XML不应该再是你的第一选择了。</p>\n<p>不过,鉴于已经存在那么多基于XML的Spring配置,所以理解如何在Spring中使用XML还是很重要的。但是,我希望本节的内容只是用来帮助你维护已有的XML配置,在完成新的Spring工作时,希望你会使用自动化配置和JavaConfig。</p>\n<h4 id=\"4-1-创建XML配置规范\"><a href=\"#4-1-创建XML配置规范\" class=\"headerlink\" title=\"4.1 创建XML配置规范\"></a>4.1 创建XML配置规范</h4><p>在使用XML为Spring装配bean之前,你需要创建一个新的配置规范。在使用avaConfig的时候,这意味着要创建一个带有@Configuration注解的类,而在XML配置中,这意味着要创建一个XML文件,并且要以<code>&lt;beans&gt;</code>元素为根。<br><img src=\"https://app.yinxiang.com/shard/s15/res/3447fe93-de26-4eb3-b358-7bc65b51e8c1/1522765974699.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-2-声明一个简单的-lt-bean-gt\"><a href=\"#4-2-声明一个简单的-lt-bean-gt\" class=\"headerlink\" title=\"4.2 声明一个简单的&lt;bean&gt;\"></a>4.2 声明一个简单的<code>&lt;bean&gt;</code></h4><p><code>&lt;bean&gt;</code>元素元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明<code>CompactDisc</code> bean:<br><code>&lt;bean class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code><br>这里声明了一个很简单的bean,创建这个bean的类通过class属性来指定的,并且要使用全限定的类名。</p>\n<p>因为没有明确给定ID,所以这个bean将会根据全限定类名来进行命名。在本例中,bean的ID将会是“soundsystem.SgtPeppers#0”。其中,“#0”是一个计数的形式,用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers,并且没有明确进行标识,那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。</p>\n<p>尽管自动化的bean命名方式非常方便,但如果你要稍后引用它的话,那自动产生的名字就没有多大的用处了。因此,通常来讲更好的办法是借助id属性,为每个bean设置一个你自己选择的名字:<br><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code></p>\n<h4 id=\"4-3-借助构造器注入初始化bean\"><a href=\"#4-3-借助构造器注入初始化bean\" class=\"headerlink\" title=\"4.3 借助构造器注入初始化bean\"></a>4.3 借助构造器注入初始化bean</h4><p>在Spring XML配置中,只有一种声明bean的方式:使用<code>&lt;bean&gt;</code>元素并指定class属性。Spring会从这里获取必要的信息来创建bean。但是,在XML中声明DI时,会有多种可选的配置方案和风格。具体到构造器注入,有两种基本的配置方案可供选择：</p>\n<ul>\n<li><code>&lt;constructor-arg&gt;</code>元素</li>\n<li>使用Spring 3.0所引入的c-命名空间</li>\n</ul>\n<p><strong>构造器注入bean引用</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cdPlayer\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"soundsystem.cdPlayer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"compactDisc\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/4259a7f5-f0b6-4863-93ff-b508cdf8d824/1522766746766.png\" alt=\"Alt text\"></p>\n<p>使用<code>&lt;constructor-arg&gt;</code>元素进行构造器参数的注入</p>\n<h4 id=\"4-4-设置属性\"><a href=\"#4-4-设置属性\" class=\"headerlink\" title=\"4.4 设置属性\"></a>4.4 设置属性</h4><p><code>&lt;property&gt;</code>元素为属性的Setter方法所提供的功能与<code>&lt;constructor-arg&gt;</code>元素为构造器所提供的功能是一样的。<br><img src=\"https://app.yinxiang.com/shard/s15/res/b365723c-f3c5-43d7-934e-088cd6a472f0/1522767233977.png\" alt=\"Alt text\"></p>\n<h3 id=\"5-导入和混合配置\"><a href=\"#5-导入和混合配置\" class=\"headerlink\" title=\"5. 导入和混合配置\"></a>5. 导入和混合配置</h3><p>在典型的Spring应用中,我们可能会同时使用自动化和显式配置。即便你更喜欢通过<br>JavaConfig实现显式配置,但有的时候XML却是最佳的方案。</p>\n<p><strong>关于混合配置,第一件需要了解的事情就是在自动装配时,它并不在意要装配的bean来自哪里。自动装配的时候会考虑到Spring容器中所有的bean,不管它是在JavaConfig或XML中声明的还是通过组件扫描获取到的。</strong></p>\n<h4 id=\"5-1-在JavaConfig中引用XML配置\"><a href=\"#5-1-在JavaConfig中引用XML配置\" class=\"headerlink\" title=\"5.1 在JavaConfig中引用XML配置\"></a>5.1 在JavaConfig中引用XML配置</h4><ol>\n<li><p><code>A</code> JavaConfig类导入 <code>B</code> JavaConfig类：使用<code>@Import</code>注解导入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(CDPlayerConfig.class)</span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(<span class=\"string\">\"classpath:cd-config.xml\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoundSystemConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在JavaConfig中引用XML配置，使用<code>@ImportResource</code>注解，示例同上。</p>\n</li>\n</ol>\n<h4 id=\"5-2-在XML配置中引用JavaConfig\"><a href=\"#5-2-在XML配置中引用JavaConfig\" class=\"headerlink\" title=\"5.2 在XML配置中引用JavaConfig\"></a>5.2 在XML配置中引用JavaConfig</h4><ol>\n<li>两个XML配置文件。使用<code>&lt;import resource=&quot;&quot;&gt;</code>标签<br><code>&lt;import resource=&quot;cdplayer-config.xml&quot;/&gt;</code></li>\n<li>在XML配置中引用JavaConfig。使用<code>&lt;bean&gt;</code>标签。<br><code>&lt;bean class=&quot;soundsystem.CDconfig&quot; /&gt;</code></li>\n</ol>\n<p>好了。在这一个博客中我们看到了在Spring中装配bean的三种方式：自动化配置、基于Java的显示配置和基于XML的显示配置。</p>\n<p>建议使用自动化配置或JavaConfig配置，如果你是在维护一个旧系统，这里也介绍了如何进行混合配置。明天见。</p>\n","site":{"data":{}},"excerpt":"<p>创建应用对象之间协作关系的行为（类的依赖）通常称为装配（wiring），这也是依赖注入的本质。<br>","more":"</p>\n<h3 id=\"1-Spring配置的可选方案\"><a href=\"#1-Spring配置的可选方案\" class=\"headerlink\" title=\"1. Spring配置的可选方案\"></a>1. Spring配置的可选方案</h3><p>在 Spring 中装配 bean 有多种方式。Spring 容器负责创建应用程序中的 bean 并通过 DI 来协调这些对象之间的关系。但是,作为开发人员,你需要告诉 Spring 要创<br>建哪些 bean 并且如何将其装配在一起。当描述 bean 如何进行装配时, Spring 具有非常大的灵活性,它提供了三种主要的装配机制:</p>\n<ul>\n<li>在XMl中进行显示配置</li>\n<li>在Java中进行显示配置</li>\n<li>隐式的bean发现机制和自动装配</li>\n</ul>\n<p>Spring 的配置风格是可以互相搭配的,所以你可以选择使用 XML 装配一些 bean ,使用 Spring 基于 Java 的配置( JavaConfig )来装配另一些 bean ,而将剩余的bean 让 Spring 去自动发现。</p>\n<p><strong>即便如此,我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置 bean 的时候(比如,有些源码不是由你来维护的,而当你需要为这些代码配置 bean 的时候),我推荐使用类型安全并且比 XML 更加强大的 JavaConfig 。最后,只有当你想要使用便利的 XML命名空间,并且在 JavaConfig 中没有同样的实现时,才应该使用 XML 。</strong></p>\n<h3 id=\"2-自动化装配Bean（隐式）\"><a href=\"#2-自动化装配Bean（隐式）\" class=\"headerlink\" title=\"2. 自动化装配Bean（隐式）\"></a>2. 自动化装配Bean（隐式）</h3><h4 id=\"2-1-创建可被发现的Bean\"><a href=\"#2-1-创建可被发现的Bean\" class=\"headerlink\" title=\"2.1 创建可被发现的Bean\"></a>2.1 创建可被发现的Bean</h4><p>尽管你会发现这些显式装配技术非常有用,但是在便利性方面,最强大的还是 Spring 的自动化配置。如果 Spring 能够进行自动化装配的话,那何苦还要显式地将这些 bean 装配在一起呢?</p>\n<p>Spring从两个角度来实现自动化装配：</p>\n<ul>\n<li>组件扫描（component scanning）: Spring会自动发现应用上下文中所创建的Bean</li>\n<li>自动装配（autowiring）: Spring自动满足bean之间的依赖</li>\n</ul>\n<p>组件扫描和自动装配组合在一起就能发挥出强大的威力,它们能够将你的显式配置降低到最少。</p>\n<p><code>@component</code>：这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p>\n<p>不过，组件扫描默认是不启用的。我们还需要显示配置一下Spring，从而命令它去寻找带有<code>@component</code>注解的类，并为其创建bean。</p>\n<p>有两种方式启用组件扫描：</p>\n<ol>\n<li>@ComponentScan 注解启用了组件扫描<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>类 CDPlayerConfig 通过 Java 代码定义了 Spring 的装配规则。<br><code>@ComponentScan</code>：这个注解能够在Spring中启用组件扫描。如果没有其他配置的话, @ComponentScan 默认会扫描与配置类相同的包。</p>\n<ol>\n<li>通过XML启用组件扫描<br>使用 Spring context 命名空间的 <a href=\"context:component-scan\" target=\"_blank\" rel=\"noopener\">context:component-scan</a> 元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>context:component-scan&gt;</code>元素会有与<code>@ComponentScan</code>注解相对应的属性和子元素。</p>\n<p><strong>测试组件扫描能够发现<code>CompactDisc</code></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Run</span><br></pre></td></tr></table></figure></p>\n<p>使用了 Spring 的 <code>SpringJUnit4ClassRunner</code> ,以便在测试开始的时候自动创建 Spring 的应用上下文。<br><code>@ContextConfiguration</code>会告诉它需要在CDPlayerConfig中加载配置。</p>\n<h4 id=\"2-2-为组件扫描的bean命名\"><a href=\"#2-2-为组件扫描的bean命名\" class=\"headerlink\" title=\"2.2 为组件扫描的bean命名\"></a>2.2 为组件扫描的bean命名</h4><p>Spring 应用上下文中所有的 bean 都会给定一个 ID 。在前面的例子中,尽管我们没有明确地为 SgtPeppers bean 设置 ID ,但 Spring 会根据类名为其指定一个 ID 。具体来讲,这个 bean 所给定的 ID 为 sgtPeppers ,也就是将类名的第一个字母变为小写。</p>\n<p>如果想为这个 bean 设置不同的 ID ,你所要做的就是将期望的 ID 作为值传递给 @Component 注解。比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"longlyHeartsClub\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用<code>@Named</code>注解替代<code>@component</code>，但是建议使用<code>@component</code></p>\n<h4 id=\"2-3-设置组件扫描的基础包\"><a href=\"#2-3-设置组件扫描的基础包\" class=\"headerlink\" title=\"2.3 设置组件扫描的基础包\"></a>2.3 设置组件扫描的基础包</h4><p><code>@ComponentScan(&quot;soundsystem&quot;)</code><br><code>@ComponentScan(basePackages=&quot;soundsystem&quot;)</code><br><code>@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})</code><br><code>@ComponentScan(basePackageClasses={CDplayer.class,DVDPlayer.class})</code></p>\n<h4 id=\"2-4-通过为-bean-添加注解实现自动装配\"><a href=\"#2-4-通过为-bean-添加注解实现自动装配\" class=\"headerlink\" title=\"2.4 通过为 bean 添加注解实现自动装配\"></a>2.4 通过为 bean 添加注解实现自动装配</h4><p>简单来说,自动装配就是让 Spring 自动满足 bean 依赖的一种方法,在满足依赖的过程中,会在 Spring 应用上下文中寻找匹配某个 bean 需求的其他 bean 。为了声明要进行自动装配,我们可以借助 Spring 的 @Autowired 注解。</p>\n<p><code>@Autowired</code>：这个注解可以用在类的任何方法上。这表明当这行某个方法时Spring会创建参数对应的Bean。进行依赖注入。它也可以用在类变量上，这样就相当于是使用在该类变量的<code>setter</code>方法上。</p>\n<p>不管是构造器、 Setter 方法还是其他的方法, Spring 都会尝试满足方法参数上所声明的依赖。假如有且只有一个 bean 匹配依赖需求的话,那么这个 bean 将会被装配进来。</p>\n<p>如果没有匹配的 bean ,那么在应用上下文创建的时候, Spring 会抛出一个异常。为了避免异常的出现,你可以将 @Autowired 的 required 属性设置为 false 。将 required 属性设置为 false 时, Spring 会尝试执行自动装配,但是如果没有匹配的 bean 的话, Spring 将会让这个 bean 处于未装配的状态。但是,把 required 属性设置为 false 时,你需要谨慎对待。如果在你的代码中没有进行 null 检查的话,这个处于未装配状态的属性有可能会出现 NullPointerException 。</p>\n<p>如果有多个 bean 都能满足依赖关系的话, Spring 将会抛出一个异常,表明没有明确指定要选择哪个 bean 进行自动装配。</p>\n<p><code>@Inject</code> 和 <code>@Autowired</code>有相同的功能。</p>\n<h3 id=\"3-通过Java代码装配bean\"><a href=\"#3-通过Java代码装配bean\" class=\"headerlink\" title=\"3. 通过Java代码装配bean\"></a>3. 通过Java代码装配bean</h3><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式,但有时候自动化配置的方案行不通,因此需要明确配置 Spring 。比如说,你想要将第三方库中的组件装配到你的应用中,在这种情况下,是没有办法在它的类上添<br>加 @Component 和 @Autowired 注解的,因此就不能使用自动化装配的方案了。</p>\n<h4 id=\"3-1-创建配置类\"><a href=\"#3-1-创建配置类\" class=\"headerlink\" title=\"3.1 创建配置类\"></a>3.1 创建配置类</h4><p>创建 JavaConfig 类的关键在于为其添加 @Configuration 注解, @Configuration 注解表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。<br><code>@Configuration</code>:表明这个类是一个配置类,该类应该包含在 Spring 应用上下文中如何创建 bean 的细节。</p>\n<h4 id=\"3-2-声明简单的bean\"><a href=\"#3-2-声明简单的bean\" class=\"headerlink\" title=\"3.2 声明简单的bean\"></a>3.2 声明简单的bean</h4><p>要在 JavaConfig 中声明 bean ,我们需要编写一个方法,这个方法会创建所需类型的实例,然后给这个方法添加 @Bean 注解。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">compactDisc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>@Bean</code>： 注解会告诉 Spring 这个方法将会返回一个对象,该对象要注册为 Spring 应用上下文中的 bean 。方法体中包含了最终产生 bean 实例的逻辑。</p>\n<p>默认情况下, bean 的 ID 与带有 @Bean 注解的方法名是一样的。在本例中, bean 的名字将会是 sgtPeppers 。如果你想为其设置成一个不同的名字的话,那么可以重命名该方法,也可以通过 name 属性指定一个不同的名字:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"othername\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">compactDisc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-3-借助JavaConfig实现注入\"><a href=\"#3-3-借助JavaConfig实现注入\" class=\"headerlink\" title=\"3.3 借助JavaConfig实现注入\"></a>3.3 借助JavaConfig实现注入</h4><p>我们前面所声明的 CompactDisc bean 是非常简单的,它自身没有其他的依赖。但现在,我们需要声明 CDPlayerbean ,它依赖于 CompactDisc 。在 JavaConfig 中,要如何将它们装配在一起呢?</p>\n<ol>\n<li>引用创建 bean 的方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc());</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>因为<code>compactDisc()</code>方法添加了<code>@Bean</code>注解，Spring会拦截所有对它的调用，并确保直接返回该方法所创建的bean。而不是每次都对其进行实际的调用。（即bean都是单例）</p>\n<p>可以看到,通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-通过XML装配bean\"><a href=\"#4-通过XML装配bean\" class=\"headerlink\" title=\"4. 通过XML装配bean\"></a>4. 通过XML装配bean</h3><p>尽管Spring长期以来确实与XML有着关联,但现在需要明确的是,XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动化配置和基于Java的配置,XML不应该再是你的第一选择了。</p>\n<p>不过,鉴于已经存在那么多基于XML的Spring配置,所以理解如何在Spring中使用XML还是很重要的。但是,我希望本节的内容只是用来帮助你维护已有的XML配置,在完成新的Spring工作时,希望你会使用自动化配置和JavaConfig。</p>\n<h4 id=\"4-1-创建XML配置规范\"><a href=\"#4-1-创建XML配置规范\" class=\"headerlink\" title=\"4.1 创建XML配置规范\"></a>4.1 创建XML配置规范</h4><p>在使用XML为Spring装配bean之前,你需要创建一个新的配置规范。在使用avaConfig的时候,这意味着要创建一个带有@Configuration注解的类,而在XML配置中,这意味着要创建一个XML文件,并且要以<code>&lt;beans&gt;</code>元素为根。<br><img src=\"https://app.yinxiang.com/shard/s15/res/3447fe93-de26-4eb3-b358-7bc65b51e8c1/1522765974699.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-2-声明一个简单的-lt-bean-gt\"><a href=\"#4-2-声明一个简单的-lt-bean-gt\" class=\"headerlink\" title=\"4.2 声明一个简单的&lt;bean&gt;\"></a>4.2 声明一个简单的<code>&lt;bean&gt;</code></h4><p><code>&lt;bean&gt;</code>元素元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明<code>CompactDisc</code> bean:<br><code>&lt;bean class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code><br>这里声明了一个很简单的bean,创建这个bean的类通过class属性来指定的,并且要使用全限定的类名。</p>\n<p>因为没有明确给定ID,所以这个bean将会根据全限定类名来进行命名。在本例中,bean的ID将会是“soundsystem.SgtPeppers#0”。其中,“#0”是一个计数的形式,用来区分相同类型的其他bean。如果你声明了另外一个SgtPeppers,并且没有明确进行标识,那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。</p>\n<p>尽管自动化的bean命名方式非常方便,但如果你要稍后引用它的话,那自动产生的名字就没有多大的用处了。因此,通常来讲更好的办法是借助id属性,为每个bean设置一个你自己选择的名字:<br><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code></p>\n<h4 id=\"4-3-借助构造器注入初始化bean\"><a href=\"#4-3-借助构造器注入初始化bean\" class=\"headerlink\" title=\"4.3 借助构造器注入初始化bean\"></a>4.3 借助构造器注入初始化bean</h4><p>在Spring XML配置中,只有一种声明bean的方式:使用<code>&lt;bean&gt;</code>元素并指定class属性。Spring会从这里获取必要的信息来创建bean。但是,在XML中声明DI时,会有多种可选的配置方案和风格。具体到构造器注入,有两种基本的配置方案可供选择：</p>\n<ul>\n<li><code>&lt;constructor-arg&gt;</code>元素</li>\n<li>使用Spring 3.0所引入的c-命名空间</li>\n</ul>\n<p><strong>构造器注入bean引用</strong><br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cdPlayer\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"soundsystem.cdPlayer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"compactDisc\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/4259a7f5-f0b6-4863-93ff-b508cdf8d824/1522766746766.png\" alt=\"Alt text\"></p>\n<p>使用<code>&lt;constructor-arg&gt;</code>元素进行构造器参数的注入</p>\n<h4 id=\"4-4-设置属性\"><a href=\"#4-4-设置属性\" class=\"headerlink\" title=\"4.4 设置属性\"></a>4.4 设置属性</h4><p><code>&lt;property&gt;</code>元素为属性的Setter方法所提供的功能与<code>&lt;constructor-arg&gt;</code>元素为构造器所提供的功能是一样的。<br><img src=\"https://app.yinxiang.com/shard/s15/res/b365723c-f3c5-43d7-934e-088cd6a472f0/1522767233977.png\" alt=\"Alt text\"></p>\n<h3 id=\"5-导入和混合配置\"><a href=\"#5-导入和混合配置\" class=\"headerlink\" title=\"5. 导入和混合配置\"></a>5. 导入和混合配置</h3><p>在典型的Spring应用中,我们可能会同时使用自动化和显式配置。即便你更喜欢通过<br>JavaConfig实现显式配置,但有的时候XML却是最佳的方案。</p>\n<p><strong>关于混合配置,第一件需要了解的事情就是在自动装配时,它并不在意要装配的bean来自哪里。自动装配的时候会考虑到Spring容器中所有的bean,不管它是在JavaConfig或XML中声明的还是通过组件扫描获取到的。</strong></p>\n<h4 id=\"5-1-在JavaConfig中引用XML配置\"><a href=\"#5-1-在JavaConfig中引用XML配置\" class=\"headerlink\" title=\"5.1 在JavaConfig中引用XML配置\"></a>5.1 在JavaConfig中引用XML配置</h4><ol>\n<li><p><code>A</code> JavaConfig类导入 <code>B</code> JavaConfig类：使用<code>@Import</code>注解导入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(CDPlayerConfig.class)</span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(<span class=\"string\">\"classpath:cd-config.xml\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoundSystemConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在JavaConfig中引用XML配置，使用<code>@ImportResource</code>注解，示例同上。</p>\n</li>\n</ol>\n<h4 id=\"5-2-在XML配置中引用JavaConfig\"><a href=\"#5-2-在XML配置中引用JavaConfig\" class=\"headerlink\" title=\"5.2 在XML配置中引用JavaConfig\"></a>5.2 在XML配置中引用JavaConfig</h4><ol>\n<li>两个XML配置文件。使用<code>&lt;import resource=&quot;&quot;&gt;</code>标签<br><code>&lt;import resource=&quot;cdplayer-config.xml&quot;/&gt;</code></li>\n<li>在XML配置中引用JavaConfig。使用<code>&lt;bean&gt;</code>标签。<br><code>&lt;bean class=&quot;soundsystem.CDconfig&quot; /&gt;</code></li>\n</ol>\n<p>好了。在这一个博客中我们看到了在Spring中装配bean的三种方式：自动化配置、基于Java的显示配置和基于XML的显示配置。</p>\n<p>建议使用自动化配置或JavaConfig配置，如果你是在维护一个旧系统，这里也介绍了如何进行混合配置。明天见。</p>"},{"toc":true,"title":"《Spring实战》面向切面的Spring","date":"2018-04-05T02:06:10.000Z","_content":"\n\n在软件开发中,散布于应用中多处的功能被称为横切关注点(cross-cutting concern)。通常来讲,这些横切关注点从概念上是与应用的业务逻辑相分离的(但是往往会直接嵌入到应用的业务逻辑之中)。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。\n\n我们介绍了如何使用依赖注入(DI)管理和配置我们的应用对象。DI有助于应用对象之间的解耦,而AOP可以实现横切关注点与它们所影响的对象之间的解耦。\n<!--more-->\n### 1. 什么是面向切面编程\n#### 1.1 定义AOP术语\n**通知(Advice)**\n切面的工作被称为通知，通知定义了切面是什么以及何时使用。\n\nSpring切面可以应用5种类型的通知：\n- 前置通知(Before):在目标方法被调用之前调用通知功能；\n- 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么;\n- 返回通知(After-returning):在目标方法成功执行之后调用通知;\n- 异常通知(After-throwing):在目标方法抛出异常后调用通知;\n- 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为。\n\n**连接点(Join point)**\n我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中,并添加新的行为。\n\n**切点(Poincut)**\n如果说通知定义了切面的“什么”和“何时”的话,那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称,或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点,可以根据运行时的决策(比如方法的参数值)来决定是否应用通知。\n\n**切面(Aspect)**\n切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么,在何时和何处完成其功能。\n\n**引入(Introduction)**\n引入允许我们向现有的类添加新方法或属性。例如,我们可以创建一个Auditable通知类,该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后,这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改这些现有的类的情况下,让它们具有新的行为和状态。\n\n**织入(Weaving)**\n织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:\n- 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n- 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面。\n- 运行期：切面在应用运行的某个时刻被织入。一般情况下,在织入切面时,AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\n#### 1.2 Spring对AOP的支持\nSpring提供了4种类型的AOP支持：\n- 基于代理的经典Spring AOP;\n- 纯POJO切面;\n- @AspectJ注解驱动的切面;\n- 注入式AspectJ切面(适用于Spring各版本)。\n\n前三种都是Spring AOP实现的变体,Spring AOP构建在动态代理基础之上,因此,Spring对AOP的支持局限于方法拦截。\n\n### 2. 通过切点来选择连接点\n在Spring AOP中,要使用AspectJ的切点表达式语言来定义切点。\n关于Spring AOP的AspectJ切点,最重要的一点就是Spring仅支持AspectJ切点指示器(pointcutdesignator)的一个子集。\n![Alt text](https://app.yinxiang.com/shard/s15/res/32c0c7c3-3903-458a-9f51-40dfc1843123/1522831830709.png)\n在Spring中尝试使用AspectJ其他指示器时,将会抛出IllegalArgument-Exception异\n常。当我们查看如上所展示的这些Spring支持的指示器时,注意只有execution指示器是实际执行匹配的,而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上,我们使用其他指示器来限制所匹配的切点。\n\n#### 2.1 编写切点\n**exeution()**\n格式：\n`execution(返回类型 类名(参数类型)[异常类型])`\n返回类型：必需，`*`表示所有返回类型\n类名：必需，`a.*.*`表示`a`包下的所有类的所有方法，`set*`表示以`set`开头的方法。\n参数类型：必需，`(..)`代表所有参数,`(*)`代表一个参数,`(*,String)`代表第一个参数为任何值,第二个为String类型.\n\n示例1：\n![Alt text](https://app.yinxiang.com/shard/s15/res/f93d95bc-1687-491d-af85-32efd6953518/1522890366397.png)\n\n示例2：\n![Alt text](https://app.yinxiang.com/shard/s15/res/bfa34aee-1c92-4041-8e05-e1ac59b6391a/1522890430573.png)\n请注意我们使用了“&&”操作符把execution()和within()指示器连接在一起形成与(and)关系(切点必须匹配所有的指示器)。类似地,我们可以使用“||”操作符来标识或\n(or)关系,而使用“!”操作符来标识非(not)操作。因为“&”在XML中有特殊含义,所以在Spring的XML配置里面描述切点时,我们可以使用and来代替“&&”。同样,or和not可以分别用来代替“||”和“!”。\n\n除了以上的切点指示器，Spring引入了一个新的`bean()`指示器，它允许我们在切点表达式中使用bean的ID来标识`bean`\n\n### 3. 使用注解定义切面\n`@Aspect`：应用在类上声明该类为一个切面。\n【示例】：\n```java\n@Aspect\n@Component\npublic class AopLog {\n    private static final Logger LOG = LoggerFactory\n            .getLogger(AopLog.class);\n\n    @Pointcut(\"execution( * com.stepbystep.spring4.samples.aop.*.*(..))\")\n    public void aspect(){}\n\n    @Around(\"aspect()\")\n    public Object around(JoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        try {\n            LOG.info(\"=======before {}\",joinPoint.getSignature().getName());\n            Object proceed = ((ProceedingJoinPoint) joinPoint).proceed();\n            LOG.info(\"=======after {}\",joinPoint.getSignature().getName());\n            long end = System.currentTimeMillis();\n                LOG.info(\"around \" + joinPoint + \"\\tUse time : \" + (end - start) + \" ms!\");\n            return proceed;\n        } catch (Throwable e) {\n            LOG.error(e.getMessage(),e);\n            long end = System.currentTimeMillis();\n            LOG.info(\"around \" + joinPoint + \"\\tUse time : \" + (end - start) + \" ms with exception : \" + e.getMessage());\n            throw e;\n        }\n    }\n}\n```\nAspectJ提供了五个注解来定义通知：\n![Alt text](https://app.yinxiang.com/shard/s15/res/cc518a43-f3f0-4c98-a539-03a26d6d3bf8/1522891975846.png)\n这五个表达式接收`execution()`等切点表达式。\n\n\n`@Pointcut`注解：能够在一个@AspectJ切面内定义可重用的切点。\n\n关于这个新的通知方法,你首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的,因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情,当要将控制权交给被通知的方法时,它需要调用ProceedingJoinPoint的proceed()方法。\n\n如果你就此止步的话,Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解,但它并不会被视为切面,这些注解不会解析,也不会创建将其转换为切面的代理。\n\n如果你使用JavaConfig配置，可以在配置类的类级别上加上`@EnableAspectJAutoProxy`注解启用自动代理功能。\n\n假如你在Spring中要使用XML来装配bean的话,那么需要使用Spring aop命名空间中的`<aop:aspectj-autoproxy>`元素。下面的XML配置展现了如何完成该功能。\n\n不管你是使用JavaConfig还是XML,AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理,这个代理会围绕着所有该切面的切点所匹配的bean。\n\n**处理通知中的参数**\n如果切面所通知的方法确实有参数该怎么办呢？切面能访问和使用传递给被通知方法的参数吗？\n答案是可以的。我们可以使用`@args(参数名称)`注解。它表明传递给playTrack()方法的int类型参数也会传递到通知中去。`参数名称`也与切点方法签名中的参数想匹配。切点定义中的参数与切点方法中的参数名称是一样的,这样就完成了从命名切点到通知方法的参数转移。\n\n示例：\n```java\n@Aspect\npublic class TrackCounter {\n\n    @Pointcut(\n            \"execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)\"\n    )\n    public void trackPlayed(int trackNumber) {\n    }\n\n    @Before(\"trackPlayed(trackNumber)\")\n    public void countTrack(int trackNumber){\n        ...\n    }\n}\n```\n\n### 4. 通过注解引入新的功能\n参考：https://blog.csdn.net/u010502101/article/details/76944753\n\n\n","source":"_posts/《Spring实战》面向切面的Spring.md","raw":"---\ntoc: true\ntitle: 《Spring实战》面向切面的Spring\ndate: 2018-04-05 10:06:10\ntags: [Spring,aop]\n---\n\n\n在软件开发中,散布于应用中多处的功能被称为横切关注点(cross-cutting concern)。通常来讲,这些横切关注点从概念上是与应用的业务逻辑相分离的(但是往往会直接嵌入到应用的业务逻辑之中)。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。\n\n我们介绍了如何使用依赖注入(DI)管理和配置我们的应用对象。DI有助于应用对象之间的解耦,而AOP可以实现横切关注点与它们所影响的对象之间的解耦。\n<!--more-->\n### 1. 什么是面向切面编程\n#### 1.1 定义AOP术语\n**通知(Advice)**\n切面的工作被称为通知，通知定义了切面是什么以及何时使用。\n\nSpring切面可以应用5种类型的通知：\n- 前置通知(Before):在目标方法被调用之前调用通知功能；\n- 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么;\n- 返回通知(After-returning):在目标方法成功执行之后调用通知;\n- 异常通知(After-throwing):在目标方法抛出异常后调用通知;\n- 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为。\n\n**连接点(Join point)**\n我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中,并添加新的行为。\n\n**切点(Poincut)**\n如果说通知定义了切面的“什么”和“何时”的话,那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称,或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点,可以根据运行时的决策(比如方法的参数值)来决定是否应用通知。\n\n**切面(Aspect)**\n切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么,在何时和何处完成其功能。\n\n**引入(Introduction)**\n引入允许我们向现有的类添加新方法或属性。例如,我们可以创建一个Auditable通知类,该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后,这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改这些现有的类的情况下,让它们具有新的行为和状态。\n\n**织入(Weaving)**\n织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:\n- 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n- 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面。\n- 运行期：切面在应用运行的某个时刻被织入。一般情况下,在织入切面时,AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\n#### 1.2 Spring对AOP的支持\nSpring提供了4种类型的AOP支持：\n- 基于代理的经典Spring AOP;\n- 纯POJO切面;\n- @AspectJ注解驱动的切面;\n- 注入式AspectJ切面(适用于Spring各版本)。\n\n前三种都是Spring AOP实现的变体,Spring AOP构建在动态代理基础之上,因此,Spring对AOP的支持局限于方法拦截。\n\n### 2. 通过切点来选择连接点\n在Spring AOP中,要使用AspectJ的切点表达式语言来定义切点。\n关于Spring AOP的AspectJ切点,最重要的一点就是Spring仅支持AspectJ切点指示器(pointcutdesignator)的一个子集。\n![Alt text](https://app.yinxiang.com/shard/s15/res/32c0c7c3-3903-458a-9f51-40dfc1843123/1522831830709.png)\n在Spring中尝试使用AspectJ其他指示器时,将会抛出IllegalArgument-Exception异\n常。当我们查看如上所展示的这些Spring支持的指示器时,注意只有execution指示器是实际执行匹配的,而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上,我们使用其他指示器来限制所匹配的切点。\n\n#### 2.1 编写切点\n**exeution()**\n格式：\n`execution(返回类型 类名(参数类型)[异常类型])`\n返回类型：必需，`*`表示所有返回类型\n类名：必需，`a.*.*`表示`a`包下的所有类的所有方法，`set*`表示以`set`开头的方法。\n参数类型：必需，`(..)`代表所有参数,`(*)`代表一个参数,`(*,String)`代表第一个参数为任何值,第二个为String类型.\n\n示例1：\n![Alt text](https://app.yinxiang.com/shard/s15/res/f93d95bc-1687-491d-af85-32efd6953518/1522890366397.png)\n\n示例2：\n![Alt text](https://app.yinxiang.com/shard/s15/res/bfa34aee-1c92-4041-8e05-e1ac59b6391a/1522890430573.png)\n请注意我们使用了“&&”操作符把execution()和within()指示器连接在一起形成与(and)关系(切点必须匹配所有的指示器)。类似地,我们可以使用“||”操作符来标识或\n(or)关系,而使用“!”操作符来标识非(not)操作。因为“&”在XML中有特殊含义,所以在Spring的XML配置里面描述切点时,我们可以使用and来代替“&&”。同样,or和not可以分别用来代替“||”和“!”。\n\n除了以上的切点指示器，Spring引入了一个新的`bean()`指示器，它允许我们在切点表达式中使用bean的ID来标识`bean`\n\n### 3. 使用注解定义切面\n`@Aspect`：应用在类上声明该类为一个切面。\n【示例】：\n```java\n@Aspect\n@Component\npublic class AopLog {\n    private static final Logger LOG = LoggerFactory\n            .getLogger(AopLog.class);\n\n    @Pointcut(\"execution( * com.stepbystep.spring4.samples.aop.*.*(..))\")\n    public void aspect(){}\n\n    @Around(\"aspect()\")\n    public Object around(JoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        try {\n            LOG.info(\"=======before {}\",joinPoint.getSignature().getName());\n            Object proceed = ((ProceedingJoinPoint) joinPoint).proceed();\n            LOG.info(\"=======after {}\",joinPoint.getSignature().getName());\n            long end = System.currentTimeMillis();\n                LOG.info(\"around \" + joinPoint + \"\\tUse time : \" + (end - start) + \" ms!\");\n            return proceed;\n        } catch (Throwable e) {\n            LOG.error(e.getMessage(),e);\n            long end = System.currentTimeMillis();\n            LOG.info(\"around \" + joinPoint + \"\\tUse time : \" + (end - start) + \" ms with exception : \" + e.getMessage());\n            throw e;\n        }\n    }\n}\n```\nAspectJ提供了五个注解来定义通知：\n![Alt text](https://app.yinxiang.com/shard/s15/res/cc518a43-f3f0-4c98-a539-03a26d6d3bf8/1522891975846.png)\n这五个表达式接收`execution()`等切点表达式。\n\n\n`@Pointcut`注解：能够在一个@AspectJ切面内定义可重用的切点。\n\n关于这个新的通知方法,你首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的,因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情,当要将控制权交给被通知的方法时,它需要调用ProceedingJoinPoint的proceed()方法。\n\n如果你就此止步的话,Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解,但它并不会被视为切面,这些注解不会解析,也不会创建将其转换为切面的代理。\n\n如果你使用JavaConfig配置，可以在配置类的类级别上加上`@EnableAspectJAutoProxy`注解启用自动代理功能。\n\n假如你在Spring中要使用XML来装配bean的话,那么需要使用Spring aop命名空间中的`<aop:aspectj-autoproxy>`元素。下面的XML配置展现了如何完成该功能。\n\n不管你是使用JavaConfig还是XML,AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理,这个代理会围绕着所有该切面的切点所匹配的bean。\n\n**处理通知中的参数**\n如果切面所通知的方法确实有参数该怎么办呢？切面能访问和使用传递给被通知方法的参数吗？\n答案是可以的。我们可以使用`@args(参数名称)`注解。它表明传递给playTrack()方法的int类型参数也会传递到通知中去。`参数名称`也与切点方法签名中的参数想匹配。切点定义中的参数与切点方法中的参数名称是一样的,这样就完成了从命名切点到通知方法的参数转移。\n\n示例：\n```java\n@Aspect\npublic class TrackCounter {\n\n    @Pointcut(\n            \"execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)\"\n    )\n    public void trackPlayed(int trackNumber) {\n    }\n\n    @Before(\"trackPlayed(trackNumber)\")\n    public void countTrack(int trackNumber){\n        ...\n    }\n}\n```\n\n### 4. 通过注解引入新的功能\n参考：https://blog.csdn.net/u010502101/article/details/76944753\n\n\n","slug":"《Spring实战》面向切面的Spring","published":1,"updated":"2018-08-13T14:28:27.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5o002q6k15yftm7u1d","content":"<p>在软件开发中,散布于应用中多处的功能被称为横切关注点(cross-cutting concern)。通常来讲,这些横切关注点从概念上是与应用的业务逻辑相分离的(但是往往会直接嵌入到应用的业务逻辑之中)。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。</p>\n<p>我们介绍了如何使用依赖注入(DI)管理和配置我们的应用对象。DI有助于应用对象之间的解耦,而AOP可以实现横切关注点与它们所影响的对象之间的解耦。<br><a id=\"more\"></a></p>\n<h3 id=\"1-什么是面向切面编程\"><a href=\"#1-什么是面向切面编程\" class=\"headerlink\" title=\"1. 什么是面向切面编程\"></a>1. 什么是面向切面编程</h3><h4 id=\"1-1-定义AOP术语\"><a href=\"#1-1-定义AOP术语\" class=\"headerlink\" title=\"1.1 定义AOP术语\"></a>1.1 定义AOP术语</h4><p><strong>通知(Advice)</strong><br>切面的工作被称为通知，通知定义了切面是什么以及何时使用。</p>\n<p>Spring切面可以应用5种类型的通知：</p>\n<ul>\n<li>前置通知(Before):在目标方法被调用之前调用通知功能；</li>\n<li>后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么;</li>\n<li>返回通知(After-returning):在目标方法成功执行之后调用通知;</li>\n<li>异常通知(After-throwing):在目标方法抛出异常后调用通知;</li>\n<li>环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ul>\n<p><strong>连接点(Join point)</strong><br>我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中,并添加新的行为。</p>\n<p><strong>切点(Poincut)</strong><br>如果说通知定义了切面的“什么”和“何时”的话,那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称,或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点,可以根据运行时的决策(比如方法的参数值)来决定是否应用通知。</p>\n<p><strong>切面(Aspect)</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么,在何时和何处完成其功能。</p>\n<p><strong>引入(Introduction)</strong><br>引入允许我们向现有的类添加新方法或属性。例如,我们可以创建一个Auditable通知类,该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后,这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改这些现有的类的情况下,让它们具有新的行为和状态。</p>\n<p><strong>织入(Weaving)</strong><br>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:</p>\n<ul>\n<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下,在织入切面时,AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>\n</ul>\n<h4 id=\"1-2-Spring对AOP的支持\"><a href=\"#1-2-Spring对AOP的支持\" class=\"headerlink\" title=\"1.2 Spring对AOP的支持\"></a>1.2 Spring对AOP的支持</h4><p>Spring提供了4种类型的AOP支持：</p>\n<ul>\n<li>基于代理的经典Spring AOP;</li>\n<li>纯POJO切面;</li>\n<li>@AspectJ注解驱动的切面;</li>\n<li>注入式AspectJ切面(适用于Spring各版本)。</li>\n</ul>\n<p>前三种都是Spring AOP实现的变体,Spring AOP构建在动态代理基础之上,因此,Spring对AOP的支持局限于方法拦截。</p>\n<h3 id=\"2-通过切点来选择连接点\"><a href=\"#2-通过切点来选择连接点\" class=\"headerlink\" title=\"2. 通过切点来选择连接点\"></a>2. 通过切点来选择连接点</h3><p>在Spring AOP中,要使用AspectJ的切点表达式语言来定义切点。<br>关于Spring AOP的AspectJ切点,最重要的一点就是Spring仅支持AspectJ切点指示器(pointcutdesignator)的一个子集。<br><img src=\"https://app.yinxiang.com/shard/s15/res/32c0c7c3-3903-458a-9f51-40dfc1843123/1522831830709.png\" alt=\"Alt text\"><br>在Spring中尝试使用AspectJ其他指示器时,将会抛出IllegalArgument-Exception异<br>常。当我们查看如上所展示的这些Spring支持的指示器时,注意只有execution指示器是实际执行匹配的,而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上,我们使用其他指示器来限制所匹配的切点。</p>\n<h4 id=\"2-1-编写切点\"><a href=\"#2-1-编写切点\" class=\"headerlink\" title=\"2.1 编写切点\"></a>2.1 编写切点</h4><p><strong>exeution()</strong><br>格式：<br><code>execution(返回类型 类名(参数类型)[异常类型])</code><br>返回类型：必需，<code>*</code>表示所有返回类型<br>类名：必需，<code>a.*.*</code>表示<code>a</code>包下的所有类的所有方法，<code>set*</code>表示以<code>set</code>开头的方法。<br>参数类型：必需，<code>(..)</code>代表所有参数,<code>(*)</code>代表一个参数,<code>(*,String)</code>代表第一个参数为任何值,第二个为String类型.</p>\n<p>示例1：<br><img src=\"https://app.yinxiang.com/shard/s15/res/f93d95bc-1687-491d-af85-32efd6953518/1522890366397.png\" alt=\"Alt text\"></p>\n<p>示例2：<br><img src=\"https://app.yinxiang.com/shard/s15/res/bfa34aee-1c92-4041-8e05-e1ac59b6391a/1522890430573.png\" alt=\"Alt text\"><br>请注意我们使用了“&amp;&amp;”操作符把execution()和within()指示器连接在一起形成与(and)关系(切点必须匹配所有的指示器)。类似地,我们可以使用“||”操作符来标识或<br>(or)关系,而使用“!”操作符来标识非(not)操作。因为“&amp;”在XML中有特殊含义,所以在Spring的XML配置里面描述切点时,我们可以使用and来代替“&amp;&amp;”。同样,or和not可以分别用来代替“||”和“!”。</p>\n<p>除了以上的切点指示器，Spring引入了一个新的<code>bean()</code>指示器，它允许我们在切点表达式中使用bean的ID来标识<code>bean</code></p>\n<h3 id=\"3-使用注解定义切面\"><a href=\"#3-使用注解定义切面\" class=\"headerlink\" title=\"3. 使用注解定义切面\"></a>3. 使用注解定义切面</h3><p><code>@Aspect</code>：应用在类上声明该类为一个切面。<br>【示例】：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</span><br><span class=\"line\">            .getLogger(AopLog.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution( * com.stepbystep.spring4.samples.aop.*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">aspect</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"aspect()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"=======before &#123;&#125;\"</span>,joinPoint.getSignature().getName());</span><br><span class=\"line\">            Object proceed = ((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"=======after &#123;&#125;\"</span>,joinPoint.getSignature().getName());</span><br><span class=\"line\">            <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">                LOG.info(<span class=\"string\">\"around \"</span> + joinPoint + <span class=\"string\">\"\\tUse time : \"</span> + (end - start) + <span class=\"string\">\" ms!\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            LOG.error(e.getMessage(),e);</span><br><span class=\"line\">            <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"around \"</span> + joinPoint + <span class=\"string\">\"\\tUse time : \"</span> + (end - start) + <span class=\"string\">\" ms with exception : \"</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AspectJ提供了五个注解来定义通知：<br><img src=\"https://app.yinxiang.com/shard/s15/res/cc518a43-f3f0-4c98-a539-03a26d6d3bf8/1522891975846.png\" alt=\"Alt text\"><br>这五个表达式接收<code>execution()</code>等切点表达式。</p>\n<p><code>@Pointcut</code>注解：能够在一个@AspectJ切面内定义可重用的切点。</p>\n<p>关于这个新的通知方法,你首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的,因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情,当要将控制权交给被通知的方法时,它需要调用ProceedingJoinPoint的proceed()方法。</p>\n<p>如果你就此止步的话,Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解,但它并不会被视为切面,这些注解不会解析,也不会创建将其转换为切面的代理。</p>\n<p>如果你使用JavaConfig配置，可以在配置类的类级别上加上<code>@EnableAspectJAutoProxy</code>注解启用自动代理功能。</p>\n<p>假如你在Spring中要使用XML来装配bean的话,那么需要使用Spring aop命名空间中的<code>&lt;aop:aspectj-autoproxy&gt;</code>元素。下面的XML配置展现了如何完成该功能。</p>\n<p>不管你是使用JavaConfig还是XML,AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理,这个代理会围绕着所有该切面的切点所匹配的bean。</p>\n<p><strong>处理通知中的参数</strong><br>如果切面所通知的方法确实有参数该怎么办呢？切面能访问和使用传递给被通知方法的参数吗？<br>答案是可以的。我们可以使用<code>@args(参数名称)</code>注解。它表明传递给playTrack()方法的int类型参数也会传递到通知中去。<code>参数名称</code>也与切点方法签名中的参数想匹配。切点定义中的参数与切点方法中的参数名称是一样的,这样就完成了从命名切点到通知方法的参数转移。</p>\n<p>示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackCounter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(</span><br><span class=\"line\">            <span class=\"string\">\"execution(* soundsystem.CompactDisc.playTrack(int)) &amp;&amp; args(trackNumber)\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trackPlayed</span><span class=\"params\">(<span class=\"keyword\">int</span> trackNumber)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"trackPlayed(trackNumber)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countTrack</span><span class=\"params\">(<span class=\"keyword\">int</span> trackNumber)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-通过注解引入新的功能\"><a href=\"#4-通过注解引入新的功能\" class=\"headerlink\" title=\"4. 通过注解引入新的功能\"></a>4. 通过注解引入新的功能</h3><p>参考：<a href=\"https://blog.csdn.net/u010502101/article/details/76944753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010502101/article/details/76944753</a></p>\n","site":{"data":{}},"excerpt":"<p>在软件开发中,散布于应用中多处的功能被称为横切关注点(cross-cutting concern)。通常来讲,这些横切关注点从概念上是与应用的业务逻辑相分离的(但是往往会直接嵌入到应用的业务逻辑之中)。把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。</p>\n<p>我们介绍了如何使用依赖注入(DI)管理和配置我们的应用对象。DI有助于应用对象之间的解耦,而AOP可以实现横切关注点与它们所影响的对象之间的解耦。<br>","more":"</p>\n<h3 id=\"1-什么是面向切面编程\"><a href=\"#1-什么是面向切面编程\" class=\"headerlink\" title=\"1. 什么是面向切面编程\"></a>1. 什么是面向切面编程</h3><h4 id=\"1-1-定义AOP术语\"><a href=\"#1-1-定义AOP术语\" class=\"headerlink\" title=\"1.1 定义AOP术语\"></a>1.1 定义AOP术语</h4><p><strong>通知(Advice)</strong><br>切面的工作被称为通知，通知定义了切面是什么以及何时使用。</p>\n<p>Spring切面可以应用5种类型的通知：</p>\n<ul>\n<li>前置通知(Before):在目标方法被调用之前调用通知功能；</li>\n<li>后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么;</li>\n<li>返回通知(After-returning):在目标方法成功执行之后调用通知;</li>\n<li>异常通知(After-throwing):在目标方法抛出异常后调用通知;</li>\n<li>环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ul>\n<p><strong>连接点(Join point)</strong><br>我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中,并添加新的行为。</p>\n<p><strong>切点(Poincut)</strong><br>如果说通知定义了切面的“什么”和“何时”的话,那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称,或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点,可以根据运行时的决策(比如方法的参数值)来决定是否应用通知。</p>\n<p><strong>切面(Aspect)</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么,在何时和何处完成其功能。</p>\n<p><strong>引入(Introduction)</strong><br>引入允许我们向现有的类添加新方法或属性。例如,我们可以创建一个Auditable通知类,该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后,这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改这些现有的类的情况下,让它们具有新的行为和状态。</p>\n<p><strong>织入(Weaving)</strong><br>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:</p>\n<ul>\n<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下,在织入切面时,AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>\n</ul>\n<h4 id=\"1-2-Spring对AOP的支持\"><a href=\"#1-2-Spring对AOP的支持\" class=\"headerlink\" title=\"1.2 Spring对AOP的支持\"></a>1.2 Spring对AOP的支持</h4><p>Spring提供了4种类型的AOP支持：</p>\n<ul>\n<li>基于代理的经典Spring AOP;</li>\n<li>纯POJO切面;</li>\n<li>@AspectJ注解驱动的切面;</li>\n<li>注入式AspectJ切面(适用于Spring各版本)。</li>\n</ul>\n<p>前三种都是Spring AOP实现的变体,Spring AOP构建在动态代理基础之上,因此,Spring对AOP的支持局限于方法拦截。</p>\n<h3 id=\"2-通过切点来选择连接点\"><a href=\"#2-通过切点来选择连接点\" class=\"headerlink\" title=\"2. 通过切点来选择连接点\"></a>2. 通过切点来选择连接点</h3><p>在Spring AOP中,要使用AspectJ的切点表达式语言来定义切点。<br>关于Spring AOP的AspectJ切点,最重要的一点就是Spring仅支持AspectJ切点指示器(pointcutdesignator)的一个子集。<br><img src=\"https://app.yinxiang.com/shard/s15/res/32c0c7c3-3903-458a-9f51-40dfc1843123/1522831830709.png\" alt=\"Alt text\"><br>在Spring中尝试使用AspectJ其他指示器时,将会抛出IllegalArgument-Exception异<br>常。当我们查看如上所展示的这些Spring支持的指示器时,注意只有execution指示器是实际执行匹配的,而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上,我们使用其他指示器来限制所匹配的切点。</p>\n<h4 id=\"2-1-编写切点\"><a href=\"#2-1-编写切点\" class=\"headerlink\" title=\"2.1 编写切点\"></a>2.1 编写切点</h4><p><strong>exeution()</strong><br>格式：<br><code>execution(返回类型 类名(参数类型)[异常类型])</code><br>返回类型：必需，<code>*</code>表示所有返回类型<br>类名：必需，<code>a.*.*</code>表示<code>a</code>包下的所有类的所有方法，<code>set*</code>表示以<code>set</code>开头的方法。<br>参数类型：必需，<code>(..)</code>代表所有参数,<code>(*)</code>代表一个参数,<code>(*,String)</code>代表第一个参数为任何值,第二个为String类型.</p>\n<p>示例1：<br><img src=\"https://app.yinxiang.com/shard/s15/res/f93d95bc-1687-491d-af85-32efd6953518/1522890366397.png\" alt=\"Alt text\"></p>\n<p>示例2：<br><img src=\"https://app.yinxiang.com/shard/s15/res/bfa34aee-1c92-4041-8e05-e1ac59b6391a/1522890430573.png\" alt=\"Alt text\"><br>请注意我们使用了“&amp;&amp;”操作符把execution()和within()指示器连接在一起形成与(and)关系(切点必须匹配所有的指示器)。类似地,我们可以使用“||”操作符来标识或<br>(or)关系,而使用“!”操作符来标识非(not)操作。因为“&amp;”在XML中有特殊含义,所以在Spring的XML配置里面描述切点时,我们可以使用and来代替“&amp;&amp;”。同样,or和not可以分别用来代替“||”和“!”。</p>\n<p>除了以上的切点指示器，Spring引入了一个新的<code>bean()</code>指示器，它允许我们在切点表达式中使用bean的ID来标识<code>bean</code></p>\n<h3 id=\"3-使用注解定义切面\"><a href=\"#3-使用注解定义切面\" class=\"headerlink\" title=\"3. 使用注解定义切面\"></a>3. 使用注解定义切面</h3><p><code>@Aspect</code>：应用在类上声明该类为一个切面。<br>【示例】：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AopLog</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</span><br><span class=\"line\">            .getLogger(AopLog.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution( * com.stepbystep.spring4.samples.aop.*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">aspect</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around</span>(<span class=\"string\">\"aspect()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">around</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"=======before &#123;&#125;\"</span>,joinPoint.getSignature().getName());</span><br><span class=\"line\">            Object proceed = ((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"=======after &#123;&#125;\"</span>,joinPoint.getSignature().getName());</span><br><span class=\"line\">            <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">                LOG.info(<span class=\"string\">\"around \"</span> + joinPoint + <span class=\"string\">\"\\tUse time : \"</span> + (end - start) + <span class=\"string\">\" ms!\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            LOG.error(e.getMessage(),e);</span><br><span class=\"line\">            <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">            LOG.info(<span class=\"string\">\"around \"</span> + joinPoint + <span class=\"string\">\"\\tUse time : \"</span> + (end - start) + <span class=\"string\">\" ms with exception : \"</span> + e.getMessage());</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AspectJ提供了五个注解来定义通知：<br><img src=\"https://app.yinxiang.com/shard/s15/res/cc518a43-f3f0-4c98-a539-03a26d6d3bf8/1522891975846.png\" alt=\"Alt text\"><br>这五个表达式接收<code>execution()</code>等切点表达式。</p>\n<p><code>@Pointcut</code>注解：能够在一个@AspectJ切面内定义可重用的切点。</p>\n<p>关于这个新的通知方法,你首先注意到的可能是它接受ProceedingJoinPoint作为参数。这个对象是必须要有的,因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情,当要将控制权交给被通知的方法时,它需要调用ProceedingJoinPoint的proceed()方法。</p>\n<p>如果你就此止步的话,Audience只会是Spring容器中的一个bean。即便使用了AspectJ注解,但它并不会被视为切面,这些注解不会解析,也不会创建将其转换为切面的代理。</p>\n<p>如果你使用JavaConfig配置，可以在配置类的类级别上加上<code>@EnableAspectJAutoProxy</code>注解启用自动代理功能。</p>\n<p>假如你在Spring中要使用XML来装配bean的话,那么需要使用Spring aop命名空间中的<code>&lt;aop:aspectj-autoproxy&gt;</code>元素。下面的XML配置展现了如何完成该功能。</p>\n<p>不管你是使用JavaConfig还是XML,AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理,这个代理会围绕着所有该切面的切点所匹配的bean。</p>\n<p><strong>处理通知中的参数</strong><br>如果切面所通知的方法确实有参数该怎么办呢？切面能访问和使用传递给被通知方法的参数吗？<br>答案是可以的。我们可以使用<code>@args(参数名称)</code>注解。它表明传递给playTrack()方法的int类型参数也会传递到通知中去。<code>参数名称</code>也与切点方法签名中的参数想匹配。切点定义中的参数与切点方法中的参数名称是一样的,这样就完成了从命名切点到通知方法的参数转移。</p>\n<p>示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackCounter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(</span><br><span class=\"line\">            <span class=\"string\">\"execution(* soundsystem.CompactDisc.playTrack(int)) &amp;&amp; args(trackNumber)\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trackPlayed</span><span class=\"params\">(<span class=\"keyword\">int</span> trackNumber)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"trackPlayed(trackNumber)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countTrack</span><span class=\"params\">(<span class=\"keyword\">int</span> trackNumber)</span></span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-通过注解引入新的功能\"><a href=\"#4-通过注解引入新的功能\" class=\"headerlink\" title=\"4. 通过注解引入新的功能\"></a>4. 通过注解引入新的功能</h3><p>参考：<a href=\"https://blog.csdn.net/u010502101/article/details/76944753\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010502101/article/details/76944753</a></p>"},{"toc":true,"title":"《提问的智慧》笔记","date":"2018-01-18T06:05:43.000Z","_content":"\n## 简介\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。\n<!--more-->\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。\n\n但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n\n## 在提问之前\n\n---\n在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n2. 尝试上网搜索以找到答案。\n3. 尝试阅读手册以找到答案。\n4. 尝试阅读常见问题文件（FAQ）以找到答案。\n5. 尝试自己检查或试验以找到答案\n6. 向你身边的强者朋友打听以找到答案。\n7. 如果你是程序开发者，请尝试阅读源代码以找到答案。\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 --一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n\n## 当你提问时\n\n---\n### 慎选提问的论坛\n小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n在与主题不合的论坛上贴出你的问题\n在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然\n在太多的不同新闻群组上重复转贴同样的问题（cross-post）\n向既非熟人也没有义务解决你问题的人发送私人电邮\n\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 -- 如果你不确定，那就向别处发送，或者压根别发。\n\n别像机关枪似的一次\"扫射\"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n\n### Stack OverFlow\n搜索，然后 在 Stack Exchange 问。\n用标签（Tag）搜索能让你更缩小你的搜索结果。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\n\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是- - 写程序无关，只是一些网络连线之类的，请到这里。\n- Stack Overflow 是问写程序有关的问题。\n- Server Fault 是问服务器和网管相关的问题。\n\n### 第二步，使用项目邮件列表\n当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n\n- 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。\n- 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n- 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n- 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n### 使用有意义且描述明确的标题\n在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n\n一个好标题范例是目标 -- 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n> 蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n> 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。\n> 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n### 使问题容易回复\n\n### 用清晰、正确、精准并语法正确的语句\n我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：\n> English is not my native language; please excuse typing errors.\n\n### 使用易于读取且标准的文件格式发送问题\n- 使用纯文字而不是 HTML\n- 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。\n- 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。\n\n### 精确的描述问题并言之有物\n- 仔细、清楚地描述你的问题或 Bug 的症状。\n- 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。\n- 描述在提问前你是怎样去研究和理解这个问题的。\n- 描述在提问前为确定问题而采取的诊断步骤。\n- 描述最近做过什么可能相关的硬件或软件变更。\n- 尽可能的提供一个可以重现这个问题的可控环境的方法。\n\n### 别动辄声称找到 Bug\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n\n### 低声下气不能代替你的功课\n有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 -- 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n\n### 描述问题症状而非你的猜测\n\n### 描述目标而不是过程\n如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n\n### 问题解决后，加个简短的补充说明\n问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。\n\n### RTFM 和 STFW：如何知道你已完全搞砸了 \n\n如何更好地回答问题\n\n态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n\n对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n\n如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n\n如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 --有些可怜的呆瓜会把它当成真的指令。\n\n试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 --你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n\n尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。\n\n如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。\n\n正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。\n\n帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。\n\n如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。\n\n","source":"_posts/《提问的智慧》笔记.md","raw":"---\ntoc: true\ntitle: 《提问的智慧》笔记\ndate: 2018-01-18 14:05:43\ntags: 提问的智慧\n---\n\n## 简介\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。\n<!--more-->\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。\n\n但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n\n## 在提问之前\n\n---\n在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n2. 尝试上网搜索以找到答案。\n3. 尝试阅读手册以找到答案。\n4. 尝试阅读常见问题文件（FAQ）以找到答案。\n5. 尝试自己检查或试验以找到答案\n6. 向你身边的强者朋友打听以找到答案。\n7. 如果你是程序开发者，请尝试阅读源代码以找到答案。\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 --一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n\n## 当你提问时\n\n---\n### 慎选提问的论坛\n小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n在与主题不合的论坛上贴出你的问题\n在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然\n在太多的不同新闻群组上重复转贴同样的问题（cross-post）\n向既非熟人也没有义务解决你问题的人发送私人电邮\n\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 -- 如果你不确定，那就向别处发送，或者压根别发。\n\n别像机关枪似的一次\"扫射\"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n\n### Stack OverFlow\n搜索，然后 在 Stack Exchange 问。\n用标签（Tag）搜索能让你更缩小你的搜索结果。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\n\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是- - 写程序无关，只是一些网络连线之类的，请到这里。\n- Stack Overflow 是问写程序有关的问题。\n- Server Fault 是问服务器和网管相关的问题。\n\n### 第二步，使用项目邮件列表\n当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n\n- 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。\n- 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n- 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n- 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n### 使用有意义且描述明确的标题\n在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n\n一个好标题范例是目标 -- 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n> 蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n> 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。\n> 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n### 使问题容易回复\n\n### 用清晰、正确、精准并语法正确的语句\n我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：\n> English is not my native language; please excuse typing errors.\n\n### 使用易于读取且标准的文件格式发送问题\n- 使用纯文字而不是 HTML\n- 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。\n- 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。\n\n### 精确的描述问题并言之有物\n- 仔细、清楚地描述你的问题或 Bug 的症状。\n- 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。\n- 描述在提问前你是怎样去研究和理解这个问题的。\n- 描述在提问前为确定问题而采取的诊断步骤。\n- 描述最近做过什么可能相关的硬件或软件变更。\n- 尽可能的提供一个可以重现这个问题的可控环境的方法。\n\n### 别动辄声称找到 Bug\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n\n### 低声下气不能代替你的功课\n有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 -- 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n\n### 描述问题症状而非你的猜测\n\n### 描述目标而不是过程\n如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n\n### 问题解决后，加个简短的补充说明\n问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。\n\n### RTFM 和 STFW：如何知道你已完全搞砸了 \n\n如何更好地回答问题\n\n态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n\n对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n\n如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n\n如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 --有些可怜的呆瓜会把它当成真的指令。\n\n试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 --你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n\n尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。\n\n如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。\n\n正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。\n\n帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。\n\n如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。\n\n","slug":"《提问的智慧》笔记","published":1,"updated":"2018-08-13T14:28:27.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5p002s6k1572avkobh","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。<br><a id=\"more\"></a><br>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。</p>\n<p>但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p>\n<h2 id=\"在提问之前\"><a href=\"#在提问之前\" class=\"headerlink\" title=\"在提问之前\"></a>在提问之前</h2><hr>\n<p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p>\n<ol>\n<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>\n<li>尝试上网搜索以找到答案。</li>\n<li>尝试阅读手册以找到答案。</li>\n<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>\n<li>尝试自己检查或试验以找到答案</li>\n<li>向你身边的强者朋友打听以找到答案。</li>\n<li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li>\n</ol>\n<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p>\n<p>绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p>\n<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>\n<h2 id=\"当你提问时\"><a href=\"#当你提问时\" class=\"headerlink\" title=\"当你提问时\"></a>当你提问时</h2><hr>\n<h3 id=\"慎选提问的论坛\"><a href=\"#慎选提问的论坛\" class=\"headerlink\" title=\"慎选提问的论坛\"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>\n<p>在与主题不合的论坛上贴出你的问题<br>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然<br>在太多的不同新闻群组上重复转贴同样的问题（cross-post）<br>向既非熟人也没有义务解决你问题的人发送私人电邮</p>\n<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p>\n<p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>\n<h3 id=\"Stack-OverFlow\"><a href=\"#Stack-OverFlow\" class=\"headerlink\" title=\"Stack OverFlow\"></a>Stack OverFlow</h3><p>搜索，然后 在 Stack Exchange 问。<br>用标签（Tag）搜索能让你更缩小你的搜索结果。<br>Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：</p>\n<p>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是- - 写程序无关，只是一些网络连线之类的，请到这里。</p>\n<ul>\n<li>Stack Overflow 是问写程序有关的问题。</li>\n<li>Server Fault 是问服务器和网管相关的问题。</li>\n</ul>\n<h3 id=\"第二步，使用项目邮件列表\"><a href=\"#第二步，使用项目邮件列表\" class=\"headerlink\" title=\"第二步，使用项目邮件列表\"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p>\n<ul>\n<li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li>\n<li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li>\n<li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li>\n<li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li>\n</ul>\n<h3 id=\"使用有意义且描述明确的标题\"><a href=\"#使用有意义且描述明确的标题\" class=\"headerlink\" title=\"使用有意义且描述明确的标题\"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p>\n<p>一个好标题范例是目标 – 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。</p>\n<blockquote>\n<p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！<br>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。<br>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>\n</blockquote>\n<h3 id=\"使问题容易回复\"><a href=\"#使问题容易回复\" class=\"headerlink\" title=\"使问题容易回复\"></a>使问题容易回复</h3><h3 id=\"用清晰、正确、精准并语法正确的语句\"><a href=\"#用清晰、正确、精准并语法正确的语句\" class=\"headerlink\" title=\"用清晰、正确、精准并语法正确的语句\"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p>\n<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：</p>\n<blockquote>\n<p>English is not my native language; please excuse typing errors.</p>\n</blockquote>\n<h3 id=\"使用易于读取且标准的文件格式发送问题\"><a href=\"#使用易于读取且标准的文件格式发送问题\" class=\"headerlink\" title=\"使用易于读取且标准的文件格式发送问题\"></a>使用易于读取且标准的文件格式发送问题</h3><ul>\n<li>使用纯文字而不是 HTML</li>\n<li>绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>\n<li>在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li>\n</ul>\n<h3 id=\"精确的描述问题并言之有物\"><a href=\"#精确的描述问题并言之有物\" class=\"headerlink\" title=\"精确的描述问题并言之有物\"></a>精确的描述问题并言之有物</h3><ul>\n<li>仔细、清楚地描述你的问题或 Bug 的症状。</li>\n<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。</li>\n<li>描述在提问前你是怎样去研究和理解这个问题的。</li>\n<li>描述在提问前为确定问题而采取的诊断步骤。</li>\n<li>描述最近做过什么可能相关的硬件或软件变更。</li>\n<li>尽可能的提供一个可以重现这个问题的可控环境的方法。</li>\n</ul>\n<h3 id=\"别动辄声称找到-Bug\"><a href=\"#别动辄声称找到-Bug\" class=\"headerlink\" title=\"别动辄声称找到 Bug\"></a>别动辄声称找到 Bug</h3><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>\n<h3 id=\"低声下气不能代替你的功课\"><a href=\"#低声下气不能代替你的功课\" class=\"headerlink\" title=\"低声下气不能代替你的功课\"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：我知道我只是个可悲的新手，一个撸瑟，但…。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>\n<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>\n<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>\n<h3 id=\"描述问题症状而非你的猜测\"><a href=\"#描述问题症状而非你的猜测\" class=\"headerlink\" title=\"描述问题症状而非你的猜测\"></a>描述问题症状而非你的猜测</h3><h3 id=\"描述目标而不是过程\"><a href=\"#描述目标而不是过程\" class=\"headerlink\" title=\"描述目标而不是过程\"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>\n<h3 id=\"问题解决后，加个简短的补充说明\"><a href=\"#问题解决后，加个简短的补充说明\" class=\"headerlink\" title=\"问题解决后，加个简短的补充说明\"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>\n<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。</p>\n<h3 id=\"RTFM-和-STFW：如何知道你已完全搞砸了\"><a href=\"#RTFM-和-STFW：如何知道你已完全搞砸了\" class=\"headerlink\" title=\"RTFM 和 STFW：如何知道你已完全搞砸了\"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>如何更好地回答问题</p>\n<p>态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>\n<p>对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>\n<p>如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>\n<p>如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆瓜会把它当成真的指令。</p>\n<p>试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p>\n<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p>\n<p>如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p>\n<p>正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。</p>\n<p>帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。</p>\n<p>如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。<br>","more":"<br>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。</p>\n<p>但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p>\n<h2 id=\"在提问之前\"><a href=\"#在提问之前\" class=\"headerlink\" title=\"在提问之前\"></a>在提问之前</h2><hr>\n<p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p>\n<ol>\n<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>\n<li>尝试上网搜索以找到答案。</li>\n<li>尝试阅读手册以找到答案。</li>\n<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>\n<li>尝试自己检查或试验以找到答案</li>\n<li>向你身边的强者朋友打听以找到答案。</li>\n<li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li>\n</ol>\n<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p>\n<p>绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p>\n<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>\n<h2 id=\"当你提问时\"><a href=\"#当你提问时\" class=\"headerlink\" title=\"当你提问时\"></a>当你提问时</h2><hr>\n<h3 id=\"慎选提问的论坛\"><a href=\"#慎选提问的论坛\" class=\"headerlink\" title=\"慎选提问的论坛\"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>\n<p>在与主题不合的论坛上贴出你的问题<br>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然<br>在太多的不同新闻群组上重复转贴同样的问题（cross-post）<br>向既非熟人也没有义务解决你问题的人发送私人电邮</p>\n<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p>\n<p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>\n<h3 id=\"Stack-OverFlow\"><a href=\"#Stack-OverFlow\" class=\"headerlink\" title=\"Stack OverFlow\"></a>Stack OverFlow</h3><p>搜索，然后 在 Stack Exchange 问。<br>用标签（Tag）搜索能让你更缩小你的搜索结果。<br>Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：</p>\n<p>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是- - 写程序无关，只是一些网络连线之类的，请到这里。</p>\n<ul>\n<li>Stack Overflow 是问写程序有关的问题。</li>\n<li>Server Fault 是问服务器和网管相关的问题。</li>\n</ul>\n<h3 id=\"第二步，使用项目邮件列表\"><a href=\"#第二步，使用项目邮件列表\" class=\"headerlink\" title=\"第二步，使用项目邮件列表\"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p>\n<ul>\n<li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li>\n<li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li>\n<li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li>\n<li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li>\n</ul>\n<h3 id=\"使用有意义且描述明确的标题\"><a href=\"#使用有意义且描述明确的标题\" class=\"headerlink\" title=\"使用有意义且描述明确的标题\"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p>\n<p>一个好标题范例是目标 – 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。</p>\n<blockquote>\n<p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！<br>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。<br>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>\n</blockquote>\n<h3 id=\"使问题容易回复\"><a href=\"#使问题容易回复\" class=\"headerlink\" title=\"使问题容易回复\"></a>使问题容易回复</h3><h3 id=\"用清晰、正确、精准并语法正确的语句\"><a href=\"#用清晰、正确、精准并语法正确的语句\" class=\"headerlink\" title=\"用清晰、正确、精准并语法正确的语句\"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p>\n<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：</p>\n<blockquote>\n<p>English is not my native language; please excuse typing errors.</p>\n</blockquote>\n<h3 id=\"使用易于读取且标准的文件格式发送问题\"><a href=\"#使用易于读取且标准的文件格式发送问题\" class=\"headerlink\" title=\"使用易于读取且标准的文件格式发送问题\"></a>使用易于读取且标准的文件格式发送问题</h3><ul>\n<li>使用纯文字而不是 HTML</li>\n<li>绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>\n<li>在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li>\n</ul>\n<h3 id=\"精确的描述问题并言之有物\"><a href=\"#精确的描述问题并言之有物\" class=\"headerlink\" title=\"精确的描述问题并言之有物\"></a>精确的描述问题并言之有物</h3><ul>\n<li>仔细、清楚地描述你的问题或 Bug 的症状。</li>\n<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。</li>\n<li>描述在提问前你是怎样去研究和理解这个问题的。</li>\n<li>描述在提问前为确定问题而采取的诊断步骤。</li>\n<li>描述最近做过什么可能相关的硬件或软件变更。</li>\n<li>尽可能的提供一个可以重现这个问题的可控环境的方法。</li>\n</ul>\n<h3 id=\"别动辄声称找到-Bug\"><a href=\"#别动辄声称找到-Bug\" class=\"headerlink\" title=\"别动辄声称找到 Bug\"></a>别动辄声称找到 Bug</h3><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>\n<h3 id=\"低声下气不能代替你的功课\"><a href=\"#低声下气不能代替你的功课\" class=\"headerlink\" title=\"低声下气不能代替你的功课\"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：我知道我只是个可悲的新手，一个撸瑟，但…。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>\n<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>\n<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>\n<h3 id=\"描述问题症状而非你的猜测\"><a href=\"#描述问题症状而非你的猜测\" class=\"headerlink\" title=\"描述问题症状而非你的猜测\"></a>描述问题症状而非你的猜测</h3><h3 id=\"描述目标而不是过程\"><a href=\"#描述目标而不是过程\" class=\"headerlink\" title=\"描述目标而不是过程\"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>\n<h3 id=\"问题解决后，加个简短的补充说明\"><a href=\"#问题解决后，加个简短的补充说明\" class=\"headerlink\" title=\"问题解决后，加个简短的补充说明\"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>\n<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。</p>\n<h3 id=\"RTFM-和-STFW：如何知道你已完全搞砸了\"><a href=\"#RTFM-和-STFW：如何知道你已完全搞砸了\" class=\"headerlink\" title=\"RTFM 和 STFW：如何知道你已完全搞砸了\"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>如何更好地回答问题</p>\n<p>态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>\n<p>对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>\n<p>如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>\n<p>如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆瓜会把它当成真的指令。</p>\n<p>试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p>\n<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p>\n<p>如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p>\n<p>正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。</p>\n<p>帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。</p>\n<p>如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。</p>"},{"toc":true,"title":"事务","date":"2018-03-29T07:38:37.000Z","_content":"\n### 1. 什么是事务\n\n**事务基本概念：**一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。\n<!--more-->\n举例，我不想再举例了，就是支付宝或微信转账，A给B转100元，A减少了100元，那么B一定得增加100元，不能出现A少了钱B没加钱，或者B加了钱A没少钱的情况。\n\n### 2. 事务四大特性ACID\n- 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败\n- 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的\n- 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰\n- 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据\n\n### 3. JDBC中的事务\n**以下部分引用自：https://blog.csdn.net/axi295309066/article/details/52981430**\n在jdbc中处理事务，都是通过Connection完成的！同一事务中所有的操作，都在使用同一个Connection对象！\n`Connection`的三个方法与事务相关：\n- `setAutoCommit(boolean)`：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了\n- `commit()`：提交结束事务\n- `rollback()`：回滚结束事务\n\n默认情况下，数据库连接处于自动提交模式。每个SQL语句一旦被执行便被提交给数据库。一旦命令被提交，就无法对它进行回滚操作。在使用事务时，需要关闭这个默认值。\n\njdbc处理事务的代码格式：\n```java\ntry {\n  con.setAutoCommit(false);//开启事务…\n  ….\n  …\n  con.commit();//try的最后提交事务\n} catch() {\n  con.rollback();//回滚事务\n}\n\npublic void transfer(boolean b) {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = JdbcUtils.getConnection();\n            //手动提交\n            con.setAutoCommit(false);\n\n            String sql = \"update account set balance=balance+? where id=?\";\n            pstmt = con.prepareStatement(sql);\n\n            //操作\n            pstmt.setDouble(1, -10000);\n            pstmt.setInt(2, 1);\n            pstmt.executeUpdate();\n\n            // 在两个操作中抛出异常\n            if(b) {\n                throw new Exception();\n            }\n\n            pstmt.setDouble(1, 10000);\n            pstmt.setInt(2, 2);\n            pstmt.executeUpdate();\n\n            //提交事务\n            con.commit();\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            JdbcUtils.close(con, pstmt);\n        }\n    }\n```\n\n#### 3.1 保存点\n保存点是JDBC3.0的东西！当要求数据库服务器支持保存点方式的回滚。 \n校验数据库服务器是否支持保存点！\n```java\nboolean b = con.getMetaData().supportsSavepoints();\n```\n保存点的作用是允许事务回滚到指定的保存点位置。在事务中设置好保存点，然后回滚时可以选择回滚到指定的保存点，而不是回滚整个事务！注意，回滚到指定保存点并没有结束事务！！！只有回滚了整个事务才算是结束事务了！\n\nConnection类的设置保存点，以及回滚到指定保存点方法：\n- 设置保存点：Savepoint setSavepoint()\n- 回滚到指定保存点：void rollback(Savepoint)\n```java\n /*\n     * 李四对张三说，如果你给我转1W，我就给你转100W。\n     * ==========================================\n     * \n     * 张三给李四转1W（张三减去1W，李四加上1W）\n     * 设置保存点！\n     * 李四给张三转100W（李四减去100W，张三加上100W）\n     * 查看李四余额为负数，那么回滚到保存点。\n     * 提交事务\n     */\n    @Test\n    public void fun() {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = JdbcUtils.getConnection();\n            //手动提交\n            con.setAutoCommit(false);\n\n            String sql = \"update account set balance=balance+? where name=?\";\n            pstmt = con.prepareStatement(sql);\n\n            //操作1（张三减去1W）\n            pstmt.setDouble(1, -10000);\n            pstmt.setString(2, \"zs\");\n            pstmt.executeUpdate();\n\n            //操作2（李四加上1W）\n            pstmt.setDouble(1, 10000);\n            pstmt.setString(2, \"ls\");\n            pstmt.executeUpdate();\n\n            // 设置保存点\n            Savepoint sp = con.setSavepoint();\n\n            //操作3（李四减去100W）\n            pstmt.setDouble(1, -1000000);\n            pstmt.setString(2, \"ls\");\n            pstmt.executeUpdate();      \n\n            //操作4（张三加上100W）\n            pstmt.setDouble(1, 1000000);\n            pstmt.setString(2, \"zs\");\n            pstmt.executeUpdate();\n\n            //操作5（查看李四余额）\n            sql = \"select balance from account where name=?\";\n            pstmt = con.prepareStatement(sql);\n            pstmt.setString(1, \"ls\");\n            ResultSet rs = pstmt.executeQuery();\n            rs.next();\n            double balance = rs.getDouble(1);\n　　　　　　//如果李四余额为负数，那么回滚到指定保存点\n            if(balance < 0) {\n                con.rollback(sp);\n                System.out.println(\"张三，你上当了！\");\n            }\n\n            //提交事务\n            con.commit();\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            JdbcUtils.close(con, pstmt);\n        }\n    }\n```\n### 4. 事务隔离级别\n#### 4.1 事务并发问题\n- 脏读（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据\n- 不可重复读（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改\n- 幻读（虚读）（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录\n\n##### 4.1.1 脏读\n事务1：张三给李四转账100元 \n事务2：李四查看自己的账户\n- t1：事务1：开始事务\n- t2：事务1：张三给李四转账100元\n- t3：事务2：开始事务\n- t4：事务2：李四查看自己的账户，看到账户多出100元（脏读）\n- t5：事务2：提交事务\n- t6：事务1：回滚事务，回到转账之前的状态\n\n##### 4.1.2 不可重复读\n事务1：酒店查看两次1048号房间状态 \n事务2：预订1048号房间\n\n- t1：事务1：开始事务\n- t2：事务1：查看1048号房间状态为空闲\n- t3：事务2：开始事务\n- t4：事务2：预定1048号房间\n- t5：事务2：提交事务\n- t6：事务1：再次查看1048号房间状态为使用\n- t7：事务1：提交事务 \n对同一记录的两次查询结果不一致！\n\n##### 4.1.3 幻读\n4.2.3幻读\n事务1：对酒店房间预订记录两次统计 \n事务2：添加一条预订房间记录\n\n- t1：事务1：开始事务\n- t2：事务1：统计预订记录100条\n- t3：事务2：开始事务\n- t4：事务2：添加一条预订房间记录\n- t5：事务2：提交事务\n- t6：事务1：再次统计预订记录为101记录\n- t7：事务1：提交\n对同一表的两次查询不一致！\n\n不可重复读和幻读的区别：\n\n不可重复读是读取到了另一事务的更新；\n幻读是读取到了另一事务的插入（MySQL中无法测试到幻读）；\n\n#### 4.2 事务隔离级别\n4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的\n\n**SERIALIZABLE（串行化）**\n- 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的\n- 性能最差\n\n**REPEATABLE READ（可重复读）（MySQL）**\n- 防止脏读和不可重复读，不能处理幻读问题\n- 性能比SERIALIZABLE好\n\n**READ COMMITTED（读已提交数据）（Oracle）**\n- 防止脏读，没有处理不可重复读，也没有处理幻读；\n- 性能比REPEATABLE READ好\n\n**READ UNCOMMITTED（读未提交数据）**\n- 可能出现任何事务并发问题\n- 性能最好\n\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/70d7f121-6172-4a9c-a2a8-16033017cb0c/1522316358581.png)\n\n#### 4.3 MySQL隔离级别\nMySQL的默认隔离级别为Repeatable read，可以通过下面语句查看：\n`select @@tx_isolation`\n也可以通过下面语句来设置当前连接的隔离级别：\n`SET SESSION transaction ISOLATION LEVEL [4选1] `\n#### 4.4 JDBC设置隔离级别\n\ncon. setTransactionIsolation(int level);参数可选值如下：\n- Connection.TRANSACTION_READ_UNCOMMITTED\n- Connection.TRANSACTION_READ_COMMITTED\n- Connection.TRANSACTION_REPEATABLE_READ\n- Connection.TRANSACTION_SERIALIZABLE\n\n### 实验\n我在idea的mysql终端里进行测试，参考的是[JDBC事务与事务隔离级别详解](http://www.cnblogs.com/dooor/p/5303904.html)这篇文章，对于脏读和不可重复读实验成功了，但是幻读却一直失败，我再事务1提交增加操作之后，事务2并没有读取到增加的一行。很是奇怪。\n\n> 参考文献：\n> [1] [JavaWeb：JDBC之事务](https://blog.csdn.net/axi295309066/article/details/52981430)\n> [2] [JDBC事务与事务隔离级别详解](http://www.cnblogs.com/dooor/p/5303904.html)\n\n\n\n\n","source":"_posts/事务.md","raw":"---\ntoc: true\ntitle: 事务\ndate: 2018-03-29 15:38:37\ntags: [事务]\n---\n\n### 1. 什么是事务\n\n**事务基本概念：**一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。\n<!--more-->\n举例，我不想再举例了，就是支付宝或微信转账，A给B转100元，A减少了100元，那么B一定得增加100元，不能出现A少了钱B没加钱，或者B加了钱A没少钱的情况。\n\n### 2. 事务四大特性ACID\n- 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败\n- 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的\n- 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰\n- 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据\n\n### 3. JDBC中的事务\n**以下部分引用自：https://blog.csdn.net/axi295309066/article/details/52981430**\n在jdbc中处理事务，都是通过Connection完成的！同一事务中所有的操作，都在使用同一个Connection对象！\n`Connection`的三个方法与事务相关：\n- `setAutoCommit(boolean)`：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了\n- `commit()`：提交结束事务\n- `rollback()`：回滚结束事务\n\n默认情况下，数据库连接处于自动提交模式。每个SQL语句一旦被执行便被提交给数据库。一旦命令被提交，就无法对它进行回滚操作。在使用事务时，需要关闭这个默认值。\n\njdbc处理事务的代码格式：\n```java\ntry {\n  con.setAutoCommit(false);//开启事务…\n  ….\n  …\n  con.commit();//try的最后提交事务\n} catch() {\n  con.rollback();//回滚事务\n}\n\npublic void transfer(boolean b) {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = JdbcUtils.getConnection();\n            //手动提交\n            con.setAutoCommit(false);\n\n            String sql = \"update account set balance=balance+? where id=?\";\n            pstmt = con.prepareStatement(sql);\n\n            //操作\n            pstmt.setDouble(1, -10000);\n            pstmt.setInt(2, 1);\n            pstmt.executeUpdate();\n\n            // 在两个操作中抛出异常\n            if(b) {\n                throw new Exception();\n            }\n\n            pstmt.setDouble(1, 10000);\n            pstmt.setInt(2, 2);\n            pstmt.executeUpdate();\n\n            //提交事务\n            con.commit();\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            JdbcUtils.close(con, pstmt);\n        }\n    }\n```\n\n#### 3.1 保存点\n保存点是JDBC3.0的东西！当要求数据库服务器支持保存点方式的回滚。 \n校验数据库服务器是否支持保存点！\n```java\nboolean b = con.getMetaData().supportsSavepoints();\n```\n保存点的作用是允许事务回滚到指定的保存点位置。在事务中设置好保存点，然后回滚时可以选择回滚到指定的保存点，而不是回滚整个事务！注意，回滚到指定保存点并没有结束事务！！！只有回滚了整个事务才算是结束事务了！\n\nConnection类的设置保存点，以及回滚到指定保存点方法：\n- 设置保存点：Savepoint setSavepoint()\n- 回滚到指定保存点：void rollback(Savepoint)\n```java\n /*\n     * 李四对张三说，如果你给我转1W，我就给你转100W。\n     * ==========================================\n     * \n     * 张三给李四转1W（张三减去1W，李四加上1W）\n     * 设置保存点！\n     * 李四给张三转100W（李四减去100W，张三加上100W）\n     * 查看李四余额为负数，那么回滚到保存点。\n     * 提交事务\n     */\n    @Test\n    public void fun() {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n\n        try {\n            con = JdbcUtils.getConnection();\n            //手动提交\n            con.setAutoCommit(false);\n\n            String sql = \"update account set balance=balance+? where name=?\";\n            pstmt = con.prepareStatement(sql);\n\n            //操作1（张三减去1W）\n            pstmt.setDouble(1, -10000);\n            pstmt.setString(2, \"zs\");\n            pstmt.executeUpdate();\n\n            //操作2（李四加上1W）\n            pstmt.setDouble(1, 10000);\n            pstmt.setString(2, \"ls\");\n            pstmt.executeUpdate();\n\n            // 设置保存点\n            Savepoint sp = con.setSavepoint();\n\n            //操作3（李四减去100W）\n            pstmt.setDouble(1, -1000000);\n            pstmt.setString(2, \"ls\");\n            pstmt.executeUpdate();      \n\n            //操作4（张三加上100W）\n            pstmt.setDouble(1, 1000000);\n            pstmt.setString(2, \"zs\");\n            pstmt.executeUpdate();\n\n            //操作5（查看李四余额）\n            sql = \"select balance from account where name=?\";\n            pstmt = con.prepareStatement(sql);\n            pstmt.setString(1, \"ls\");\n            ResultSet rs = pstmt.executeQuery();\n            rs.next();\n            double balance = rs.getDouble(1);\n　　　　　　//如果李四余额为负数，那么回滚到指定保存点\n            if(balance < 0) {\n                con.rollback(sp);\n                System.out.println(\"张三，你上当了！\");\n            }\n\n            //提交事务\n            con.commit();\n        } catch(Exception e) {\n            //回滚事务\n            if(con != null) {\n                try {\n                    con.rollback();\n                } catch(SQLException ex) {}\n            }\n            throw new RuntimeException(e);\n        } finally {\n            //关闭\n            JdbcUtils.close(con, pstmt);\n        }\n    }\n```\n### 4. 事务隔离级别\n#### 4.1 事务并发问题\n- 脏读（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据\n- 不可重复读（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改\n- 幻读（虚读）（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录\n\n##### 4.1.1 脏读\n事务1：张三给李四转账100元 \n事务2：李四查看自己的账户\n- t1：事务1：开始事务\n- t2：事务1：张三给李四转账100元\n- t3：事务2：开始事务\n- t4：事务2：李四查看自己的账户，看到账户多出100元（脏读）\n- t5：事务2：提交事务\n- t6：事务1：回滚事务，回到转账之前的状态\n\n##### 4.1.2 不可重复读\n事务1：酒店查看两次1048号房间状态 \n事务2：预订1048号房间\n\n- t1：事务1：开始事务\n- t2：事务1：查看1048号房间状态为空闲\n- t3：事务2：开始事务\n- t4：事务2：预定1048号房间\n- t5：事务2：提交事务\n- t6：事务1：再次查看1048号房间状态为使用\n- t7：事务1：提交事务 \n对同一记录的两次查询结果不一致！\n\n##### 4.1.3 幻读\n4.2.3幻读\n事务1：对酒店房间预订记录两次统计 \n事务2：添加一条预订房间记录\n\n- t1：事务1：开始事务\n- t2：事务1：统计预订记录100条\n- t3：事务2：开始事务\n- t4：事务2：添加一条预订房间记录\n- t5：事务2：提交事务\n- t6：事务1：再次统计预订记录为101记录\n- t7：事务1：提交\n对同一表的两次查询不一致！\n\n不可重复读和幻读的区别：\n\n不可重复读是读取到了另一事务的更新；\n幻读是读取到了另一事务的插入（MySQL中无法测试到幻读）；\n\n#### 4.2 事务隔离级别\n4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的\n\n**SERIALIZABLE（串行化）**\n- 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的\n- 性能最差\n\n**REPEATABLE READ（可重复读）（MySQL）**\n- 防止脏读和不可重复读，不能处理幻读问题\n- 性能比SERIALIZABLE好\n\n**READ COMMITTED（读已提交数据）（Oracle）**\n- 防止脏读，没有处理不可重复读，也没有处理幻读；\n- 性能比REPEATABLE READ好\n\n**READ UNCOMMITTED（读未提交数据）**\n- 可能出现任何事务并发问题\n- 性能最好\n\n\n![Alt text](https://app.yinxiang.com/shard/s15/res/70d7f121-6172-4a9c-a2a8-16033017cb0c/1522316358581.png)\n\n#### 4.3 MySQL隔离级别\nMySQL的默认隔离级别为Repeatable read，可以通过下面语句查看：\n`select @@tx_isolation`\n也可以通过下面语句来设置当前连接的隔离级别：\n`SET SESSION transaction ISOLATION LEVEL [4选1] `\n#### 4.4 JDBC设置隔离级别\n\ncon. setTransactionIsolation(int level);参数可选值如下：\n- Connection.TRANSACTION_READ_UNCOMMITTED\n- Connection.TRANSACTION_READ_COMMITTED\n- Connection.TRANSACTION_REPEATABLE_READ\n- Connection.TRANSACTION_SERIALIZABLE\n\n### 实验\n我在idea的mysql终端里进行测试，参考的是[JDBC事务与事务隔离级别详解](http://www.cnblogs.com/dooor/p/5303904.html)这篇文章，对于脏读和不可重复读实验成功了，但是幻读却一直失败，我再事务1提交增加操作之后，事务2并没有读取到增加的一行。很是奇怪。\n\n> 参考文献：\n> [1] [JavaWeb：JDBC之事务](https://blog.csdn.net/axi295309066/article/details/52981430)\n> [2] [JDBC事务与事务隔离级别详解](http://www.cnblogs.com/dooor/p/5303904.html)\n\n\n\n\n","slug":"事务","published":1,"updated":"2018-08-13T14:28:27.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5r002u6k15m23xgvlk","content":"<h3 id=\"1-什么是事务\"><a href=\"#1-什么是事务\" class=\"headerlink\" title=\"1. 什么是事务\"></a>1. 什么是事务</h3><p><strong>事务基本概念：</strong>一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。<br><a id=\"more\"></a><br>举例，我不想再举例了，就是支付宝或微信转账，A给B转100元，A减少了100元，那么B一定得增加100元，不能出现A少了钱B没加钱，或者B加了钱A没少钱的情况。</p>\n<h3 id=\"2-事务四大特性ACID\"><a href=\"#2-事务四大特性ACID\" class=\"headerlink\" title=\"2. 事务四大特性ACID\"></a>2. 事务四大特性ACID</h3><ul>\n<li>原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败</li>\n<li>一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的</li>\n<li>隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</li>\n<li>持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据</li>\n</ul>\n<h3 id=\"3-JDBC中的事务\"><a href=\"#3-JDBC中的事务\" class=\"headerlink\" title=\"3. JDBC中的事务\"></a>3. JDBC中的事务</h3><p><strong>以下部分引用自：<a href=\"https://blog.csdn.net/axi295309066/article/details/52981430\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/axi295309066/article/details/52981430</a></strong><br>在jdbc中处理事务，都是通过Connection完成的！同一事务中所有的操作，都在使用同一个Connection对象！<br><code>Connection</code>的三个方法与事务相关：</p>\n<ul>\n<li><code>setAutoCommit(boolean)</code>：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了</li>\n<li><code>commit()</code>：提交结束事务</li>\n<li><code>rollback()</code>：回滚结束事务</li>\n</ul>\n<p>默认情况下，数据库连接处于自动提交模式。每个SQL语句一旦被执行便被提交给数据库。一旦命令被提交，就无法对它进行回滚操作。在使用事务时，需要关闭这个默认值。</p>\n<p>jdbc处理事务的代码格式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  con.setAutoCommit(<span class=\"keyword\">false</span>);<span class=\"comment\">//开启事务…</span></span><br><span class=\"line\">  ….</span><br><span class=\"line\">  …</span><br><span class=\"line\">  con.commit();<span class=\"comment\">//try的最后提交事务</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>() &#123;</span><br><span class=\"line\">  con.rollback();<span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">        Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            con = JdbcUtils.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">//手动提交</span></span><br><span class=\"line\">            con.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            String sql = <span class=\"string\">\"update account set balance=balance+? where id=?\"</span>;</span><br><span class=\"line\">            pstmt = con.prepareStatement(sql);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//操作</span></span><br><span class=\"line\">            pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">10000</span>);</span><br><span class=\"line\">            pstmt.setInt(<span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在两个操作中抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">            pstmt.setInt(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//提交事务</span></span><br><span class=\"line\">            con.commit();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    con.rollback();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭</span></span><br><span class=\"line\">            JdbcUtils.close(con, pstmt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-1-保存点\"><a href=\"#3-1-保存点\" class=\"headerlink\" title=\"3.1 保存点\"></a>3.1 保存点</h4><p>保存点是JDBC3.0的东西！当要求数据库服务器支持保存点方式的回滚。<br>校验数据库服务器是否支持保存点！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> b = con.getMetaData().supportsSavepoints();</span><br></pre></td></tr></table></figure></p>\n<p>保存点的作用是允许事务回滚到指定的保存点位置。在事务中设置好保存点，然后回滚时可以选择回滚到指定的保存点，而不是回滚整个事务！注意，回滚到指定保存点并没有结束事务！！！只有回滚了整个事务才算是结束事务了！</p>\n<p>Connection类的设置保存点，以及回滚到指定保存点方法：</p>\n<ul>\n<li>设置保存点：Savepoint setSavepoint()</li>\n<li>回滚到指定保存点：void rollback(Savepoint)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 李四对张三说，如果你给我转1W，我就给你转100W。</span></span><br><span class=\"line\"><span class=\"comment\">    * ==========================================</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    * 张三给李四转1W（张三减去1W，李四加上1W）</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置保存点！</span></span><br><span class=\"line\"><span class=\"comment\">    * 李四给张三转100W（李四减去100W，张三加上100W）</span></span><br><span class=\"line\"><span class=\"comment\">    * 查看李四余额为负数，那么回滚到保存点。</span></span><br><span class=\"line\"><span class=\"comment\">    * 提交事务</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           con = JdbcUtils.getConnection();</span><br><span class=\"line\">           <span class=\"comment\">//手动提交</span></span><br><span class=\"line\">           con.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           String sql = <span class=\"string\">\"update account set balance=balance+? where name=?\"</span>;</span><br><span class=\"line\">           pstmt = con.prepareStatement(sql);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作1（张三减去1W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">10000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"zs\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作2（李四加上1W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 设置保存点</span></span><br><span class=\"line\">           Savepoint sp = con.setSavepoint();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作3（李四减去100W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">1000000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();      </span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作4（张三加上100W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">1000000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"zs\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作5（查看李四余额）</span></span><br><span class=\"line\">           sql = <span class=\"string\">\"select balance from account where name=?\"</span>;</span><br><span class=\"line\">           pstmt = con.prepareStatement(sql);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">           rs.next();</span><br><span class=\"line\">           <span class=\"keyword\">double</span> balance = rs.getDouble(<span class=\"number\">1</span>);</span><br><span class=\"line\">　　　　　　<span class=\"comment\">//如果李四余额为负数，那么回滚到指定保存点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(balance &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               con.rollback(sp);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"张三，你上当了！\"</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//提交事务</span></span><br><span class=\"line\">           con.commit();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   con.rollback();</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//关闭</span></span><br><span class=\"line\">           JdbcUtils.close(con, pstmt);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-事务隔离级别\"><a href=\"#4-事务隔离级别\" class=\"headerlink\" title=\"4. 事务隔离级别\"></a>4. 事务隔离级别</h3><h4 id=\"4-1-事务并发问题\"><a href=\"#4-1-事务并发问题\" class=\"headerlink\" title=\"4.1 事务并发问题\"></a>4.1 事务并发问题</h4><ul>\n<li>脏读（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据</li>\n<li>不可重复读（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改</li>\n<li>幻读（虚读）（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录</li>\n</ul>\n<h5 id=\"4-1-1-脏读\"><a href=\"#4-1-1-脏读\" class=\"headerlink\" title=\"4.1.1 脏读\"></a>4.1.1 脏读</h5><p>事务1：张三给李四转账100元<br>事务2：李四查看自己的账户</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：张三给李四转账100元</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：李四查看自己的账户，看到账户多出100元（脏读）</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：回滚事务，回到转账之前的状态</li>\n</ul>\n<h5 id=\"4-1-2-不可重复读\"><a href=\"#4-1-2-不可重复读\" class=\"headerlink\" title=\"4.1.2 不可重复读\"></a>4.1.2 不可重复读</h5><p>事务1：酒店查看两次1048号房间状态<br>事务2：预订1048号房间</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：查看1048号房间状态为空闲</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：预定1048号房间</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：再次查看1048号房间状态为使用</li>\n<li>t7：事务1：提交事务<br>对同一记录的两次查询结果不一致！</li>\n</ul>\n<h5 id=\"4-1-3-幻读\"><a href=\"#4-1-3-幻读\" class=\"headerlink\" title=\"4.1.3 幻读\"></a>4.1.3 幻读</h5><p>4.2.3幻读<br>事务1：对酒店房间预订记录两次统计<br>事务2：添加一条预订房间记录</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：统计预订记录100条</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：添加一条预订房间记录</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：再次统计预订记录为101记录</li>\n<li>t7：事务1：提交<br>对同一表的两次查询不一致！</li>\n</ul>\n<p>不可重复读和幻读的区别：</p>\n<p>不可重复读是读取到了另一事务的更新；<br>幻读是读取到了另一事务的插入（MySQL中无法测试到幻读）；</p>\n<h4 id=\"4-2-事务隔离级别\"><a href=\"#4-2-事务隔离级别\" class=\"headerlink\" title=\"4.2 事务隔离级别\"></a>4.2 事务隔离级别</h4><p>4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的</p>\n<p><strong>SERIALIZABLE（串行化）</strong></p>\n<ul>\n<li>不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的</li>\n<li>性能最差</li>\n</ul>\n<p><strong>REPEATABLE READ（可重复读）（MySQL）</strong></p>\n<ul>\n<li>防止脏读和不可重复读，不能处理幻读问题</li>\n<li>性能比SERIALIZABLE好</li>\n</ul>\n<p><strong>READ COMMITTED（读已提交数据）（Oracle）</strong></p>\n<ul>\n<li>防止脏读，没有处理不可重复读，也没有处理幻读；</li>\n<li>性能比REPEATABLE READ好</li>\n</ul>\n<p><strong>READ UNCOMMITTED（读未提交数据）</strong></p>\n<ul>\n<li>可能出现任何事务并发问题</li>\n<li>性能最好</li>\n</ul>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/70d7f121-6172-4a9c-a2a8-16033017cb0c/1522316358581.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-MySQL隔离级别\"><a href=\"#4-3-MySQL隔离级别\" class=\"headerlink\" title=\"4.3 MySQL隔离级别\"></a>4.3 MySQL隔离级别</h4><p>MySQL的默认隔离级别为Repeatable read，可以通过下面语句查看：<br><code>select @@tx_isolation</code><br>也可以通过下面语句来设置当前连接的隔离级别：<br><code>SET SESSION transaction ISOLATION LEVEL [4选1]</code></p>\n<h4 id=\"4-4-JDBC设置隔离级别\"><a href=\"#4-4-JDBC设置隔离级别\" class=\"headerlink\" title=\"4.4 JDBC设置隔离级别\"></a>4.4 JDBC设置隔离级别</h4><p>con. setTransactionIsolation(int level);参数可选值如下：</p>\n<ul>\n<li>Connection.TRANSACTION_READ_UNCOMMITTED</li>\n<li>Connection.TRANSACTION_READ_COMMITTED</li>\n<li>Connection.TRANSACTION_REPEATABLE_READ</li>\n<li>Connection.TRANSACTION_SERIALIZABLE</li>\n</ul>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><p>我在idea的mysql终端里进行测试，参考的是<a href=\"http://www.cnblogs.com/dooor/p/5303904.html\" target=\"_blank\" rel=\"noopener\">JDBC事务与事务隔离级别详解</a>这篇文章，对于脏读和不可重复读实验成功了，但是幻读却一直失败，我再事务1提交增加操作之后，事务2并没有读取到增加的一行。很是奇怪。</p>\n<blockquote>\n<p>参考文献：<br>[1] <a href=\"https://blog.csdn.net/axi295309066/article/details/52981430\" target=\"_blank\" rel=\"noopener\">JavaWeb：JDBC之事务</a><br>[2] <a href=\"http://www.cnblogs.com/dooor/p/5303904.html\" target=\"_blank\" rel=\"noopener\">JDBC事务与事务隔离级别详解</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-什么是事务\"><a href=\"#1-什么是事务\" class=\"headerlink\" title=\"1. 什么是事务\"></a>1. 什么是事务</h3><p><strong>事务基本概念：</strong>一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。<br>","more":"<br>举例，我不想再举例了，就是支付宝或微信转账，A给B转100元，A减少了100元，那么B一定得增加100元，不能出现A少了钱B没加钱，或者B加了钱A没少钱的情况。</p>\n<h3 id=\"2-事务四大特性ACID\"><a href=\"#2-事务四大特性ACID\" class=\"headerlink\" title=\"2. 事务四大特性ACID\"></a>2. 事务四大特性ACID</h3><ul>\n<li>原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败</li>\n<li>一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的</li>\n<li>隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</li>\n<li>持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据</li>\n</ul>\n<h3 id=\"3-JDBC中的事务\"><a href=\"#3-JDBC中的事务\" class=\"headerlink\" title=\"3. JDBC中的事务\"></a>3. JDBC中的事务</h3><p><strong>以下部分引用自：<a href=\"https://blog.csdn.net/axi295309066/article/details/52981430\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/axi295309066/article/details/52981430</a></strong><br>在jdbc中处理事务，都是通过Connection完成的！同一事务中所有的操作，都在使用同一个Connection对象！<br><code>Connection</code>的三个方法与事务相关：</p>\n<ul>\n<li><code>setAutoCommit(boolean)</code>：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了</li>\n<li><code>commit()</code>：提交结束事务</li>\n<li><code>rollback()</code>：回滚结束事务</li>\n</ul>\n<p>默认情况下，数据库连接处于自动提交模式。每个SQL语句一旦被执行便被提交给数据库。一旦命令被提交，就无法对它进行回滚操作。在使用事务时，需要关闭这个默认值。</p>\n<p>jdbc处理事务的代码格式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  con.setAutoCommit(<span class=\"keyword\">false</span>);<span class=\"comment\">//开启事务…</span></span><br><span class=\"line\">  ….</span><br><span class=\"line\">  …</span><br><span class=\"line\">  con.commit();<span class=\"comment\">//try的最后提交事务</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>() &#123;</span><br><span class=\"line\">  con.rollback();<span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">        Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            con = JdbcUtils.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">//手动提交</span></span><br><span class=\"line\">            con.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            String sql = <span class=\"string\">\"update account set balance=balance+? where id=?\"</span>;</span><br><span class=\"line\">            pstmt = con.prepareStatement(sql);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//操作</span></span><br><span class=\"line\">            pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">10000</span>);</span><br><span class=\"line\">            pstmt.setInt(<span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 在两个操作中抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">            pstmt.setInt(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//提交事务</span></span><br><span class=\"line\">            con.commit();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    con.rollback();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭</span></span><br><span class=\"line\">            JdbcUtils.close(con, pstmt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-1-保存点\"><a href=\"#3-1-保存点\" class=\"headerlink\" title=\"3.1 保存点\"></a>3.1 保存点</h4><p>保存点是JDBC3.0的东西！当要求数据库服务器支持保存点方式的回滚。<br>校验数据库服务器是否支持保存点！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> b = con.getMetaData().supportsSavepoints();</span><br></pre></td></tr></table></figure></p>\n<p>保存点的作用是允许事务回滚到指定的保存点位置。在事务中设置好保存点，然后回滚时可以选择回滚到指定的保存点，而不是回滚整个事务！注意，回滚到指定保存点并没有结束事务！！！只有回滚了整个事务才算是结束事务了！</p>\n<p>Connection类的设置保存点，以及回滚到指定保存点方法：</p>\n<ul>\n<li>设置保存点：Savepoint setSavepoint()</li>\n<li>回滚到指定保存点：void rollback(Savepoint)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 李四对张三说，如果你给我转1W，我就给你转100W。</span></span><br><span class=\"line\"><span class=\"comment\">    * ==========================================</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    * 张三给李四转1W（张三减去1W，李四加上1W）</span></span><br><span class=\"line\"><span class=\"comment\">    * 设置保存点！</span></span><br><span class=\"line\"><span class=\"comment\">    * 李四给张三转100W（李四减去100W，张三加上100W）</span></span><br><span class=\"line\"><span class=\"comment\">    * 查看李四余额为负数，那么回滚到保存点。</span></span><br><span class=\"line\"><span class=\"comment\">    * 提交事务</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       Connection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       PreparedStatement pstmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           con = JdbcUtils.getConnection();</span><br><span class=\"line\">           <span class=\"comment\">//手动提交</span></span><br><span class=\"line\">           con.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           String sql = <span class=\"string\">\"update account set balance=balance+? where name=?\"</span>;</span><br><span class=\"line\">           pstmt = con.prepareStatement(sql);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作1（张三减去1W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">10000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"zs\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作2（李四加上1W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 设置保存点</span></span><br><span class=\"line\">           Savepoint sp = con.setSavepoint();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作3（李四减去100W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, -<span class=\"number\">1000000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();      </span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作4（张三加上100W）</span></span><br><span class=\"line\">           pstmt.setDouble(<span class=\"number\">1</span>, <span class=\"number\">1000000</span>);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">2</span>, <span class=\"string\">\"zs\"</span>);</span><br><span class=\"line\">           pstmt.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//操作5（查看李四余额）</span></span><br><span class=\"line\">           sql = <span class=\"string\">\"select balance from account where name=?\"</span>;</span><br><span class=\"line\">           pstmt = con.prepareStatement(sql);</span><br><span class=\"line\">           pstmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"ls\"</span>);</span><br><span class=\"line\">           ResultSet rs = pstmt.executeQuery();</span><br><span class=\"line\">           rs.next();</span><br><span class=\"line\">           <span class=\"keyword\">double</span> balance = rs.getDouble(<span class=\"number\">1</span>);</span><br><span class=\"line\">　　　　　　<span class=\"comment\">//如果李四余额为负数，那么回滚到指定保存点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(balance &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               con.rollback(sp);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"张三，你上当了！\"</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//提交事务</span></span><br><span class=\"line\">           con.commit();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//回滚事务</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(con != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   con.rollback();</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span>(SQLException ex) &#123;&#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//关闭</span></span><br><span class=\"line\">           JdbcUtils.close(con, pstmt);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-事务隔离级别\"><a href=\"#4-事务隔离级别\" class=\"headerlink\" title=\"4. 事务隔离级别\"></a>4. 事务隔离级别</h3><h4 id=\"4-1-事务并发问题\"><a href=\"#4-1-事务并发问题\" class=\"headerlink\" title=\"4.1 事务并发问题\"></a>4.1 事务并发问题</h4><ul>\n<li>脏读（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据</li>\n<li>不可重复读（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改</li>\n<li>幻读（虚读）（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录</li>\n</ul>\n<h5 id=\"4-1-1-脏读\"><a href=\"#4-1-1-脏读\" class=\"headerlink\" title=\"4.1.1 脏读\"></a>4.1.1 脏读</h5><p>事务1：张三给李四转账100元<br>事务2：李四查看自己的账户</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：张三给李四转账100元</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：李四查看自己的账户，看到账户多出100元（脏读）</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：回滚事务，回到转账之前的状态</li>\n</ul>\n<h5 id=\"4-1-2-不可重复读\"><a href=\"#4-1-2-不可重复读\" class=\"headerlink\" title=\"4.1.2 不可重复读\"></a>4.1.2 不可重复读</h5><p>事务1：酒店查看两次1048号房间状态<br>事务2：预订1048号房间</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：查看1048号房间状态为空闲</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：预定1048号房间</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：再次查看1048号房间状态为使用</li>\n<li>t7：事务1：提交事务<br>对同一记录的两次查询结果不一致！</li>\n</ul>\n<h5 id=\"4-1-3-幻读\"><a href=\"#4-1-3-幻读\" class=\"headerlink\" title=\"4.1.3 幻读\"></a>4.1.3 幻读</h5><p>4.2.3幻读<br>事务1：对酒店房间预订记录两次统计<br>事务2：添加一条预订房间记录</p>\n<ul>\n<li>t1：事务1：开始事务</li>\n<li>t2：事务1：统计预订记录100条</li>\n<li>t3：事务2：开始事务</li>\n<li>t4：事务2：添加一条预订房间记录</li>\n<li>t5：事务2：提交事务</li>\n<li>t6：事务1：再次统计预订记录为101记录</li>\n<li>t7：事务1：提交<br>对同一表的两次查询不一致！</li>\n</ul>\n<p>不可重复读和幻读的区别：</p>\n<p>不可重复读是读取到了另一事务的更新；<br>幻读是读取到了另一事务的插入（MySQL中无法测试到幻读）；</p>\n<h4 id=\"4-2-事务隔离级别\"><a href=\"#4-2-事务隔离级别\" class=\"headerlink\" title=\"4.2 事务隔离级别\"></a>4.2 事务隔离级别</h4><p>4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的</p>\n<p><strong>SERIALIZABLE（串行化）</strong></p>\n<ul>\n<li>不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的</li>\n<li>性能最差</li>\n</ul>\n<p><strong>REPEATABLE READ（可重复读）（MySQL）</strong></p>\n<ul>\n<li>防止脏读和不可重复读，不能处理幻读问题</li>\n<li>性能比SERIALIZABLE好</li>\n</ul>\n<p><strong>READ COMMITTED（读已提交数据）（Oracle）</strong></p>\n<ul>\n<li>防止脏读，没有处理不可重复读，也没有处理幻读；</li>\n<li>性能比REPEATABLE READ好</li>\n</ul>\n<p><strong>READ UNCOMMITTED（读未提交数据）</strong></p>\n<ul>\n<li>可能出现任何事务并发问题</li>\n<li>性能最好</li>\n</ul>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/70d7f121-6172-4a9c-a2a8-16033017cb0c/1522316358581.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-MySQL隔离级别\"><a href=\"#4-3-MySQL隔离级别\" class=\"headerlink\" title=\"4.3 MySQL隔离级别\"></a>4.3 MySQL隔离级别</h4><p>MySQL的默认隔离级别为Repeatable read，可以通过下面语句查看：<br><code>select @@tx_isolation</code><br>也可以通过下面语句来设置当前连接的隔离级别：<br><code>SET SESSION transaction ISOLATION LEVEL [4选1]</code></p>\n<h4 id=\"4-4-JDBC设置隔离级别\"><a href=\"#4-4-JDBC设置隔离级别\" class=\"headerlink\" title=\"4.4 JDBC设置隔离级别\"></a>4.4 JDBC设置隔离级别</h4><p>con. setTransactionIsolation(int level);参数可选值如下：</p>\n<ul>\n<li>Connection.TRANSACTION_READ_UNCOMMITTED</li>\n<li>Connection.TRANSACTION_READ_COMMITTED</li>\n<li>Connection.TRANSACTION_REPEATABLE_READ</li>\n<li>Connection.TRANSACTION_SERIALIZABLE</li>\n</ul>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><p>我在idea的mysql终端里进行测试，参考的是<a href=\"http://www.cnblogs.com/dooor/p/5303904.html\" target=\"_blank\" rel=\"noopener\">JDBC事务与事务隔离级别详解</a>这篇文章，对于脏读和不可重复读实验成功了，但是幻读却一直失败，我再事务1提交增加操作之后，事务2并没有读取到增加的一行。很是奇怪。</p>\n<blockquote>\n<p>参考文献：<br>[1] <a href=\"https://blog.csdn.net/axi295309066/article/details/52981430\" target=\"_blank\" rel=\"noopener\">JavaWeb：JDBC之事务</a><br>[2] <a href=\"http://www.cnblogs.com/dooor/p/5303904.html\" target=\"_blank\" rel=\"noopener\">JDBC事务与事务隔离级别详解</a></p>\n</blockquote>"},{"toc":true,"title":"动态规划","date":"2017-07-18T06:11:55.000Z","_content":"\n**1. 什么是动态规划？**\n**定义：**满足对阶段决策过程的最优化问题，一般都可以用动态规划来解决。\n<!--more-->\n**1.1 特性：**\n- 动态规划的本质是对问题**状态的定义**和**状态转移方程的定义**\n- 动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解可以由上一次子问题的解推出。使用动态规划时间复杂度仅为多项式时间，因此比回溯法、暴力枚举等方法快许多\n- “缓存”、“重叠子问题”、“记忆化”\n- 递归\n- 无后效性，即满足**最优性原理**\n\n**1.2 思想：** 通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。**如何拆分问题**才是动态规划的核心，而拆分问题，靠的就是**状态的定义**和**状态转移方程的定义**\n- **1.2.1 什么是状态的定义？**\n\t- 请看这![Alt text](./1503321739076.png)\n\t- 状态这个东西我现在无法明确描述并给予定义，希望在真正理解应用动态规划后再回来解释。\n- **1.2.2 什么是状态转移方程？**\n\t- 上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。\n\t- ![Alt text](./1503322212142.png)\n\t- 状态转移方程就是带有条件的递推式\n\n**注：**一个问题可能会有多个定义，存在一个不满足最优性原理的定义，**不代表该问题**不适用动态规划。\n\n**2. 实例**\n数学类的、计算机类的东西，你明白了定义，但是不上手体会，记忆不会牢固，也不能真正理解应用。\n- **动态规划基本步骤：**\n\t- （1）找出最优解的性质，并刻画其结构特征\n\t- （2）递归的定义最优解\n\t- （3）以自底向上的方式计算出最优值\n\t- （4）根据计算最优值时得到的信息，构造最优解\n\n**2.1 入门**\n【问题】如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？\n【解答】\n1. 定义问题（状态）：要凑够**i**元最少需要几个硬币。\n2. 状态转移方程：当前要凑够**i**元，比这更小一点的问题有，我选择了其中一个硬币V<sub>j</sub>（V<sub>j</sub>表示一种硬币的值）$$d(i) = min{d(i - V<sub>j</sub>)}+1$$其中$i - V<sub>j</sub> >= 0$,V<sub>j</sub>表示第j个硬币的面值；\n有了状态和状态转移方程，这个问题就基本解决了。\n> Talk is cheap, show me the Code!\n```Java\n/**\n * @Author:liujifang\n * @Description: 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？\n * @Date: Created in 22:28 2017/8/21\n */\npublic class MinCoins {\n\t/**\n     * @param money 需要凑够的钱\n     * @param coins 硬币种类\n     * @return 最少的硬币数量\n     */\n    public static int solution(int money, int[] coins){\n        int n = coins.length;\n        int[] dp = new int[money+1];\n        dp[0] = 0;\n        for (int i = 1; i <= money; i++) {\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 1; i <= money; i++) {\n            for (int j = 0; j < n; j++) {\n                if(coins[j] <= i && dp[i-coins[j]]+1 < dp[i])\n                    dp[i] = dp[i-1]+1;\n            }\n        }\n        return dp[money];\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1,3,5};\n        int money = 11;\n        System.out.println(solution(money, coins));\n    }\n}\n```\n**2.2 初级**\n*上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题，如何找到状态之间的转移方式（即状态转移方程）。*\n\n【问题】**LIS：**一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。\n【解答】\n1. 状态：考虑从A[1],..A[i]的最长非降子序列的长度，其中i<N，定义d(i)为前 i 个数中以 A[i] 结尾的最长非降子序列的长度。\n2. 状态转移方程：如果我们已经求出了d(1)到d(i)，那么$$d(i) = max{1, d(j)+1},其中j<i,A[j]<A[i]$$\n\n【代码】\n```java\n/**\n * @Author:liujifang\n * @Description: 一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。\n * @Date: Created in 23:17 2017/8/21\n */\npublic class LIS {\n    /**\n     * @param arr 待求最长上升子序列的数组\n     * @return 最长上升子序列\n     * @desc 时间复杂度为n^2\n     */\n    public static int solution(int[] arr) {\n        int m = 0;\n        int n = arr.length;\n        int[] dp = new int[n];\n        int ans = 0;\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            m = 0;\n            for (int j = 0; j < i; j++) {\n                if (arr[j] <= arr[i] && dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                }\n            }\n            if (dp[i] > ans) ans = dp[i];\n        }\n        return ans;\n    }\n\n    /**\n     * @desc 时间复杂度为nlog(n)\n     */\n    public static int solution2(int[] arr) {\n        int n = arr.length;\n        int[] dup = new int[n];\n        dup[0] = 1;\n        int size = 0;\n        int j;\n        for (int i = 1; i < n; i++) {\n            if (arr[i] < dup[0]) {\n                j = 1;\n            } else if (arr[i] > dup[size]) {\n                j = ++size;\n            } else {\n                j = bs(dup, size, arr[i]);\n            }\n            dup[j] = arr[i];\n        }\n        return size;\n    }\n\n    private static int bs(int[] dup, int size, int key) {\n        int low = 0;\n        int high = size;\n        int mid;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if (key > dup[mid] && key <= dup[mid + 1])\n                return mid + 1;\n            else if (key < dup[mid])\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 2, 4, 12, 8};\n        System.out.println(solution2(arr));\n    }\n}\n```\n**2.3 中级**\n【问题】平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。\n【解答】\n1. 定义问题（状态）：走到 i * j 个格子的时候最多能收集到多少个苹果。\n2. 状态转移方程：假设格子（或者称为棋盘）是一个二维数组cell[N][M]，二维数组的值就是格子上的苹果数。从cell[0][0]到cell[i][j]能得到的最大苹果数为dp[i][j]。则：$$dp[i][j] = max \\{ dp[i-1][j],dp[i][j-1]\\} + cell[i][j]$$\n\n【代码】\n```java\npackage javastudy.algorithm.dp;\n/**\n * @Author:liujifang\n * @Description: 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。\n * @Date: Created in 22:25 2017/8/22\n */\npublic class ChessMetric {\n    public static void main(String[] args) {\n        int[][] arr = {{1,2,3},{2,3,1},{6,3,5}};\n        int max = maxApples(arr);\n        System.out.println(max);\n    }\n\n    public static int maxApples(int[][] arr){\n        int result = 0;\n        int n = arr.length;\n        int m = arr[0].length;\n        int[][] dp = new int[n][m];\n        //初始化dp[][]\n        dp[0][0] = arr[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = dp[i-1][0] + arr[i][0];\n        }\n        for (int i = 1; i < m; i++) {\n            dp[0][i] = dp[0][i-1] + arr[0][i];\n        }\n        //dp过程\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + arr[i][j];\n            }\n        }\n        result = dp[n-1][m-1];\n        return result;\n    }\n\n    private static int max(int i, int j) {\n        return i>j?i:j;\n    }\n}\n```\n \n**2.4 中高级**\n【问题】无向图G有N个结点，它的边上带有正的权重值。你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i，那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱，就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。\n【解答】...未完待续\n \n","source":"_posts/动态规划.md","raw":"---\ntoc: true\ntitle: 动态规划\ndate: 2017-07-18 14:11:55\ntags: [算法,动态规划]\n---\n\n**1. 什么是动态规划？**\n**定义：**满足对阶段决策过程的最优化问题，一般都可以用动态规划来解决。\n<!--more-->\n**1.1 特性：**\n- 动态规划的本质是对问题**状态的定义**和**状态转移方程的定义**\n- 动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解可以由上一次子问题的解推出。使用动态规划时间复杂度仅为多项式时间，因此比回溯法、暴力枚举等方法快许多\n- “缓存”、“重叠子问题”、“记忆化”\n- 递归\n- 无后效性，即满足**最优性原理**\n\n**1.2 思想：** 通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。**如何拆分问题**才是动态规划的核心，而拆分问题，靠的就是**状态的定义**和**状态转移方程的定义**\n- **1.2.1 什么是状态的定义？**\n\t- 请看这![Alt text](./1503321739076.png)\n\t- 状态这个东西我现在无法明确描述并给予定义，希望在真正理解应用动态规划后再回来解释。\n- **1.2.2 什么是状态转移方程？**\n\t- 上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。\n\t- ![Alt text](./1503322212142.png)\n\t- 状态转移方程就是带有条件的递推式\n\n**注：**一个问题可能会有多个定义，存在一个不满足最优性原理的定义，**不代表该问题**不适用动态规划。\n\n**2. 实例**\n数学类的、计算机类的东西，你明白了定义，但是不上手体会，记忆不会牢固，也不能真正理解应用。\n- **动态规划基本步骤：**\n\t- （1）找出最优解的性质，并刻画其结构特征\n\t- （2）递归的定义最优解\n\t- （3）以自底向上的方式计算出最优值\n\t- （4）根据计算最优值时得到的信息，构造最优解\n\n**2.1 入门**\n【问题】如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？\n【解答】\n1. 定义问题（状态）：要凑够**i**元最少需要几个硬币。\n2. 状态转移方程：当前要凑够**i**元，比这更小一点的问题有，我选择了其中一个硬币V<sub>j</sub>（V<sub>j</sub>表示一种硬币的值）$$d(i) = min{d(i - V<sub>j</sub>)}+1$$其中$i - V<sub>j</sub> >= 0$,V<sub>j</sub>表示第j个硬币的面值；\n有了状态和状态转移方程，这个问题就基本解决了。\n> Talk is cheap, show me the Code!\n```Java\n/**\n * @Author:liujifang\n * @Description: 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？\n * @Date: Created in 22:28 2017/8/21\n */\npublic class MinCoins {\n\t/**\n     * @param money 需要凑够的钱\n     * @param coins 硬币种类\n     * @return 最少的硬币数量\n     */\n    public static int solution(int money, int[] coins){\n        int n = coins.length;\n        int[] dp = new int[money+1];\n        dp[0] = 0;\n        for (int i = 1; i <= money; i++) {\n            dp[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 1; i <= money; i++) {\n            for (int j = 0; j < n; j++) {\n                if(coins[j] <= i && dp[i-coins[j]]+1 < dp[i])\n                    dp[i] = dp[i-1]+1;\n            }\n        }\n        return dp[money];\n    }\n\n    public static void main(String[] args) {\n        int[] coins = {1,3,5};\n        int money = 11;\n        System.out.println(solution(money, coins));\n    }\n}\n```\n**2.2 初级**\n*上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题，如何找到状态之间的转移方式（即状态转移方程）。*\n\n【问题】**LIS：**一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。\n【解答】\n1. 状态：考虑从A[1],..A[i]的最长非降子序列的长度，其中i<N，定义d(i)为前 i 个数中以 A[i] 结尾的最长非降子序列的长度。\n2. 状态转移方程：如果我们已经求出了d(1)到d(i)，那么$$d(i) = max{1, d(j)+1},其中j<i,A[j]<A[i]$$\n\n【代码】\n```java\n/**\n * @Author:liujifang\n * @Description: 一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。\n * @Date: Created in 23:17 2017/8/21\n */\npublic class LIS {\n    /**\n     * @param arr 待求最长上升子序列的数组\n     * @return 最长上升子序列\n     * @desc 时间复杂度为n^2\n     */\n    public static int solution(int[] arr) {\n        int m = 0;\n        int n = arr.length;\n        int[] dp = new int[n];\n        int ans = 0;\n        dp[0] = 1;\n        for (int i = 1; i < n; i++) {\n            m = 0;\n            for (int j = 0; j < i; j++) {\n                if (arr[j] <= arr[i] && dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                }\n            }\n            if (dp[i] > ans) ans = dp[i];\n        }\n        return ans;\n    }\n\n    /**\n     * @desc 时间复杂度为nlog(n)\n     */\n    public static int solution2(int[] arr) {\n        int n = arr.length;\n        int[] dup = new int[n];\n        dup[0] = 1;\n        int size = 0;\n        int j;\n        for (int i = 1; i < n; i++) {\n            if (arr[i] < dup[0]) {\n                j = 1;\n            } else if (arr[i] > dup[size]) {\n                j = ++size;\n            } else {\n                j = bs(dup, size, arr[i]);\n            }\n            dup[j] = arr[i];\n        }\n        return size;\n    }\n\n    private static int bs(int[] dup, int size, int key) {\n        int low = 0;\n        int high = size;\n        int mid;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if (key > dup[mid] && key <= dup[mid + 1])\n                return mid + 1;\n            else if (key < dup[mid])\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 2, 4, 12, 8};\n        System.out.println(solution2(arr));\n    }\n}\n```\n**2.3 中级**\n【问题】平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。\n【解答】\n1. 定义问题（状态）：走到 i * j 个格子的时候最多能收集到多少个苹果。\n2. 状态转移方程：假设格子（或者称为棋盘）是一个二维数组cell[N][M]，二维数组的值就是格子上的苹果数。从cell[0][0]到cell[i][j]能得到的最大苹果数为dp[i][j]。则：$$dp[i][j] = max \\{ dp[i-1][j],dp[i][j-1]\\} + cell[i][j]$$\n\n【代码】\n```java\npackage javastudy.algorithm.dp;\n/**\n * @Author:liujifang\n * @Description: 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。\n * @Date: Created in 22:25 2017/8/22\n */\npublic class ChessMetric {\n    public static void main(String[] args) {\n        int[][] arr = {{1,2,3},{2,3,1},{6,3,5}};\n        int max = maxApples(arr);\n        System.out.println(max);\n    }\n\n    public static int maxApples(int[][] arr){\n        int result = 0;\n        int n = arr.length;\n        int m = arr[0].length;\n        int[][] dp = new int[n][m];\n        //初始化dp[][]\n        dp[0][0] = arr[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = dp[i-1][0] + arr[i][0];\n        }\n        for (int i = 1; i < m; i++) {\n            dp[0][i] = dp[0][i-1] + arr[0][i];\n        }\n        //dp过程\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + arr[i][j];\n            }\n        }\n        result = dp[n-1][m-1];\n        return result;\n    }\n\n    private static int max(int i, int j) {\n        return i>j?i:j;\n    }\n}\n```\n \n**2.4 中高级**\n【问题】无向图G有N个结点，它的边上带有正的权重值。你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i，那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱，就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。\n【解答】...未完待续\n \n","slug":"动态规划","published":1,"updated":"2018-08-13T14:28:27.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5s002w6k15tznmo4o7","content":"<p><strong>1. 什么是动态规划？</strong><br><strong>定义：</strong>满足对阶段决策过程的最优化问题，一般都可以用动态规划来解决。<br><a id=\"more\"></a><br><strong>1.1 特性：</strong></p>\n<ul>\n<li>动态规划的本质是对问题<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong></li>\n<li>动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解可以由上一次子问题的解推出。使用动态规划时间复杂度仅为多项式时间，因此比回溯法、暴力枚举等方法快许多</li>\n<li>“缓存”、“重叠子问题”、“记忆化”</li>\n<li>递归</li>\n<li>无后效性，即满足<strong>最优性原理</strong></li>\n</ul>\n<p><strong>1.2 思想：</strong> 通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<strong>如何拆分问题</strong>才是动态规划的核心，而拆分问题，靠的就是<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong></p>\n<ul>\n<li><strong>1.2.1 什么是状态的定义？</strong><ul>\n<li>请看这<img src=\"./1503321739076.png\" alt=\"Alt text\"></li>\n<li>状态这个东西我现在无法明确描述并给予定义，希望在真正理解应用动态规划后再回来解释。</li>\n</ul>\n</li>\n<li><strong>1.2.2 什么是状态转移方程？</strong><ul>\n<li>上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。</li>\n<li><img src=\"./1503322212142.png\" alt=\"Alt text\"></li>\n<li>状态转移方程就是带有条件的递推式</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：</strong>一个问题可能会有多个定义，存在一个不满足最优性原理的定义，<strong>不代表该问题</strong>不适用动态规划。</p>\n<p><strong>2. 实例</strong><br>数学类的、计算机类的东西，你明白了定义，但是不上手体会，记忆不会牢固，也不能真正理解应用。</p>\n<ul>\n<li><strong>动态规划基本步骤：</strong><ul>\n<li>（1）找出最优解的性质，并刻画其结构特征</li>\n<li>（2）递归的定义最优解</li>\n<li>（3）以自底向上的方式计算出最优值</li>\n<li>（4）根据计算最优值时得到的信息，构造最优解</li>\n</ul>\n</li>\n</ul>\n<p><strong>2.1 入门</strong><br>【问题】如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？<br>【解答】</p>\n<ol>\n<li>定义问题（状态）：要凑够<strong>i</strong>元最少需要几个硬币。</li>\n<li>状态转移方程：当前要凑够<strong>i</strong>元，比这更小一点的问题有，我选择了其中一个硬币V<sub>j</sub>（V<sub>j</sub>表示一种硬币的值）$$d(i) = min{d(i - V<sub>j</sub>)}+1$$其中$i - V<sub>j</sub> &gt;= 0$,V<sub>j</sub>表示第j个硬币的面值；<br>有了状态和状态转移方程，这个问题就基本解决了。<blockquote>\n<p>Talk is cheap, show me the Code!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 22:28 2017/8/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinCoins</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> money 需要凑够的钱</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> coins 硬币种类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最少的硬币数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution</span><span class=\"params\">(<span class=\"keyword\">int</span> money, <span class=\"keyword\">int</span>[] coins)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = coins.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[money+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= money; i++) &#123;</span><br><span class=\"line\">            dp[i] = Integer.MAX_VALUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= money; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]]+<span class=\"number\">1</span> &lt; dp[i])</span><br><span class=\"line\">                    dp[i] = dp[i-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[money];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] coins = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> money = <span class=\"number\">11</span>;</span><br><span class=\"line\">        System.out.println(solution(money, coins));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<p><strong>2.2 初级</strong><br><em>上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题，如何找到状态之间的转移方式（即状态转移方程）。</em></p>\n<p>【问题】<strong>LIS：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。<br>【解答】</p>\n<ol>\n<li>状态：考虑从A[1],..A[i]的最长非降子序列的长度，其中i&lt;N，定义d(i)为前 i 个数中以 A[i] 结尾的最长非降子序列的长度。</li>\n<li>状态转移方程：如果我们已经求出了d(1)到d(i)，那么$$d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;A[i]$$</li>\n</ol>\n<p>【代码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 23:17 2017/8/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LIS</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr 待求最长上升子序列的数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最长上升子序列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 时间复杂度为n^2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &lt;= arr[i] &amp;&amp; dp[j] + <span class=\"number\">1</span> &gt; dp[i]) &#123;</span><br><span class=\"line\">                    dp[i] = dp[j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[i] &gt; ans) ans = dp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 时间复杂度为nlog(n)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution2</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dup = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        dup[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &lt; dup[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[i] &gt; dup[size]) &#123;</span><br><span class=\"line\">                j = ++size;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = bs(dup, size, arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dup[j] = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] dup, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = size;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">            mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &gt; dup[mid] &amp;&amp; key &lt;= dup[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; dup[mid])</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">        System.out.println(solution2(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.3 中级</strong><br>【问题】平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。<br>【解答】</p>\n<ol>\n<li>定义问题（状态）：走到 i * j 个格子的时候最多能收集到多少个苹果。</li>\n<li>状态转移方程：假设格子（或者称为棋盘）是一个二维数组cell[N][M]，二维数组的值就是格子上的苹果数。从cell[0][0]到cell[i][j]能得到的最大苹果数为dp[i][j]。则：$$dp[i][j] = max { dp[i-1][j],dp[i][j-1]} + cell[i][j]$$</li>\n</ol>\n<p>【代码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> javastudy.algorithm.dp;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 22:25 2017/8/22</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessMetric</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] arr = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = maxApples(arr);</span><br><span class=\"line\">        System.out.println(max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">maxApples</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = arr[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        <span class=\"comment\">//初始化dp[][]</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>] + arr[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = dp[<span class=\"number\">0</span>][i-<span class=\"number\">1</span>] + arr[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//dp过程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i-<span class=\"number\">1</span>][j], dp[i][j-<span class=\"number\">1</span>]) + arr[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result = dp[n-<span class=\"number\">1</span>][m-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i&gt;j?i:j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.4 中高级</strong><br>【问题】无向图G有N个结点，它的边上带有正的权重值。你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i，那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱，就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。<br>【解答】…未完待续</p>\n","site":{"data":{}},"excerpt":"<p><strong>1. 什么是动态规划？</strong><br><strong>定义：</strong>满足对阶段决策过程的最优化问题，一般都可以用动态规划来解决。<br>","more":"<br><strong>1.1 特性：</strong></p>\n<ul>\n<li>动态规划的本质是对问题<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong></li>\n<li>动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解可以由上一次子问题的解推出。使用动态规划时间复杂度仅为多项式时间，因此比回溯法、暴力枚举等方法快许多</li>\n<li>“缓存”、“重叠子问题”、“记忆化”</li>\n<li>递归</li>\n<li>无后效性，即满足<strong>最优性原理</strong></li>\n</ul>\n<p><strong>1.2 思想：</strong> 通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<strong>如何拆分问题</strong>才是动态规划的核心，而拆分问题，靠的就是<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong></p>\n<ul>\n<li><strong>1.2.1 什么是状态的定义？</strong><ul>\n<li>请看这<img src=\"./1503321739076.png\" alt=\"Alt text\"></li>\n<li>状态这个东西我现在无法明确描述并给予定义，希望在真正理解应用动态规划后再回来解释。</li>\n</ul>\n</li>\n<li><strong>1.2.2 什么是状态转移方程？</strong><ul>\n<li>上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。</li>\n<li><img src=\"./1503322212142.png\" alt=\"Alt text\"></li>\n<li>状态转移方程就是带有条件的递推式</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：</strong>一个问题可能会有多个定义，存在一个不满足最优性原理的定义，<strong>不代表该问题</strong>不适用动态规划。</p>\n<p><strong>2. 实例</strong><br>数学类的、计算机类的东西，你明白了定义，但是不上手体会，记忆不会牢固，也不能真正理解应用。</p>\n<ul>\n<li><strong>动态规划基本步骤：</strong><ul>\n<li>（1）找出最优解的性质，并刻画其结构特征</li>\n<li>（2）递归的定义最优解</li>\n<li>（3）以自底向上的方式计算出最优值</li>\n<li>（4）根据计算最优值时得到的信息，构造最优解</li>\n</ul>\n</li>\n</ul>\n<p><strong>2.1 入门</strong><br>【问题】如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？<br>【解答】</p>\n<ol>\n<li>定义问题（状态）：要凑够<strong>i</strong>元最少需要几个硬币。</li>\n<li>状态转移方程：当前要凑够<strong>i</strong>元，比这更小一点的问题有，我选择了其中一个硬币V<sub>j</sub>（V<sub>j</sub>表示一种硬币的值）$$d(i) = min{d(i - V<sub>j</sub>)}+1$$其中$i - V<sub>j</sub> &gt;= 0$,V<sub>j</sub>表示第j个硬币的面值；<br>有了状态和状态转移方程，这个问题就基本解决了。<blockquote>\n<p>Talk is cheap, show me the Code!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 22:28 2017/8/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinCoins</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> money 需要凑够的钱</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> coins 硬币种类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最少的硬币数量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution</span><span class=\"params\">(<span class=\"keyword\">int</span> money, <span class=\"keyword\">int</span>[] coins)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = coins.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[money+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= money; i++) &#123;</span><br><span class=\"line\">            dp[i] = Integer.MAX_VALUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= money; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]]+<span class=\"number\">1</span> &lt; dp[i])</span><br><span class=\"line\">                    dp[i] = dp[i-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[money];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] coins = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> money = <span class=\"number\">11</span>;</span><br><span class=\"line\">        System.out.println(solution(money, coins));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<p><strong>2.2 初级</strong><br><em>上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题，如何找到状态之间的转移方式（即状态转移方程）。</em></p>\n<p>【问题】<strong>LIS：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。<br>【解答】</p>\n<ol>\n<li>状态：考虑从A[1],..A[i]的最长非降子序列的长度，其中i&lt;N，定义d(i)为前 i 个数中以 A[i] 结尾的最长非降子序列的长度。</li>\n<li>状态转移方程：如果我们已经求出了d(1)到d(i)，那么$$d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;A[i]$$</li>\n</ol>\n<p>【代码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 一个序列有N个数：A[1],A[2],...,A[N]，求出最长非降子序列的长度。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 23:17 2017/8/21</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LIS</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr 待求最长上升子序列的数组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最长上升子序列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 时间复杂度为n^2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            m = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &lt;= arr[i] &amp;&amp; dp[j] + <span class=\"number\">1</span> &gt; dp[i]) &#123;</span><br><span class=\"line\">                    dp[i] = dp[j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[i] &gt; ans) ans = dp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 时间复杂度为nlog(n)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solution2</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dup = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        dup[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &lt; dup[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                j = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[i] &gt; dup[size]) &#123;</span><br><span class=\"line\">                j = ++size;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = bs(dup, size, arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dup[j] = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">bs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] dup, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = size;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">            mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key &gt; dup[mid] &amp;&amp; key &lt;= dup[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; dup[mid])</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">        System.out.println(solution2(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.3 中级</strong><br>【问题】平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。<br>【解答】</p>\n<ol>\n<li>定义问题（状态）：走到 i * j 个格子的时候最多能收集到多少个苹果。</li>\n<li>状态转移方程：假设格子（或者称为棋盘）是一个二维数组cell[N][M]，二维数组的值就是格子上的苹果数。从cell[0][0]到cell[i][j]能得到的最大苹果数为dp[i][j]。则：$$dp[i][j] = max { dp[i-1][j],dp[i][j-1]} + cell[i][j]$$</li>\n</ol>\n<p>【代码】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> javastudy.algorithm.dp;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span>:liujifang</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 平面上有N＊M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Date</span>: Created in 22:25 2017/8/22</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessMetric</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] arr = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = maxApples(arr);</span><br><span class=\"line\">        System.out.println(max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">maxApples</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] arr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = arr[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        <span class=\"comment\">//初始化dp[][]</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>] + arr[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = dp[<span class=\"number\">0</span>][i-<span class=\"number\">1</span>] + arr[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//dp过程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i-<span class=\"number\">1</span>][j], dp[i][j-<span class=\"number\">1</span>]) + arr[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result = dp[n-<span class=\"number\">1</span>][m-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i&gt;j?i:j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.4 中高级</strong><br>【问题】无向图G有N个结点，它的边上带有正的权重值。你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i，那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱，就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。<br>【解答】…未完待续</p>"},{"toc":true,"title":"字符集、字符编码","date":"2018-03-21T06:18:00.000Z","_content":"\n### 1. 概念\n- **字符**：是各种文字和符号的总称，包括各国家的文字、标点符号、图形符号、数字等\n- **字符集**：多个字符的集合，常见的有ASCII,GBxx,Unicode等\n- **字符编码**：是把字符集中的字符编码为特定的二进制数，以便计算机存储。字符集中的每个字符编码都不同。\n<!--more-->\n### 2. 字符集\n**2.1 ASCII**\n> 维基百科：（发音： /ˈæski/ ass-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。\n\n> ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。\n![Alt text](https://app.yinxiang.com/shard/s15/res/18cbf79c-52f9-461c-849d-15c2fa4e4564)\n\n**Unicode**\n> 维基百科：Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。\n\n> Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2017年6月20日公布的10.0.0[2]，已经收录超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。\n\n> Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。\n\n> Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。\n\n### 3. 字符编码\nUnicode字符集虽然定义了每一个字符的二进制代码，但是没有定义这些二进制怎么存储（用多少个字节存储）。而其他大多数字符集本身也是字符编码，比如ASCII使用一个字节存储一个字符，GB2312用两个字节表示一个字符。\n**【问题】**unicode能够表示世界上任何一个字符，所以一个字符的二进制位数也相应增加，但是如ASCII一个字节表示的现代英语字符，如果用三个字节或更多的字节去表示就会造成浪费。所以它造成的结果是，有许多不同的二进制格式用来表示Unicode.\n\n#### 3.1 **UTF-8**\nUTF-8是使用最广的一种unicode实现方式。它是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。\n**UTF-8的编码方式**\n这里我觉得[阮一峰的博客](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)讲的比维基百科更易理解，所以放上它的链接。\n![Alt text](https://app.yinxiang.com/shard/s15/res/689caf25-a9fb-482f-9dc1-17be7d1632a3)\n![Alt text](https://app.yinxiang.com/shard/s15/res/858e3291-8781-49e2-899e-4625529dcc71)\n上图的`根据`写错了。2333.\n\n#### UTF-16\nUTF-16的编码方式较UTF-8更为复杂。\n通过查阅[wiki](https://zh.wikipedia.org/wiki/UTF-16)，大致明白了UTF-16的编码方式。\n> Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。\n1. 第一个平面称为基本多语言平面\n2. 其他平面称为辅助平面\n\n> 基本多语言平面内，从U+D800到U+DFFF之间的码位区块永久保留不映射到任何unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。\n\n- 从U+0000至U+D7FF以及从U+E000至U+FFFF的码位\n正常表示对应的字符\n- 从U+10000到U+10FFFF的码位\n辅助平面中的码位被编码为一对（两个）16比特长的码元，称作**代理对**（在guava Strings类源码中，我曾被这个代理对弄得很晕）。\n具体计算方法：\n> - 码位减去0x10000,得到的值的范围为20比特长的0..0xFFFFF.\n- 高位的10比特的值（值的范围为0..0x3FF）被加上0xD800得到第一个码元或称作高位代理（high surrogate），值的范围是0xD800..0xDBFF.由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理（lead surrogates）。\n- 低位的10比特的值（值的范围也是0..0x3FF）被加上0xDC00得到第二个码元或称作低位代理（low surrogate），现在值的范围是0xDC00..0xDFFF.由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理（trail surrogates）。\n> 上述算法可理解为：辅助平面中的码位从U+10000到U+10FFFF，共计FFFFF个，即220=1,048,576个，需要20位来表示。如果用两个16位长的整数组成的序列来表示，第一个整数（称为前导代理）要容纳上述20位的前10位，第二个整数（称为后尾代理）容纳上述20位的后10位。还要能根据16位整数的值直接判明属于前导整数代理的值的范围（210=1024)，还是后尾整数代理的值的范围（也是210=1024）。因此，需要在基本多语言平面中保留不对应于Unicode字符的2048个码位，就足以容纳前导代理与后尾代理所需要的编码空间。这对于基本多语言平面总计65536个码位来说，仅占3.125%.\n\n`2048个码位`刚好就是`U+D800`到`U+DFFF`直接的码位，也就是说用两个16位的处于`U+D800`到`U+DFFF`之间的数来表示从U+10000到U+10FFFF的码位。\n\n> 由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）:可以通过仅检查一个码元就可以判定给定字符的下一个字符的起始码元. UTF-8也有类似优点，但许多早期的编码模式就不是这样，必须从头开始分析文本才能确定不同字符的码元的边界。\n\n从上面的解释可以明白，只需要判断当前16位比特值在哪个区间就可以判断是用一个16位能够表示还是需要两个16位来表示一个字符。即UTF-16是可变长的。\n\n### 4. Little endian 和 Big endian\n同样引用`阮一峰博客原文`：\n\n上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。\n\n这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。\n\n第一个字节在前，就是\"大头方式\"（Big endian），第二个字节在前就是\"小头方式\"（Little endian）。\n\n那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？\n\nUnicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。\n\n如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。\n\n> 参考文献\n> [1] [字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n> [2] [Unicode](https://zh.wikipedia.org/zh-cn/Unicode)\n> [3] [UTF-16](https://zh.wikipedia.org/zh-cn/UTF-16)\n\n","source":"_posts/字符集-字符编码.md","raw":"---\ntoc: true\ntitle: 字符集、字符编码\ndate: 2018-03-21 14:18:00\ntags: [字符编码,字符集,UTF-8,UTF-16,Unicode]\n---\n\n### 1. 概念\n- **字符**：是各种文字和符号的总称，包括各国家的文字、标点符号、图形符号、数字等\n- **字符集**：多个字符的集合，常见的有ASCII,GBxx,Unicode等\n- **字符编码**：是把字符集中的字符编码为特定的二进制数，以便计算机存储。字符集中的每个字符编码都不同。\n<!--more-->\n### 2. 字符集\n**2.1 ASCII**\n> 维基百科：（发音： /ˈæski/ ass-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。\n\n> ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。\n![Alt text](https://app.yinxiang.com/shard/s15/res/18cbf79c-52f9-461c-849d-15c2fa4e4564)\n\n**Unicode**\n> 维基百科：Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。\n\n> Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2017年6月20日公布的10.0.0[2]，已经收录超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。\n\n> Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。\n\n> Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。\n\n### 3. 字符编码\nUnicode字符集虽然定义了每一个字符的二进制代码，但是没有定义这些二进制怎么存储（用多少个字节存储）。而其他大多数字符集本身也是字符编码，比如ASCII使用一个字节存储一个字符，GB2312用两个字节表示一个字符。\n**【问题】**unicode能够表示世界上任何一个字符，所以一个字符的二进制位数也相应增加，但是如ASCII一个字节表示的现代英语字符，如果用三个字节或更多的字节去表示就会造成浪费。所以它造成的结果是，有许多不同的二进制格式用来表示Unicode.\n\n#### 3.1 **UTF-8**\nUTF-8是使用最广的一种unicode实现方式。它是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。\n**UTF-8的编码方式**\n这里我觉得[阮一峰的博客](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)讲的比维基百科更易理解，所以放上它的链接。\n![Alt text](https://app.yinxiang.com/shard/s15/res/689caf25-a9fb-482f-9dc1-17be7d1632a3)\n![Alt text](https://app.yinxiang.com/shard/s15/res/858e3291-8781-49e2-899e-4625529dcc71)\n上图的`根据`写错了。2333.\n\n#### UTF-16\nUTF-16的编码方式较UTF-8更为复杂。\n通过查阅[wiki](https://zh.wikipedia.org/wiki/UTF-16)，大致明白了UTF-16的编码方式。\n> Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。\n1. 第一个平面称为基本多语言平面\n2. 其他平面称为辅助平面\n\n> 基本多语言平面内，从U+D800到U+DFFF之间的码位区块永久保留不映射到任何unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。\n\n- 从U+0000至U+D7FF以及从U+E000至U+FFFF的码位\n正常表示对应的字符\n- 从U+10000到U+10FFFF的码位\n辅助平面中的码位被编码为一对（两个）16比特长的码元，称作**代理对**（在guava Strings类源码中，我曾被这个代理对弄得很晕）。\n具体计算方法：\n> - 码位减去0x10000,得到的值的范围为20比特长的0..0xFFFFF.\n- 高位的10比特的值（值的范围为0..0x3FF）被加上0xD800得到第一个码元或称作高位代理（high surrogate），值的范围是0xD800..0xDBFF.由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理（lead surrogates）。\n- 低位的10比特的值（值的范围也是0..0x3FF）被加上0xDC00得到第二个码元或称作低位代理（low surrogate），现在值的范围是0xDC00..0xDFFF.由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理（trail surrogates）。\n> 上述算法可理解为：辅助平面中的码位从U+10000到U+10FFFF，共计FFFFF个，即220=1,048,576个，需要20位来表示。如果用两个16位长的整数组成的序列来表示，第一个整数（称为前导代理）要容纳上述20位的前10位，第二个整数（称为后尾代理）容纳上述20位的后10位。还要能根据16位整数的值直接判明属于前导整数代理的值的范围（210=1024)，还是后尾整数代理的值的范围（也是210=1024）。因此，需要在基本多语言平面中保留不对应于Unicode字符的2048个码位，就足以容纳前导代理与后尾代理所需要的编码空间。这对于基本多语言平面总计65536个码位来说，仅占3.125%.\n\n`2048个码位`刚好就是`U+D800`到`U+DFFF`直接的码位，也就是说用两个16位的处于`U+D800`到`U+DFFF`之间的数来表示从U+10000到U+10FFFF的码位。\n\n> 由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）:可以通过仅检查一个码元就可以判定给定字符的下一个字符的起始码元. UTF-8也有类似优点，但许多早期的编码模式就不是这样，必须从头开始分析文本才能确定不同字符的码元的边界。\n\n从上面的解释可以明白，只需要判断当前16位比特值在哪个区间就可以判断是用一个16位能够表示还是需要两个16位来表示一个字符。即UTF-16是可变长的。\n\n### 4. Little endian 和 Big endian\n同样引用`阮一峰博客原文`：\n\n上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。\n\n这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。\n\n第一个字节在前，就是\"大头方式\"（Big endian），第二个字节在前就是\"小头方式\"（Little endian）。\n\n那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？\n\nUnicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。\n\n如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。\n\n> 参考文献\n> [1] [字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n> [2] [Unicode](https://zh.wikipedia.org/zh-cn/Unicode)\n> [3] [UTF-16](https://zh.wikipedia.org/zh-cn/UTF-16)\n\n","slug":"字符集-字符编码","published":1,"updated":"2018-08-13T14:28:27.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5u002z6k15ru9i8gea","content":"<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><ul>\n<li><strong>字符</strong>：是各种文字和符号的总称，包括各国家的文字、标点符号、图形符号、数字等</li>\n<li><strong>字符集</strong>：多个字符的集合，常见的有ASCII,GBxx,Unicode等</li>\n<li><strong>字符编码</strong>：是把字符集中的字符编码为特定的二进制数，以便计算机存储。字符集中的每个字符编码都不同。<a id=\"more\"></a>\n<h3 id=\"2-字符集\"><a href=\"#2-字符集\" class=\"headerlink\" title=\"2. 字符集\"></a>2. 字符集</h3><strong>2.1 ASCII</strong><blockquote>\n<p>维基百科：（发音： /ˈæski/ ass-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。<br><img src=\"https://app.yinxiang.com/shard/s15/res/18cbf79c-52f9-461c-849d-15c2fa4e4564\" alt=\"Alt text\"></p>\n</blockquote>\n<p><strong>Unicode</strong></p>\n<blockquote>\n<p>维基百科：Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p>\n</blockquote>\n<blockquote>\n<p>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2017年6月20日公布的10.0.0[2]，已经收录超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p>\n</blockquote>\n<blockquote>\n<p>Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。</p>\n</blockquote>\n<blockquote>\n<p>Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。</p>\n</blockquote>\n<h3 id=\"3-字符编码\"><a href=\"#3-字符编码\" class=\"headerlink\" title=\"3. 字符编码\"></a>3. 字符编码</h3><p>Unicode字符集虽然定义了每一个字符的二进制代码，但是没有定义这些二进制怎么存储（用多少个字节存储）。而其他大多数字符集本身也是字符编码，比如ASCII使用一个字节存储一个字符，GB2312用两个字节表示一个字符。<br><strong>【问题】</strong>unicode能够表示世界上任何一个字符，所以一个字符的二进制位数也相应增加，但是如ASCII一个字节表示的现代英语字符，如果用三个字节或更多的字节去表示就会造成浪费。所以它造成的结果是，有许多不同的二进制格式用来表示Unicode.</p>\n<h4 id=\"3-1-UTF-8\"><a href=\"#3-1-UTF-8\" class=\"headerlink\" title=\"3.1 UTF-8\"></a>3.1 <strong>UTF-8</strong></h4><p>UTF-8是使用最广的一种unicode实现方式。它是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。<br><strong>UTF-8的编码方式</strong><br>这里我觉得<a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">阮一峰的博客</a>讲的比维基百科更易理解，所以放上它的链接。<br><img src=\"https://app.yinxiang.com/shard/s15/res/689caf25-a9fb-482f-9dc1-17be7d1632a3\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/858e3291-8781-49e2-899e-4625529dcc71\" alt=\"Alt text\"><br>上图的<code>根据</code>写错了。2333.</p>\n<h4 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h4><p>UTF-16的编码方式较UTF-8更为复杂。<br>通过查阅<a href=\"https://zh.wikipedia.org/wiki/UTF-16\" target=\"_blank\" rel=\"noopener\">wiki</a>，大致明白了UTF-16的编码方式。</p>\n<blockquote>\n<p>Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。</p>\n<ol>\n<li>第一个平面称为基本多语言平面</li>\n<li>其他平面称为辅助平面</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>基本多语言平面内，从U+D800到U+DFFF之间的码位区块永久保留不映射到任何unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。</p>\n</blockquote>\n<ul>\n<li>从U+0000至U+D7FF以及从U+E000至U+FFFF的码位<br>正常表示对应的字符</li>\n<li>从U+10000到U+10FFFF的码位<br>辅助平面中的码位被编码为一对（两个）16比特长的码元，称作<strong>代理对</strong>（在guava Strings类源码中，我曾被这个代理对弄得很晕）。<br>具体计算方法：<blockquote>\n<ul>\n<li>码位减去0x10000,得到的值的范围为20比特长的0..0xFFFFF.</li>\n</ul>\n</blockquote>\n</li>\n<li>高位的10比特的值（值的范围为0..0x3FF）被加上0xD800得到第一个码元或称作高位代理（high surrogate），值的范围是0xD800..0xDBFF.由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理（lead surrogates）。</li>\n<li>低位的10比特的值（值的范围也是0..0x3FF）被加上0xDC00得到第二个码元或称作低位代理（low surrogate），现在值的范围是0xDC00..0xDFFF.由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理（trail surrogates）。<blockquote>\n<p>上述算法可理解为：辅助平面中的码位从U+10000到U+10FFFF，共计FFFFF个，即220=1,048,576个，需要20位来表示。如果用两个16位长的整数组成的序列来表示，第一个整数（称为前导代理）要容纳上述20位的前10位，第二个整数（称为后尾代理）容纳上述20位的后10位。还要能根据16位整数的值直接判明属于前导整数代理的值的范围（210=1024)，还是后尾整数代理的值的范围（也是210=1024）。因此，需要在基本多语言平面中保留不对应于Unicode字符的2048个码位，就足以容纳前导代理与后尾代理所需要的编码空间。这对于基本多语言平面总计65536个码位来说，仅占3.125%.</p>\n</blockquote>\n</li>\n</ul>\n<p><code>2048个码位</code>刚好就是<code>U+D800</code>到<code>U+DFFF</code>直接的码位，也就是说用两个16位的处于<code>U+D800</code>到<code>U+DFFF</code>之间的数来表示从U+10000到U+10FFFF的码位。</p>\n<blockquote>\n<p>由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）:可以通过仅检查一个码元就可以判定给定字符的下一个字符的起始码元. UTF-8也有类似优点，但许多早期的编码模式就不是这样，必须从头开始分析文本才能确定不同字符的码元的边界。</p>\n</blockquote>\n<p>从上面的解释可以明白，只需要判断当前16位比特值在哪个区间就可以判断是用一个16位能够表示还是需要两个16位来表示一个字符。即UTF-16是可变长的。</p>\n<h3 id=\"4-Little-endian-和-Big-endian\"><a href=\"#4-Little-endian-和-Big-endian\" class=\"headerlink\" title=\"4. Little endian 和 Big endian\"></a>4. Little endian 和 Big endian</h3><p>同样引用<code>阮一峰博客原文</code>：</p>\n<p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。</p>\n<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>\n<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>\n<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>\n<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p>\n<p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br>[2] <a href=\"https://zh.wikipedia.org/zh-cn/Unicode\" target=\"_blank\" rel=\"noopener\">Unicode</a><br>[3] <a href=\"https://zh.wikipedia.org/zh-cn/UTF-16\" target=\"_blank\" rel=\"noopener\">UTF-16</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><ul>\n<li><strong>字符</strong>：是各种文字和符号的总称，包括各国家的文字、标点符号、图形符号、数字等</li>\n<li><strong>字符集</strong>：多个字符的集合，常见的有ASCII,GBxx,Unicode等</li>\n<li><strong>字符编码</strong>：是把字符集中的字符编码为特定的二进制数，以便计算机存储。字符集中的每个字符编码都不同。","more":"<h3 id=\"2-字符集\"><a href=\"#2-字符集\" class=\"headerlink\" title=\"2. 字符集\"></a>2. 字符集</h3><strong>2.1 ASCII</strong><blockquote>\n<p>维基百科：（发音： /ˈæski/ ass-kee[1]，American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。<br><img src=\"https://app.yinxiang.com/shard/s15/res/18cbf79c-52f9-461c-849d-15c2fa4e4564\" alt=\"Alt text\"></p>\n</blockquote>\n<p><strong>Unicode</strong></p>\n<blockquote>\n<p>维基百科：Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</p>\n</blockquote>\n<blockquote>\n<p>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式[1]对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2017年6月20日公布的10.0.0[2]，已经收录超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p>\n</blockquote>\n<blockquote>\n<p>Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。</p>\n</blockquote>\n<blockquote>\n<p>Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言（Extensible Markup Language，简称：XML）、Java编程语言以及现代的操作系统，都采用Unicode编码。</p>\n</blockquote>\n<h3 id=\"3-字符编码\"><a href=\"#3-字符编码\" class=\"headerlink\" title=\"3. 字符编码\"></a>3. 字符编码</h3><p>Unicode字符集虽然定义了每一个字符的二进制代码，但是没有定义这些二进制怎么存储（用多少个字节存储）。而其他大多数字符集本身也是字符编码，比如ASCII使用一个字节存储一个字符，GB2312用两个字节表示一个字符。<br><strong>【问题】</strong>unicode能够表示世界上任何一个字符，所以一个字符的二进制位数也相应增加，但是如ASCII一个字节表示的现代英语字符，如果用三个字节或更多的字节去表示就会造成浪费。所以它造成的结果是，有许多不同的二进制格式用来表示Unicode.</p>\n<h4 id=\"3-1-UTF-8\"><a href=\"#3-1-UTF-8\" class=\"headerlink\" title=\"3.1 UTF-8\"></a>3.1 <strong>UTF-8</strong></h4><p>UTF-8是使用最广的一种unicode实现方式。它是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号变化字节长度。<br><strong>UTF-8的编码方式</strong><br>这里我觉得<a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">阮一峰的博客</a>讲的比维基百科更易理解，所以放上它的链接。<br><img src=\"https://app.yinxiang.com/shard/s15/res/689caf25-a9fb-482f-9dc1-17be7d1632a3\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/858e3291-8781-49e2-899e-4625529dcc71\" alt=\"Alt text\"><br>上图的<code>根据</code>写错了。2333.</p>\n<h4 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h4><p>UTF-16的编码方式较UTF-8更为复杂。<br>通过查阅<a href=\"https://zh.wikipedia.org/wiki/UTF-16\" target=\"_blank\" rel=\"noopener\">wiki</a>，大致明白了UTF-16的编码方式。</p>\n<blockquote>\n<p>Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位（code point）可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含216（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面。</p>\n<ol>\n<li>第一个平面称为基本多语言平面</li>\n<li>其他平面称为辅助平面</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>基本多语言平面内，从U+D800到U+DFFF之间的码位区块永久保留不映射到任何unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。</p>\n</blockquote>\n<ul>\n<li>从U+0000至U+D7FF以及从U+E000至U+FFFF的码位<br>正常表示对应的字符</li>\n<li>从U+10000到U+10FFFF的码位<br>辅助平面中的码位被编码为一对（两个）16比特长的码元，称作<strong>代理对</strong>（在guava Strings类源码中，我曾被这个代理对弄得很晕）。<br>具体计算方法：<blockquote>\n<ul>\n<li>码位减去0x10000,得到的值的范围为20比特长的0..0xFFFFF.</li>\n</ul>\n</blockquote>\n</li>\n<li>高位的10比特的值（值的范围为0..0x3FF）被加上0xD800得到第一个码元或称作高位代理（high surrogate），值的范围是0xD800..0xDBFF.由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理（lead surrogates）。</li>\n<li>低位的10比特的值（值的范围也是0..0x3FF）被加上0xDC00得到第二个码元或称作低位代理（low surrogate），现在值的范围是0xDC00..0xDFFF.由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理（trail surrogates）。<blockquote>\n<p>上述算法可理解为：辅助平面中的码位从U+10000到U+10FFFF，共计FFFFF个，即220=1,048,576个，需要20位来表示。如果用两个16位长的整数组成的序列来表示，第一个整数（称为前导代理）要容纳上述20位的前10位，第二个整数（称为后尾代理）容纳上述20位的后10位。还要能根据16位整数的值直接判明属于前导整数代理的值的范围（210=1024)，还是后尾整数代理的值的范围（也是210=1024）。因此，需要在基本多语言平面中保留不对应于Unicode字符的2048个码位，就足以容纳前导代理与后尾代理所需要的编码空间。这对于基本多语言平面总计65536个码位来说，仅占3.125%.</p>\n</blockquote>\n</li>\n</ul>\n<p><code>2048个码位</code>刚好就是<code>U+D800</code>到<code>U+DFFF</code>直接的码位，也就是说用两个16位的处于<code>U+D800</code>到<code>U+DFFF</code>之间的数来表示从U+10000到U+10FFFF的码位。</p>\n<blockquote>\n<p>由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）:可以通过仅检查一个码元就可以判定给定字符的下一个字符的起始码元. UTF-8也有类似优点，但许多早期的编码模式就不是这样，必须从头开始分析文本才能确定不同字符的码元的边界。</p>\n</blockquote>\n<p>从上面的解释可以明白，只需要判断当前16位比特值在哪个区间就可以判断是用一个16位能够表示还是需要两个16位来表示一个字符。即UTF-16是可变长的。</p>\n<h3 id=\"4-Little-endian-和-Big-endian\"><a href=\"#4-Little-endian-和-Big-endian\" class=\"headerlink\" title=\"4. Little endian 和 Big endian\"></a>4. Little endian 和 Big endian</h3><p>同样引用<code>阮一峰博客原文</code>：</p>\n<p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。</p>\n<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>\n<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>\n<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>\n<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p>\n<p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"noopener\">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br>[2] <a href=\"https://zh.wikipedia.org/zh-cn/Unicode\" target=\"_blank\" rel=\"noopener\">Unicode</a><br>[3] <a href=\"https://zh.wikipedia.org/zh-cn/UTF-16\" target=\"_blank\" rel=\"noopener\">UTF-16</a></p>\n</blockquote>"},{"toc":true,"title":"[译]Linux包管理基础：apt,yum,dnf,pkg","date":"2018-05-05T07:51:14.000Z","_content":"\n> 原文地址: [Package Management Basics: apt, yum, dnf, pkg](https://www.digitalocean.com/community/tutorials/package-management-basics-apt-yum-dnf-pkg)\n> 原文作者: Brennen Bearnes\n> 译文出自: [Cap_ljf's Blog](http://cap-ljf.top/)\n> 本文永久链接: \n> 译者: cap_ljf\n\n### 引言\n大多数类Unix操作系统提供了一个用于查找和安装软件的集中式机制。软件通常以软件包的形式分发，保存在软件仓库中。使用软件包被称为软件包管理。软件包为操作系统提供基本的组件，以及共享库、应用程序、服务和文档。\n<!--more-->\n软件包系统不仅仅是一次性安装软件。它还提供用于升级已安装软件的工具。软件包仓库有助于确保代码已经过审核以供你的系统使用，并且已安装的软件版本已获得开发人员和程序包维护人员的批准。\n\n在配置线上或开发环境时，往往需要去官方仓库检查软件版本。已发行稳定版中的软件包可能已过时，特别是在涉及新的或快速变化的软件情况下。尽管如此，软件包管理对于系统管理员和开发者来说是一项至关重要的技能，而为主流发行版提供的丰富软件包是一项巨大的资源。\n\n本指南旨在作为一个查找、安装和升级各个发行版软件包的基础知识的快速参考，并应帮助你在不同系统之间切换这些知识。\n\n### 软件包管理系统：摘要\n大多数软件包系统都是围绕软件包文件集建立的。一个软件包文件通常是一个文档，其中包含已编译二进制文件和其他组装软件的资源以及安装脚本。软件包还包含有价值的元数据，包括依赖项（安装和运行该软件依赖的其他包列表）。\n\n尽管它们的功能和优点大致相同，但各种平台的封装格式和工具各不相同：\n\n| Operating System      |    Format | Tool(s)  |\n| :-------- | --------:| :--: |\n| Debian  | .deb |  apt, apt-cache, apt-get, dpkg   |\n| Ubuntu  | .deb |  apt, apt-cache, apt-get, dpkg   |\n| CentOS  | .rpm |  yum   |\n| Fedora  | .rpm |  dnf   |\n| FreeBSD  | Ports,.deb |  make,pkg   |\n\n在Debian和基于它的系统中，如Ubuntu、Linux Mint和Raspbian，包格式是`.deb`文件。高级打包工具APT（Advanced Packaging Tool）提供用于大多数常见操作的命令：搜索软件仓库、安装软件包集合以及它们的依赖项，以及管理升级。APT命令作为底层命令dpkg工具的前端操作，dpkg处理本地系统上各个`.deb`文件的安装，有时会直接调用dpkg。\n\n近期大多数Debian派生的发行版系统包括`APT`命令，该命令为常用操作提供了一个简洁统一的接口，这些接口传统上由更具体的`apt-get`和`apt-cache`。它的使用是可选的，但可以简化一些任务。\n\nCentOS、Fedora和其他Red Hat家族的成员使用RPM文件。在CentOS中，`yum`用于与单个软件包文件和仓库交互。\n\n在最近的Fedora版本，`yum`已被`dnf`取代，`dnf`是`yum`一个现代化的分支，它保留了`yum`的大部分接口。\n\nFreeBSD的二进制包系统使用pkg命令进行管理。FreeBSD还提供Ports Collection，一个本地目录结构和工具，允许用户使用Makefiles直接从源代码获取、编译和安装软件包。使用pkg通常要方便得多，但偶尔预编译的软件包不可用，或者你可能需要更改编译时选项。\n\n### 更新软件包列表\n大多数系统会保留一份远程仓库可用软件列表在本地数据库。你最好在安装和更新软件前更新这个数据库。作为这种模式的一个部分例外，`yum`和`dnf`会在执行某些操作之前检查更新，但你可以随时询问是否有更新可用。\n\n| System      |    Command |\n| :-------- | :--------|\n| Debian/Ubuntu  | sudo apt-get update |\n||sudo apt update|\n| CentOS  | yum check-update |\n|  Fedora | dnf check-update |\n| FreeBSD Packages  | sudo pkg update |\n| FreeBSD Ports  | sudo portsnap fetch update |\n\n### 更新已安装软件\n\n对于一个没有软件包系统的机器，确保所有已安装软件保持是最新版本将是一个巨大的负担。你将不得不追踪数百个不同软件包的上游更改和安全警报。虽然软件包管理器不能解决升级软件时遇到的每个问题，但它确实使你能够使用少量的命令来维护大多数系统组件。\n\n在FreeBSD，升级已安装的ports可能导致重大的改变或需要手工配置步骤。在使用portmaster升级之前，最好先阅读/usr/ports/UPDATING。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu  | sudo apt-get upgrade |  只升级已安装的并且可以升级的软件包  |\n|| sudo apt-get dist-upgrade | 可以添加或删除软件包以满足新的依赖关系 |\n|| sudo apt upgrade | 同 sudo apt-get upgrade |\n|| sudo apt full-upgrade | 同 apt-get dist-upgrade. |\n| CentOS  | sudo yum update |  |\n| Fedora | sudo dnf upgrade ||\n| FreeBSD Packages\t | sudo pkg upgrade ||\n| FreeBSD Ports | less /usr/ports/UPDATING | 使用`less`命令查看ports的更新注释 |\n|| cd /usr/ports/ports-mgmt/portmaster && sudo make install && sudo portmaster -a | 安装portmaster并用它去更新已安装的ports |\n\n### 查找一个软件包\n大多数发行版都提供软件集的图形或菜单驱动前端。这些可以按类别浏览并发现新软件是一种好方法。但是，通常情况下，查找软件包的最快和最有效的方法是使用命令行工具进行搜索。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n|  Debian / Ubuntu | apt-cache search search_string |  |\n|   | apt search search_string |  |\n| CentOS  | yum search search_string |  |\n|   | yum search all search_string | 搜索所有字段，包括软件名、描述等 |\n| Fedora  | dnf search search_string |  |\n|   | dnf search all search_string | 搜索所有字段，包括软件名、描述等 |\n| FreeBSD Packages  | pkg search search_string | 根据软件名搜索 |\n|   | pkg search -f search_string | 根据软件名搜索，返回完整的的描述 |\n|   | pkg search -D search_string | 搜索描述 |\n| FreeBSD Ports  | cd /usr/ports && make search name=package | 根据软件名搜索 |\n|   | cd /usr/ports && make search key=search_string\t | 搜索评论、描述和依赖项 |\n\n### 查看一个具体软件包的信息\n当要决定安装哪一个软件包时，读一读软件包的详细描述会很有用。除了可读的文本之外，这些文件通常还包含元数据，如版本号和包的依赖项列表等。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | apt-cache show package | 显示本地缓存该软件包的信息 |\n|  | apt show package |  |\n|  | dpkg -s package | 显示一个软件包现在的已安装状态 |\n| CentOS | yum info package |  |\n|  | yum deplist package | 软件包的依赖项列表 |\n| Fedora | dnf info package |  |\n|  | dnf repoquery --requires package | 软件包的依赖项列表 |\n| FreeBSD Packages | pkg info package | Shows info for an installed package. |\n| FreeBSD Ports | cd /usr/ports/category/port && cat pkg-descr |  |\n\n\n### 从仓库安装一个软件包\n一旦你知道软件包的名字，通常你可以使用单条命令来安装它和它的依赖项。一般来说，你可以将所有软件名一起列出将它们全部安装。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | sudo apt-get install package |  |\n|  | sudo apt-get install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo apt-get install -y package | 提示是否继续是都选择\"yes\" |\n|  | sudo apt install package | 显示一个有颜色的进度条 |\n| CentOS | sudo yum install package |  |\n|  | sudo yum install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo yum install -y package | 提示是否继续是都选择\"yes\" |\n| Fedora | sudo dnf install package |  |\n|  | sudo dnf install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo dnf install -y package | 提示是否继续是都选择\"yes\" |\n| FreeBSD Packages | sudo pkg install package |  |\n|  | sudo pkg install package1 package2 ... | 安装所有列出的软件 |\n| FreeBSD Ports | cd /usr/ports/category/port && sudo make install | 从源代码编译安装一个port |\n\n### 从本地文件系统安装一个软件包\n\n有时，即使软件没有针对给定的操作系统正式打包，开发者或供应商也会提供打包文件下载。你通常可以使用Web浏览器下载，或者通过`curl`命令下载。一旦安装包在目标系统上，它通常可以用一个命令安装。\n\n在Debian派生的系统上，dkpg处理单个软件包文件。如果一个软件包为满足依赖关系，`gdebi`通常可以用来从官方存储库检索它们。\n\n在CentOS和Fedora系统上，`yum`和`dnf`命令用于安装单个文件，这两个命令也会处理需要的依赖包。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | sudo dpkg -i package.deb |  |\n|  | sudo apt-get install -y gdebi && sudo gdebi package.deb | 安装`gdebi`并使用gdebi安装package.deb并安装它的依赖项 |\n| CentOS | sudo yum install package.rpm |  |\n| Fedora | sudo dnf install package.rpm |  |\n| FreeBSD Packages | sudo pkg add package.txz |  |\n|  | sudo pkg add -f package.txz | 即使软件已经安装了也依旧安装 |\n\n\n### 卸载一个或多个已安装软件\n\n由于软件包管理器知道给定软件包提供了哪些文件，因此如果软件不再需要，通常可以从系统中彻底删除它们。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu\t | sudo apt-get remove package |  |\n|  | sudo apt remove package |  |\n|  | sudo apt-get autoremove | 删除所有不再需要的包 |\n| CentOS | sudo yum remove package |  |\n| Fedora | sudo dnf erase package |  |\n| FreeBSD Packages | sudo pkg delete package |  |\n|  | sudo pkg autoremove | 删除所有不再需要的包 |\n| FreeBSD Ports | sudo pkg delete package |  |\n|  | cd /usr/ports/path_to_port && make deinstall | De-installs an installed port. |\n\n### `apt`命令\nDebian家族发行版的管理员通常熟悉`apt-get`和`apt-cache`。较少广为人知的是简化的apt接口，apt是专为交互式使用而设计的。\n\n| Traditional Command      |    apt Equivalent |\n| :-------- | :--------| \n| apt-get update | apt update |\n| apt-get dist-upgrade | apt full-upgrade |\n| apt-cache search string | apt search string |\n| apt-get install package | apt install package |\n| apt-get remove package | apt remove package |\n| apt-get purge package | apt purge package |\n\n尽管`apt`对于是一个更容易记住的操作，但是它并不是完全取代传统命令`apt-get`等的工具，并且它的接口可能会在不同版本之间进行更改以提高可用性。如果你在脚本或shell管道中使用包管理命令，那么坚持使用apt-get和apt-cache是一个好主意。\n\n### 帮助\n除了基于Web的文档之外，请记住，Unix手册（通常称为man pages）可用于shell中的大多数命令。要阅读一个页面，请使用`man`：\n```bash\n$ man page\n```\n使用`man`命令，你可以通过键盘箭头键进行导航，按`/`搜索页面中的文本，按`q`退出。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | man apt-get | 更新本地数据库包并使用软件包 |\n|  | man apt-cache | 查询本地软件数据库 |\n|  | man dpkg | 处理单个文件包并查询已安装的软件 |\n|  | man apt | 查询一个对大多数操作更简洁的、用户友好的接口 |\n| CentOS | man yum |  |\n| Fedora | man dnf |  |\n| FreeBSD Packages | man pkg | 处理已编译二进制包 |\n| FreeBSD Ports | man ports | 处理Ports Collection. |\n\n### 结论&扩展阅读\n本指南提供了可以在系统间进行交叉引用的基本操作的概述，但只是浏览了一个复杂主题的表面。有关给定系统的更多细节，你可以参阅以下资源：\n- [This guide](https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials)涵盖Ubuntu和Debian软件包管理器的细节。\n- 这是一份[official CentOS guide to managing software with yum](https://www.centos.org/docs/5/html/yum/)\n- There's a [Fedora wiki page about dnf](https://fedoraproject.org/wiki/Dnf), and [an official manual for dnf itself](https://dnf.readthedocs.org/en/latest/index.html).\n- [This guide](https://www.digitalocean.com/community/tutorials/how-to-manage-packages-on-freebsd-10-1-with-pkg) covers FreeBSD package management using pkg.\n- The [FreeBSD Handbook](https://www.freebsd.org/doc/handbook/) contains a [section on using the Ports Collection](https://www.freebsd.org/doc/handbook/ports-using.html).\n","source":"_posts/译-Linux包管理基础：apt-yum-dnf-pkg.md","raw":"---\ntoc: true\ntitle: '[译]Linux包管理基础：apt,yum,dnf,pkg'\ndate: 2018-05-05 15:51:14\ntags: [linux,yum,apt]\n---\n\n> 原文地址: [Package Management Basics: apt, yum, dnf, pkg](https://www.digitalocean.com/community/tutorials/package-management-basics-apt-yum-dnf-pkg)\n> 原文作者: Brennen Bearnes\n> 译文出自: [Cap_ljf's Blog](http://cap-ljf.top/)\n> 本文永久链接: \n> 译者: cap_ljf\n\n### 引言\n大多数类Unix操作系统提供了一个用于查找和安装软件的集中式机制。软件通常以软件包的形式分发，保存在软件仓库中。使用软件包被称为软件包管理。软件包为操作系统提供基本的组件，以及共享库、应用程序、服务和文档。\n<!--more-->\n软件包系统不仅仅是一次性安装软件。它还提供用于升级已安装软件的工具。软件包仓库有助于确保代码已经过审核以供你的系统使用，并且已安装的软件版本已获得开发人员和程序包维护人员的批准。\n\n在配置线上或开发环境时，往往需要去官方仓库检查软件版本。已发行稳定版中的软件包可能已过时，特别是在涉及新的或快速变化的软件情况下。尽管如此，软件包管理对于系统管理员和开发者来说是一项至关重要的技能，而为主流发行版提供的丰富软件包是一项巨大的资源。\n\n本指南旨在作为一个查找、安装和升级各个发行版软件包的基础知识的快速参考，并应帮助你在不同系统之间切换这些知识。\n\n### 软件包管理系统：摘要\n大多数软件包系统都是围绕软件包文件集建立的。一个软件包文件通常是一个文档，其中包含已编译二进制文件和其他组装软件的资源以及安装脚本。软件包还包含有价值的元数据，包括依赖项（安装和运行该软件依赖的其他包列表）。\n\n尽管它们的功能和优点大致相同，但各种平台的封装格式和工具各不相同：\n\n| Operating System      |    Format | Tool(s)  |\n| :-------- | --------:| :--: |\n| Debian  | .deb |  apt, apt-cache, apt-get, dpkg   |\n| Ubuntu  | .deb |  apt, apt-cache, apt-get, dpkg   |\n| CentOS  | .rpm |  yum   |\n| Fedora  | .rpm |  dnf   |\n| FreeBSD  | Ports,.deb |  make,pkg   |\n\n在Debian和基于它的系统中，如Ubuntu、Linux Mint和Raspbian，包格式是`.deb`文件。高级打包工具APT（Advanced Packaging Tool）提供用于大多数常见操作的命令：搜索软件仓库、安装软件包集合以及它们的依赖项，以及管理升级。APT命令作为底层命令dpkg工具的前端操作，dpkg处理本地系统上各个`.deb`文件的安装，有时会直接调用dpkg。\n\n近期大多数Debian派生的发行版系统包括`APT`命令，该命令为常用操作提供了一个简洁统一的接口，这些接口传统上由更具体的`apt-get`和`apt-cache`。它的使用是可选的，但可以简化一些任务。\n\nCentOS、Fedora和其他Red Hat家族的成员使用RPM文件。在CentOS中，`yum`用于与单个软件包文件和仓库交互。\n\n在最近的Fedora版本，`yum`已被`dnf`取代，`dnf`是`yum`一个现代化的分支，它保留了`yum`的大部分接口。\n\nFreeBSD的二进制包系统使用pkg命令进行管理。FreeBSD还提供Ports Collection，一个本地目录结构和工具，允许用户使用Makefiles直接从源代码获取、编译和安装软件包。使用pkg通常要方便得多，但偶尔预编译的软件包不可用，或者你可能需要更改编译时选项。\n\n### 更新软件包列表\n大多数系统会保留一份远程仓库可用软件列表在本地数据库。你最好在安装和更新软件前更新这个数据库。作为这种模式的一个部分例外，`yum`和`dnf`会在执行某些操作之前检查更新，但你可以随时询问是否有更新可用。\n\n| System      |    Command |\n| :-------- | :--------|\n| Debian/Ubuntu  | sudo apt-get update |\n||sudo apt update|\n| CentOS  | yum check-update |\n|  Fedora | dnf check-update |\n| FreeBSD Packages  | sudo pkg update |\n| FreeBSD Ports  | sudo portsnap fetch update |\n\n### 更新已安装软件\n\n对于一个没有软件包系统的机器，确保所有已安装软件保持是最新版本将是一个巨大的负担。你将不得不追踪数百个不同软件包的上游更改和安全警报。虽然软件包管理器不能解决升级软件时遇到的每个问题，但它确实使你能够使用少量的命令来维护大多数系统组件。\n\n在FreeBSD，升级已安装的ports可能导致重大的改变或需要手工配置步骤。在使用portmaster升级之前，最好先阅读/usr/ports/UPDATING。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu  | sudo apt-get upgrade |  只升级已安装的并且可以升级的软件包  |\n|| sudo apt-get dist-upgrade | 可以添加或删除软件包以满足新的依赖关系 |\n|| sudo apt upgrade | 同 sudo apt-get upgrade |\n|| sudo apt full-upgrade | 同 apt-get dist-upgrade. |\n| CentOS  | sudo yum update |  |\n| Fedora | sudo dnf upgrade ||\n| FreeBSD Packages\t | sudo pkg upgrade ||\n| FreeBSD Ports | less /usr/ports/UPDATING | 使用`less`命令查看ports的更新注释 |\n|| cd /usr/ports/ports-mgmt/portmaster && sudo make install && sudo portmaster -a | 安装portmaster并用它去更新已安装的ports |\n\n### 查找一个软件包\n大多数发行版都提供软件集的图形或菜单驱动前端。这些可以按类别浏览并发现新软件是一种好方法。但是，通常情况下，查找软件包的最快和最有效的方法是使用命令行工具进行搜索。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n|  Debian / Ubuntu | apt-cache search search_string |  |\n|   | apt search search_string |  |\n| CentOS  | yum search search_string |  |\n|   | yum search all search_string | 搜索所有字段，包括软件名、描述等 |\n| Fedora  | dnf search search_string |  |\n|   | dnf search all search_string | 搜索所有字段，包括软件名、描述等 |\n| FreeBSD Packages  | pkg search search_string | 根据软件名搜索 |\n|   | pkg search -f search_string | 根据软件名搜索，返回完整的的描述 |\n|   | pkg search -D search_string | 搜索描述 |\n| FreeBSD Ports  | cd /usr/ports && make search name=package | 根据软件名搜索 |\n|   | cd /usr/ports && make search key=search_string\t | 搜索评论、描述和依赖项 |\n\n### 查看一个具体软件包的信息\n当要决定安装哪一个软件包时，读一读软件包的详细描述会很有用。除了可读的文本之外，这些文件通常还包含元数据，如版本号和包的依赖项列表等。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | apt-cache show package | 显示本地缓存该软件包的信息 |\n|  | apt show package |  |\n|  | dpkg -s package | 显示一个软件包现在的已安装状态 |\n| CentOS | yum info package |  |\n|  | yum deplist package | 软件包的依赖项列表 |\n| Fedora | dnf info package |  |\n|  | dnf repoquery --requires package | 软件包的依赖项列表 |\n| FreeBSD Packages | pkg info package | Shows info for an installed package. |\n| FreeBSD Ports | cd /usr/ports/category/port && cat pkg-descr |  |\n\n\n### 从仓库安装一个软件包\n一旦你知道软件包的名字，通常你可以使用单条命令来安装它和它的依赖项。一般来说，你可以将所有软件名一起列出将它们全部安装。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | sudo apt-get install package |  |\n|  | sudo apt-get install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo apt-get install -y package | 提示是否继续是都选择\"yes\" |\n|  | sudo apt install package | 显示一个有颜色的进度条 |\n| CentOS | sudo yum install package |  |\n|  | sudo yum install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo yum install -y package | 提示是否继续是都选择\"yes\" |\n| Fedora | sudo dnf install package |  |\n|  | sudo dnf install package1 package2 ... | 安装所有列出的软件 |\n|  | sudo dnf install -y package | 提示是否继续是都选择\"yes\" |\n| FreeBSD Packages | sudo pkg install package |  |\n|  | sudo pkg install package1 package2 ... | 安装所有列出的软件 |\n| FreeBSD Ports | cd /usr/ports/category/port && sudo make install | 从源代码编译安装一个port |\n\n### 从本地文件系统安装一个软件包\n\n有时，即使软件没有针对给定的操作系统正式打包，开发者或供应商也会提供打包文件下载。你通常可以使用Web浏览器下载，或者通过`curl`命令下载。一旦安装包在目标系统上，它通常可以用一个命令安装。\n\n在Debian派生的系统上，dkpg处理单个软件包文件。如果一个软件包为满足依赖关系，`gdebi`通常可以用来从官方存储库检索它们。\n\n在CentOS和Fedora系统上，`yum`和`dnf`命令用于安装单个文件，这两个命令也会处理需要的依赖包。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | sudo dpkg -i package.deb |  |\n|  | sudo apt-get install -y gdebi && sudo gdebi package.deb | 安装`gdebi`并使用gdebi安装package.deb并安装它的依赖项 |\n| CentOS | sudo yum install package.rpm |  |\n| Fedora | sudo dnf install package.rpm |  |\n| FreeBSD Packages | sudo pkg add package.txz |  |\n|  | sudo pkg add -f package.txz | 即使软件已经安装了也依旧安装 |\n\n\n### 卸载一个或多个已安装软件\n\n由于软件包管理器知道给定软件包提供了哪些文件，因此如果软件不再需要，通常可以从系统中彻底删除它们。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu\t | sudo apt-get remove package |  |\n|  | sudo apt remove package |  |\n|  | sudo apt-get autoremove | 删除所有不再需要的包 |\n| CentOS | sudo yum remove package |  |\n| Fedora | sudo dnf erase package |  |\n| FreeBSD Packages | sudo pkg delete package |  |\n|  | sudo pkg autoremove | 删除所有不再需要的包 |\n| FreeBSD Ports | sudo pkg delete package |  |\n|  | cd /usr/ports/path_to_port && make deinstall | De-installs an installed port. |\n\n### `apt`命令\nDebian家族发行版的管理员通常熟悉`apt-get`和`apt-cache`。较少广为人知的是简化的apt接口，apt是专为交互式使用而设计的。\n\n| Traditional Command      |    apt Equivalent |\n| :-------- | :--------| \n| apt-get update | apt update |\n| apt-get dist-upgrade | apt full-upgrade |\n| apt-cache search string | apt search string |\n| apt-get install package | apt install package |\n| apt-get remove package | apt remove package |\n| apt-get purge package | apt purge package |\n\n尽管`apt`对于是一个更容易记住的操作，但是它并不是完全取代传统命令`apt-get`等的工具，并且它的接口可能会在不同版本之间进行更改以提高可用性。如果你在脚本或shell管道中使用包管理命令，那么坚持使用apt-get和apt-cache是一个好主意。\n\n### 帮助\n除了基于Web的文档之外，请记住，Unix手册（通常称为man pages）可用于shell中的大多数命令。要阅读一个页面，请使用`man`：\n```bash\n$ man page\n```\n使用`man`命令，你可以通过键盘箭头键进行导航，按`/`搜索页面中的文本，按`q`退出。\n\n| System      |    Command | Notes  |\n| :-------- | :--------| :--: |\n| Debian / Ubuntu | man apt-get | 更新本地数据库包并使用软件包 |\n|  | man apt-cache | 查询本地软件数据库 |\n|  | man dpkg | 处理单个文件包并查询已安装的软件 |\n|  | man apt | 查询一个对大多数操作更简洁的、用户友好的接口 |\n| CentOS | man yum |  |\n| Fedora | man dnf |  |\n| FreeBSD Packages | man pkg | 处理已编译二进制包 |\n| FreeBSD Ports | man ports | 处理Ports Collection. |\n\n### 结论&扩展阅读\n本指南提供了可以在系统间进行交叉引用的基本操作的概述，但只是浏览了一个复杂主题的表面。有关给定系统的更多细节，你可以参阅以下资源：\n- [This guide](https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials)涵盖Ubuntu和Debian软件包管理器的细节。\n- 这是一份[official CentOS guide to managing software with yum](https://www.centos.org/docs/5/html/yum/)\n- There's a [Fedora wiki page about dnf](https://fedoraproject.org/wiki/Dnf), and [an official manual for dnf itself](https://dnf.readthedocs.org/en/latest/index.html).\n- [This guide](https://www.digitalocean.com/community/tutorials/how-to-manage-packages-on-freebsd-10-1-with-pkg) covers FreeBSD package management using pkg.\n- The [FreeBSD Handbook](https://www.freebsd.org/doc/handbook/) contains a [section on using the Ports Collection](https://www.freebsd.org/doc/handbook/ports-using.html).\n","slug":"译-Linux包管理基础：apt-yum-dnf-pkg","published":1,"updated":"2018-08-13T14:28:27.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5w00316k1559piqoab","content":"<blockquote>\n<p>原文地址: <a href=\"https://www.digitalocean.com/community/tutorials/package-management-basics-apt-yum-dnf-pkg\" target=\"_blank\" rel=\"noopener\">Package Management Basics: apt, yum, dnf, pkg</a><br>原文作者: Brennen Bearnes<br>译文出自: <a href=\"http://cap-ljf.top/\">Cap_ljf’s Blog</a><br>本文永久链接:<br>译者: cap_ljf</p>\n</blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>大多数类Unix操作系统提供了一个用于查找和安装软件的集中式机制。软件通常以软件包的形式分发，保存在软件仓库中。使用软件包被称为软件包管理。软件包为操作系统提供基本的组件，以及共享库、应用程序、服务和文档。<br><a id=\"more\"></a><br>软件包系统不仅仅是一次性安装软件。它还提供用于升级已安装软件的工具。软件包仓库有助于确保代码已经过审核以供你的系统使用，并且已安装的软件版本已获得开发人员和程序包维护人员的批准。</p>\n<p>在配置线上或开发环境时，往往需要去官方仓库检查软件版本。已发行稳定版中的软件包可能已过时，特别是在涉及新的或快速变化的软件情况下。尽管如此，软件包管理对于系统管理员和开发者来说是一项至关重要的技能，而为主流发行版提供的丰富软件包是一项巨大的资源。</p>\n<p>本指南旨在作为一个查找、安装和升级各个发行版软件包的基础知识的快速参考，并应帮助你在不同系统之间切换这些知识。</p>\n<h3 id=\"软件包管理系统：摘要\"><a href=\"#软件包管理系统：摘要\" class=\"headerlink\" title=\"软件包管理系统：摘要\"></a>软件包管理系统：摘要</h3><p>大多数软件包系统都是围绕软件包文件集建立的。一个软件包文件通常是一个文档，其中包含已编译二进制文件和其他组装软件的资源以及安装脚本。软件包还包含有价值的元数据，包括依赖项（安装和运行该软件依赖的其他包列表）。</p>\n<p>尽管它们的功能和优点大致相同，但各种平台的封装格式和工具各不相同：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Operating System</th>\n<th style=\"text-align:right\">Format</th>\n<th style=\"text-align:center\">Tool(s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian</td>\n<td style=\"text-align:right\">.deb</td>\n<td style=\"text-align:center\">apt, apt-cache, apt-get, dpkg</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ubuntu</td>\n<td style=\"text-align:right\">.deb</td>\n<td style=\"text-align:center\">apt, apt-cache, apt-get, dpkg</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:right\">.rpm</td>\n<td style=\"text-align:center\">yum</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:right\">.rpm</td>\n<td style=\"text-align:center\">dnf</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD</td>\n<td style=\"text-align:right\">Ports,.deb</td>\n<td style=\"text-align:center\">make,pkg</td>\n</tr>\n</tbody>\n</table>\n<p>在Debian和基于它的系统中，如Ubuntu、Linux Mint和Raspbian，包格式是<code>.deb</code>文件。高级打包工具APT（Advanced Packaging Tool）提供用于大多数常见操作的命令：搜索软件仓库、安装软件包集合以及它们的依赖项，以及管理升级。APT命令作为底层命令dpkg工具的前端操作，dpkg处理本地系统上各个<code>.deb</code>文件的安装，有时会直接调用dpkg。</p>\n<p>近期大多数Debian派生的发行版系统包括<code>APT</code>命令，该命令为常用操作提供了一个简洁统一的接口，这些接口传统上由更具体的<code>apt-get</code>和<code>apt-cache</code>。它的使用是可选的，但可以简化一些任务。</p>\n<p>CentOS、Fedora和其他Red Hat家族的成员使用RPM文件。在CentOS中，<code>yum</code>用于与单个软件包文件和仓库交互。</p>\n<p>在最近的Fedora版本，<code>yum</code>已被<code>dnf</code>取代，<code>dnf</code>是<code>yum</code>一个现代化的分支，它保留了<code>yum</code>的大部分接口。</p>\n<p>FreeBSD的二进制包系统使用pkg命令进行管理。FreeBSD还提供Ports Collection，一个本地目录结构和工具，允许用户使用Makefiles直接从源代码获取、编译和安装软件包。使用pkg通常要方便得多，但偶尔预编译的软件包不可用，或者你可能需要更改编译时选项。</p>\n<h3 id=\"更新软件包列表\"><a href=\"#更新软件包列表\" class=\"headerlink\" title=\"更新软件包列表\"></a>更新软件包列表</h3><p>大多数系统会保留一份远程仓库可用软件列表在本地数据库。你最好在安装和更新软件前更新这个数据库。作为这种模式的一个部分例外，<code>yum</code>和<code>dnf</code>会在执行某些操作之前检查更新，但你可以随时询问是否有更新可用。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian/Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum check-update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf check-update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">sudo portsnap fetch update</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"更新已安装软件\"><a href=\"#更新已安装软件\" class=\"headerlink\" title=\"更新已安装软件\"></a>更新已安装软件</h3><p>对于一个没有软件包系统的机器，确保所有已安装软件保持是最新版本将是一个巨大的负担。你将不得不追踪数百个不同软件包的上游更改和安全警报。虽然软件包管理器不能解决升级软件时遇到的每个问题，但它确实使你能够使用少量的命令来维护大多数系统组件。</p>\n<p>在FreeBSD，升级已安装的ports可能导致重大的改变或需要手工配置步骤。在使用portmaster升级之前，最好先阅读/usr/ports/UPDATING。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get upgrade</td>\n<td style=\"text-align:center\">只升级已安装的并且可以升级的软件包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get dist-upgrade</td>\n<td style=\"text-align:center\">可以添加或删除软件包以满足新的依赖关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt upgrade</td>\n<td style=\"text-align:center\">同 sudo apt-get upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt full-upgrade</td>\n<td style=\"text-align:center\">同 apt-get dist-upgrade.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum update</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf upgrade</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg upgrade</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">less /usr/ports/UPDATING</td>\n<td style=\"text-align:center\">使用<code>less</code>命令查看ports的更新注释</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports/ports-mgmt/portmaster &amp;&amp; sudo make install &amp;&amp; sudo portmaster -a</td>\n<td style=\"text-align:center\">安装portmaster并用它去更新已安装的ports</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查找一个软件包\"><a href=\"#查找一个软件包\" class=\"headerlink\" title=\"查找一个软件包\"></a>查找一个软件包</h3><p>大多数发行版都提供软件集的图形或菜单驱动前端。这些可以按类别浏览并发现新软件是一种好方法。但是，通常情况下，查找软件包的最快和最有效的方法是使用命令行工具进行搜索。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">apt-cache search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">apt search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yum search all search_string</td>\n<td style=\"text-align:center\">搜索所有字段，包括软件名、描述等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dnf search all search_string</td>\n<td style=\"text-align:center\">搜索所有字段，包括软件名、描述等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">pkg search search_string</td>\n<td style=\"text-align:center\">根据软件名搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">pkg search -f search_string</td>\n<td style=\"text-align:center\">根据软件名搜索，返回完整的的描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">pkg search -D search_string</td>\n<td style=\"text-align:center\">搜索描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports &amp;&amp; make search name=package</td>\n<td style=\"text-align:center\">根据软件名搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports &amp;&amp; make search key=search_string</td>\n<td style=\"text-align:center\">搜索评论、描述和依赖项</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看一个具体软件包的信息\"><a href=\"#查看一个具体软件包的信息\" class=\"headerlink\" title=\"查看一个具体软件包的信息\"></a>查看一个具体软件包的信息</h3><p>当要决定安装哪一个软件包时，读一读软件包的详细描述会很有用。除了可读的文本之外，这些文件通常还包含元数据，如版本号和包的依赖项列表等。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">apt-cache show package</td>\n<td style=\"text-align:center\">显示本地缓存该软件包的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">apt show package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dpkg -s package</td>\n<td style=\"text-align:center\">显示一个软件包现在的已安装状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum info package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yum deplist package</td>\n<td style=\"text-align:center\">软件包的依赖项列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf info package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dnf repoquery –requires package</td>\n<td style=\"text-align:center\">软件包的依赖项列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">pkg info package</td>\n<td style=\"text-align:center\">Shows info for an installed package.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports/category/port &amp;&amp; cat pkg-descr</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"从仓库安装一个软件包\"><a href=\"#从仓库安装一个软件包\" class=\"headerlink\" title=\"从仓库安装一个软件包\"></a>从仓库安装一个软件包</h3><p>一旦你知道软件包的名字，通常你可以使用单条命令来安装它和它的依赖项。一般来说，你可以将所有软件名一起列出将它们全部安装。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt install package</td>\n<td style=\"text-align:center\">显示一个有颜色的进度条</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo yum install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo yum install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo dnf install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo dnf install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports/category/port &amp;&amp; sudo make install</td>\n<td style=\"text-align:center\">从源代码编译安装一个port</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"从本地文件系统安装一个软件包\"><a href=\"#从本地文件系统安装一个软件包\" class=\"headerlink\" title=\"从本地文件系统安装一个软件包\"></a>从本地文件系统安装一个软件包</h3><p>有时，即使软件没有针对给定的操作系统正式打包，开发者或供应商也会提供打包文件下载。你通常可以使用Web浏览器下载，或者通过<code>curl</code>命令下载。一旦安装包在目标系统上，它通常可以用一个命令安装。</p>\n<p>在Debian派生的系统上，dkpg处理单个软件包文件。如果一个软件包为满足依赖关系，<code>gdebi</code>通常可以用来从官方存储库检索它们。</p>\n<p>在CentOS和Fedora系统上，<code>yum</code>和<code>dnf</code>命令用于安装单个文件，这两个命令也会处理需要的依赖包。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo dpkg -i package.deb</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install -y gdebi &amp;&amp; sudo gdebi package.deb</td>\n<td style=\"text-align:center\">安装<code>gdebi</code>并使用gdebi安装package.deb并安装它的依赖项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum install package.rpm</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf install package.rpm</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg add package.txz</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg add -f package.txz</td>\n<td style=\"text-align:center\">即使软件已经安装了也依旧安装</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"卸载一个或多个已安装软件\"><a href=\"#卸载一个或多个已安装软件\" class=\"headerlink\" title=\"卸载一个或多个已安装软件\"></a>卸载一个或多个已安装软件</h3><p>由于软件包管理器知道给定软件包提供了哪些文件，因此如果软件不再需要，通常可以从系统中彻底删除它们。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get autoremove</td>\n<td style=\"text-align:center\">删除所有不再需要的包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf erase package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg delete package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg autoremove</td>\n<td style=\"text-align:center\">删除所有不再需要的包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">sudo pkg delete package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports/path_to_port &amp;&amp; make deinstall</td>\n<td style=\"text-align:center\">De-installs an installed port.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"apt命令\"><a href=\"#apt命令\" class=\"headerlink\" title=\"apt命令\"></a><code>apt</code>命令</h3><p>Debian家族发行版的管理员通常熟悉<code>apt-get</code>和<code>apt-cache</code>。较少广为人知的是简化的apt接口，apt是专为交互式使用而设计的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Traditional Command</th>\n<th style=\"text-align:left\">apt Equivalent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">apt-get update</td>\n<td style=\"text-align:left\">apt update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get dist-upgrade</td>\n<td style=\"text-align:left\">apt full-upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-cache search string</td>\n<td style=\"text-align:left\">apt search string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get install package</td>\n<td style=\"text-align:left\">apt install package</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get remove package</td>\n<td style=\"text-align:left\">apt remove package</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get purge package</td>\n<td style=\"text-align:left\">apt purge package</td>\n</tr>\n</tbody>\n</table>\n<p>尽管<code>apt</code>对于是一个更容易记住的操作，但是它并不是完全取代传统命令<code>apt-get</code>等的工具，并且它的接口可能会在不同版本之间进行更改以提高可用性。如果你在脚本或shell管道中使用包管理命令，那么坚持使用apt-get和apt-cache是一个好主意。</p>\n<h3 id=\"帮助\"><a href=\"#帮助\" class=\"headerlink\" title=\"帮助\"></a>帮助</h3><p>除了基于Web的文档之外，请记住，Unix手册（通常称为man pages）可用于shell中的大多数命令。要阅读一个页面，请使用<code>man</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man page</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>man</code>命令，你可以通过键盘箭头键进行导航，按<code>/</code>搜索页面中的文本，按<code>q</code>退出。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">man apt-get</td>\n<td style=\"text-align:center\">更新本地数据库包并使用软件包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man apt-cache</td>\n<td style=\"text-align:center\">查询本地软件数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man dpkg</td>\n<td style=\"text-align:center\">处理单个文件包并查询已安装的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man apt</td>\n<td style=\"text-align:center\">查询一个对大多数操作更简洁的、用户友好的接口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">man yum</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">man dnf</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">man pkg</td>\n<td style=\"text-align:center\">处理已编译二进制包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">man ports</td>\n<td style=\"text-align:center\">处理Ports Collection.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"结论-amp-扩展阅读\"><a href=\"#结论-amp-扩展阅读\" class=\"headerlink\" title=\"结论&amp;扩展阅读\"></a>结论&amp;扩展阅读</h3><p>本指南提供了可以在系统间进行交叉引用的基本操作的概述，但只是浏览了一个复杂主题的表面。有关给定系统的更多细节，你可以参阅以下资源：</p>\n<ul>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials\" target=\"_blank\" rel=\"noopener\">This guide</a>涵盖Ubuntu和Debian软件包管理器的细节。</li>\n<li>这是一份<a href=\"https://www.centos.org/docs/5/html/yum/\" target=\"_blank\" rel=\"noopener\">official CentOS guide to managing software with yum</a></li>\n<li>There’s a <a href=\"https://fedoraproject.org/wiki/Dnf\" target=\"_blank\" rel=\"noopener\">Fedora wiki page about dnf</a>, and <a href=\"https://dnf.readthedocs.org/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">an official manual for dnf itself</a>.</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-manage-packages-on-freebsd-10-1-with-pkg\" target=\"_blank\" rel=\"noopener\">This guide</a> covers FreeBSD package management using pkg.</li>\n<li>The <a href=\"https://www.freebsd.org/doc/handbook/\" target=\"_blank\" rel=\"noopener\">FreeBSD Handbook</a> contains a <a href=\"https://www.freebsd.org/doc/handbook/ports-using.html\" target=\"_blank\" rel=\"noopener\">section on using the Ports Collection</a>.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原文地址: <a href=\"https://www.digitalocean.com/community/tutorials/package-management-basics-apt-yum-dnf-pkg\" target=\"_blank\" rel=\"noopener\">Package Management Basics: apt, yum, dnf, pkg</a><br>原文作者: Brennen Bearnes<br>译文出自: <a href=\"http://cap-ljf.top/\">Cap_ljf’s Blog</a><br>本文永久链接:<br>译者: cap_ljf</p>\n</blockquote>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>大多数类Unix操作系统提供了一个用于查找和安装软件的集中式机制。软件通常以软件包的形式分发，保存在软件仓库中。使用软件包被称为软件包管理。软件包为操作系统提供基本的组件，以及共享库、应用程序、服务和文档。<br>","more":"<br>软件包系统不仅仅是一次性安装软件。它还提供用于升级已安装软件的工具。软件包仓库有助于确保代码已经过审核以供你的系统使用，并且已安装的软件版本已获得开发人员和程序包维护人员的批准。</p>\n<p>在配置线上或开发环境时，往往需要去官方仓库检查软件版本。已发行稳定版中的软件包可能已过时，特别是在涉及新的或快速变化的软件情况下。尽管如此，软件包管理对于系统管理员和开发者来说是一项至关重要的技能，而为主流发行版提供的丰富软件包是一项巨大的资源。</p>\n<p>本指南旨在作为一个查找、安装和升级各个发行版软件包的基础知识的快速参考，并应帮助你在不同系统之间切换这些知识。</p>\n<h3 id=\"软件包管理系统：摘要\"><a href=\"#软件包管理系统：摘要\" class=\"headerlink\" title=\"软件包管理系统：摘要\"></a>软件包管理系统：摘要</h3><p>大多数软件包系统都是围绕软件包文件集建立的。一个软件包文件通常是一个文档，其中包含已编译二进制文件和其他组装软件的资源以及安装脚本。软件包还包含有价值的元数据，包括依赖项（安装和运行该软件依赖的其他包列表）。</p>\n<p>尽管它们的功能和优点大致相同，但各种平台的封装格式和工具各不相同：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Operating System</th>\n<th style=\"text-align:right\">Format</th>\n<th style=\"text-align:center\">Tool(s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian</td>\n<td style=\"text-align:right\">.deb</td>\n<td style=\"text-align:center\">apt, apt-cache, apt-get, dpkg</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ubuntu</td>\n<td style=\"text-align:right\">.deb</td>\n<td style=\"text-align:center\">apt, apt-cache, apt-get, dpkg</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:right\">.rpm</td>\n<td style=\"text-align:center\">yum</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:right\">.rpm</td>\n<td style=\"text-align:center\">dnf</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD</td>\n<td style=\"text-align:right\">Ports,.deb</td>\n<td style=\"text-align:center\">make,pkg</td>\n</tr>\n</tbody>\n</table>\n<p>在Debian和基于它的系统中，如Ubuntu、Linux Mint和Raspbian，包格式是<code>.deb</code>文件。高级打包工具APT（Advanced Packaging Tool）提供用于大多数常见操作的命令：搜索软件仓库、安装软件包集合以及它们的依赖项，以及管理升级。APT命令作为底层命令dpkg工具的前端操作，dpkg处理本地系统上各个<code>.deb</code>文件的安装，有时会直接调用dpkg。</p>\n<p>近期大多数Debian派生的发行版系统包括<code>APT</code>命令，该命令为常用操作提供了一个简洁统一的接口，这些接口传统上由更具体的<code>apt-get</code>和<code>apt-cache</code>。它的使用是可选的，但可以简化一些任务。</p>\n<p>CentOS、Fedora和其他Red Hat家族的成员使用RPM文件。在CentOS中，<code>yum</code>用于与单个软件包文件和仓库交互。</p>\n<p>在最近的Fedora版本，<code>yum</code>已被<code>dnf</code>取代，<code>dnf</code>是<code>yum</code>一个现代化的分支，它保留了<code>yum</code>的大部分接口。</p>\n<p>FreeBSD的二进制包系统使用pkg命令进行管理。FreeBSD还提供Ports Collection，一个本地目录结构和工具，允许用户使用Makefiles直接从源代码获取、编译和安装软件包。使用pkg通常要方便得多，但偶尔预编译的软件包不可用，或者你可能需要更改编译时选项。</p>\n<h3 id=\"更新软件包列表\"><a href=\"#更新软件包列表\" class=\"headerlink\" title=\"更新软件包列表\"></a>更新软件包列表</h3><p>大多数系统会保留一份远程仓库可用软件列表在本地数据库。你最好在安装和更新软件前更新这个数据库。作为这种模式的一个部分例外，<code>yum</code>和<code>dnf</code>会在执行某些操作之前检查更新，但你可以随时询问是否有更新可用。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian/Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum check-update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf check-update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">sudo portsnap fetch update</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"更新已安装软件\"><a href=\"#更新已安装软件\" class=\"headerlink\" title=\"更新已安装软件\"></a>更新已安装软件</h3><p>对于一个没有软件包系统的机器，确保所有已安装软件保持是最新版本将是一个巨大的负担。你将不得不追踪数百个不同软件包的上游更改和安全警报。虽然软件包管理器不能解决升级软件时遇到的每个问题，但它确实使你能够使用少量的命令来维护大多数系统组件。</p>\n<p>在FreeBSD，升级已安装的ports可能导致重大的改变或需要手工配置步骤。在使用portmaster升级之前，最好先阅读/usr/ports/UPDATING。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get upgrade</td>\n<td style=\"text-align:center\">只升级已安装的并且可以升级的软件包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get dist-upgrade</td>\n<td style=\"text-align:center\">可以添加或删除软件包以满足新的依赖关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt upgrade</td>\n<td style=\"text-align:center\">同 sudo apt-get upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt full-upgrade</td>\n<td style=\"text-align:center\">同 apt-get dist-upgrade.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum update</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf upgrade</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg upgrade</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">less /usr/ports/UPDATING</td>\n<td style=\"text-align:center\">使用<code>less</code>命令查看ports的更新注释</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports/ports-mgmt/portmaster &amp;&amp; sudo make install &amp;&amp; sudo portmaster -a</td>\n<td style=\"text-align:center\">安装portmaster并用它去更新已安装的ports</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查找一个软件包\"><a href=\"#查找一个软件包\" class=\"headerlink\" title=\"查找一个软件包\"></a>查找一个软件包</h3><p>大多数发行版都提供软件集的图形或菜单驱动前端。这些可以按类别浏览并发现新软件是一种好方法。但是，通常情况下，查找软件包的最快和最有效的方法是使用命令行工具进行搜索。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">apt-cache search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">apt search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yum search all search_string</td>\n<td style=\"text-align:center\">搜索所有字段，包括软件名、描述等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf search search_string</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dnf search all search_string</td>\n<td style=\"text-align:center\">搜索所有字段，包括软件名、描述等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">pkg search search_string</td>\n<td style=\"text-align:center\">根据软件名搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">pkg search -f search_string</td>\n<td style=\"text-align:center\">根据软件名搜索，返回完整的的描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">pkg search -D search_string</td>\n<td style=\"text-align:center\">搜索描述</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports &amp;&amp; make search name=package</td>\n<td style=\"text-align:center\">根据软件名搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports &amp;&amp; make search key=search_string</td>\n<td style=\"text-align:center\">搜索评论、描述和依赖项</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看一个具体软件包的信息\"><a href=\"#查看一个具体软件包的信息\" class=\"headerlink\" title=\"查看一个具体软件包的信息\"></a>查看一个具体软件包的信息</h3><p>当要决定安装哪一个软件包时，读一读软件包的详细描述会很有用。除了可读的文本之外，这些文件通常还包含元数据，如版本号和包的依赖项列表等。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">apt-cache show package</td>\n<td style=\"text-align:center\">显示本地缓存该软件包的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">apt show package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dpkg -s package</td>\n<td style=\"text-align:center\">显示一个软件包现在的已安装状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">yum info package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yum deplist package</td>\n<td style=\"text-align:center\">软件包的依赖项列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">dnf info package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">dnf repoquery –requires package</td>\n<td style=\"text-align:center\">软件包的依赖项列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">pkg info package</td>\n<td style=\"text-align:center\">Shows info for an installed package.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports/category/port &amp;&amp; cat pkg-descr</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"从仓库安装一个软件包\"><a href=\"#从仓库安装一个软件包\" class=\"headerlink\" title=\"从仓库安装一个软件包\"></a>从仓库安装一个软件包</h3><p>一旦你知道软件包的名字，通常你可以使用单条命令来安装它和它的依赖项。一般来说，你可以将所有软件名一起列出将它们全部安装。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt install package</td>\n<td style=\"text-align:center\">显示一个有颜色的进度条</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo yum install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo yum install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo dnf install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo dnf install -y package</td>\n<td style=\"text-align:center\">提示是否继续是都选择”yes”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg install package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg install package1 package2 …</td>\n<td style=\"text-align:center\">安装所有列出的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">cd /usr/ports/category/port &amp;&amp; sudo make install</td>\n<td style=\"text-align:center\">从源代码编译安装一个port</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"从本地文件系统安装一个软件包\"><a href=\"#从本地文件系统安装一个软件包\" class=\"headerlink\" title=\"从本地文件系统安装一个软件包\"></a>从本地文件系统安装一个软件包</h3><p>有时，即使软件没有针对给定的操作系统正式打包，开发者或供应商也会提供打包文件下载。你通常可以使用Web浏览器下载，或者通过<code>curl</code>命令下载。一旦安装包在目标系统上，它通常可以用一个命令安装。</p>\n<p>在Debian派生的系统上，dkpg处理单个软件包文件。如果一个软件包为满足依赖关系，<code>gdebi</code>通常可以用来从官方存储库检索它们。</p>\n<p>在CentOS和Fedora系统上，<code>yum</code>和<code>dnf</code>命令用于安装单个文件，这两个命令也会处理需要的依赖包。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo dpkg -i package.deb</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get install -y gdebi &amp;&amp; sudo gdebi package.deb</td>\n<td style=\"text-align:center\">安装<code>gdebi</code>并使用gdebi安装package.deb并安装它的依赖项</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum install package.rpm</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf install package.rpm</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg add package.txz</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg add -f package.txz</td>\n<td style=\"text-align:center\">即使软件已经安装了也依旧安装</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"卸载一个或多个已安装软件\"><a href=\"#卸载一个或多个已安装软件\" class=\"headerlink\" title=\"卸载一个或多个已安装软件\"></a>卸载一个或多个已安装软件</h3><p>由于软件包管理器知道给定软件包提供了哪些文件，因此如果软件不再需要，通常可以从系统中彻底删除它们。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">sudo apt-get remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo apt-get autoremove</td>\n<td style=\"text-align:center\">删除所有不再需要的包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">sudo yum remove package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">sudo dnf erase package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">sudo pkg delete package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">sudo pkg autoremove</td>\n<td style=\"text-align:center\">删除所有不再需要的包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">sudo pkg delete package</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">cd /usr/ports/path_to_port &amp;&amp; make deinstall</td>\n<td style=\"text-align:center\">De-installs an installed port.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"apt命令\"><a href=\"#apt命令\" class=\"headerlink\" title=\"apt命令\"></a><code>apt</code>命令</h3><p>Debian家族发行版的管理员通常熟悉<code>apt-get</code>和<code>apt-cache</code>。较少广为人知的是简化的apt接口，apt是专为交互式使用而设计的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Traditional Command</th>\n<th style=\"text-align:left\">apt Equivalent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">apt-get update</td>\n<td style=\"text-align:left\">apt update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get dist-upgrade</td>\n<td style=\"text-align:left\">apt full-upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-cache search string</td>\n<td style=\"text-align:left\">apt search string</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get install package</td>\n<td style=\"text-align:left\">apt install package</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get remove package</td>\n<td style=\"text-align:left\">apt remove package</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">apt-get purge package</td>\n<td style=\"text-align:left\">apt purge package</td>\n</tr>\n</tbody>\n</table>\n<p>尽管<code>apt</code>对于是一个更容易记住的操作，但是它并不是完全取代传统命令<code>apt-get</code>等的工具，并且它的接口可能会在不同版本之间进行更改以提高可用性。如果你在脚本或shell管道中使用包管理命令，那么坚持使用apt-get和apt-cache是一个好主意。</p>\n<h3 id=\"帮助\"><a href=\"#帮助\" class=\"headerlink\" title=\"帮助\"></a>帮助</h3><p>除了基于Web的文档之外，请记住，Unix手册（通常称为man pages）可用于shell中的大多数命令。要阅读一个页面，请使用<code>man</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ man page</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>man</code>命令，你可以通过键盘箭头键进行导航，按<code>/</code>搜索页面中的文本，按<code>q</code>退出。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">System</th>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Debian / Ubuntu</td>\n<td style=\"text-align:left\">man apt-get</td>\n<td style=\"text-align:center\">更新本地数据库包并使用软件包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man apt-cache</td>\n<td style=\"text-align:center\">查询本地软件数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man dpkg</td>\n<td style=\"text-align:center\">处理单个文件包并查询已安装的软件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">man apt</td>\n<td style=\"text-align:center\">查询一个对大多数操作更简洁的、用户友好的接口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CentOS</td>\n<td style=\"text-align:left\">man yum</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fedora</td>\n<td style=\"text-align:left\">man dnf</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Packages</td>\n<td style=\"text-align:left\">man pkg</td>\n<td style=\"text-align:center\">处理已编译二进制包</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FreeBSD Ports</td>\n<td style=\"text-align:left\">man ports</td>\n<td style=\"text-align:center\">处理Ports Collection.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"结论-amp-扩展阅读\"><a href=\"#结论-amp-扩展阅读\" class=\"headerlink\" title=\"结论&amp;扩展阅读\"></a>结论&amp;扩展阅读</h3><p>本指南提供了可以在系统间进行交叉引用的基本操作的概述，但只是浏览了一个复杂主题的表面。有关给定系统的更多细节，你可以参阅以下资源：</p>\n<ul>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials\" target=\"_blank\" rel=\"noopener\">This guide</a>涵盖Ubuntu和Debian软件包管理器的细节。</li>\n<li>这是一份<a href=\"https://www.centos.org/docs/5/html/yum/\" target=\"_blank\" rel=\"noopener\">official CentOS guide to managing software with yum</a></li>\n<li>There’s a <a href=\"https://fedoraproject.org/wiki/Dnf\" target=\"_blank\" rel=\"noopener\">Fedora wiki page about dnf</a>, and <a href=\"https://dnf.readthedocs.org/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">an official manual for dnf itself</a>.</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-manage-packages-on-freebsd-10-1-with-pkg\" target=\"_blank\" rel=\"noopener\">This guide</a> covers FreeBSD package management using pkg.</li>\n<li>The <a href=\"https://www.freebsd.org/doc/handbook/\" target=\"_blank\" rel=\"noopener\">FreeBSD Handbook</a> contains a <a href=\"https://www.freebsd.org/doc/handbook/ports-using.html\" target=\"_blank\" rel=\"noopener\">section on using the Ports Collection</a>.</li>\n</ul>"},{"toc":true,"title":"正则表达式","date":"2018-03-23T04:01:06.000Z","_content":"\n## 1. 正则表达式是什么\n> 菜鸟教程：正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n<!--more-->\n## 2. 正则语法\n构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。\n\n正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。\n### 普通字符\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n### 非打印字符\n![Alt text](https://app.yinxiang.com/shard/s15/res/1bdd80c2-7840-4ec5-a13c-6f0fe6a2a85c/1521767629685.png)\n### 特殊字符\n特殊字符就是具有特殊功能的字符，如果要匹配特殊字符本身，需要加上转义字符`\\`。\n| 特殊字符      |    描述 |\n| :-------- | --------:|\n| $  | 匹配行尾，如果设置了RegExp的MultiLine属性，则可以匹配多行，即匹配字符串尾 |\n|^|匹配行首|\n|*|匹配`*`号前面子表达式 0次或多次|\n|+|匹配`+`号前面子表达式 1次或多次|\n|.|匹配除换行符`\\n`以外的所有字符|\n|[|标记一个中括号表达式的开始|\n|{|标记限定符表达式的开始|\n|()|标记一个子表达式的开始和结束|\n|?|匹配前面子表达式0次或一次|\n|\\||指明两项中间的一个选择|\n### 限定符\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n![Alt text](https://app.yinxiang.com/shard/s15/res/9c64de64-243d-4be9-825e-647e8436af88/1521768572824.png)\n\n\n## 3. java怎么使用正则\n\n正则表达式的最简单用法就是测试某个特定的字符串是否与它匹配。\n1. 首先构建一个`Pattern`对象。\n`Pattern pattern = Pattern.compile(patternString)` #patternString为正则表达式字符串\n2. 从`pattern`中获得一个`Matcher`，并调用它的`matches`方法\n`Mathcer matcher = pattern.matcher(input)` #input是需要匹配的字符串\n这个匹配器的输入和可以是任何实现了CharSequence接口的类的对象，例如String、StringBuffer和CharBuffer。\n\n在编译这个模式时，你可以设置一个或多个标志：\n`Pattern pattern = Pattern.compile(patternString, 标志1，标志2...)`\n下面是所支持的6个标志：\n- `CASE_INSENSITIVE`：匹配字符时忽略字母的大小写。默认情况下这个标志只考虑US ASCII码字符。\n- `UNICODE_CASE`：当与`CASE_INSENSITIVE`组合时，用Unicode字符集的大小写来匹配。\n- `MULTILINE`：^和$匹配行的开头和结尾，而不是整个输入的开头和结尾。\n- `UNIX_LINES`：在多行模式中匹配^和$时，只有`\\n`被识别成行终止符。\n- `DOTALL`：当使用这个标志时，`.`符号匹配所有字符，包括行终止符。\n- `CANON_EQ`：考虑Unicode字符规范的等价性。例如，u后面跟随分音符号匹配`我打不出来的这个音标`\n\n如果正则表达式包含群组：\n可以使用\n`mather.group(int groupIndex)`来获取某一个匹配群组的字符\n但是这里需要注意，在调用这个函数前需要先调用另外`Matcher`类的两个函数中的一个：\n- `boolean matches()`这个函数会尝试匹配整个字符串，而不是字符串的某一个部分，只有整个字符串匹配上了才会返回`true`\n- `boolean find()`这个函数就会尝试匹配所有情况，而不是整个字符串都要完全匹配。\n【对比】\n```java\npackage re;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * author: jifang\n * date: 18-3-23 上午9:57\n */\n\npublic class RegexTest {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"(1?[0-9]):([0-5][0-9])[ap]m\");\n        String input = \"11:59am11:59am\";\n        Matcher matcher = pattern.matcher(input);\n        if (matcher.matches()){\n            System.out.println(\"matches方法：\" + matcher.group(0));\n        }else {\n            System.out.println(\"matche方法没有匹配到\");\n        }\n        if (matcher.find()) {\n            System.out.println(\"find方法:\" + matcher.group(0));\n        }else {\n            System.out.println(\"find方法没有匹配到\");\n        }\n\n    }\n}\n\n```\n\nMatcher类的`replaceAll`方法将正则表达式出现的所有地方都用替换字符串来替换。\n“替换字符串可以包含对模式中`group`的引用：`$n`表示替换成第n个`group`。” 这句话的意思是把所有满足匹配的`group`都替换成第n个`group`。当我们需要在替换文本中包含一个`$`字符时，需要使用`\\$`来表示。\n如果字符串中包含$和\\，但是又不希望他们被解释成群组的替换符，那么就可以调用`matcher.replaceAll(Matcher.quoteReplacement(str))`。\n\n这里给一个题目，是我在查询Matcher.replaceAll方法时浏览到的一个博客上的题目，大家有兴趣可以自己先写一下，并不难，但是在解这个题的时候基本上关于java 正则相关的几个类的函数你都会用到，其中有很多坑，尤其是`find()`函数：\n【题目】：\n```\n字符串模板： \n    String template=\"尊敬的客户${customerName}你好！本次消费金额${amount}，您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\"; \n其中以 ${ 开始 } 结尾的为待替换的变量域。 \n数据存放于Map中，key为域名，value为域值。如： \nMap-- \n    customerName = 刘明 \n    accountNumber = 888888888\n    balance = $1000000.00\n    amount = $1000.00 \n请编写函数： \n    public static String composeMessage(String template, Map data) throw Exception \n实现将任意模板字符串中的变量域，按域名替换为data中的域值。 \n例如，上例替换结果为： \n    \"尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的余额为$1000000.00，欢迎下次光临！\" \n注：如果Map中找不到域值，以空字符串\"\"替换。 \n```\n【我的解法】\n```java\npackage re;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * author: jifang\n * date: 18-3-23 上午9:57\n */\n\npublic class RegexTest {\n    public static void main(String[] args) throws Exception {\n        String template=\"尊敬的客户${customerName}你好！本次消费金额${amount}，您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\";\n        Map<String,String> map = new HashMap<>();\n        map.put(\"customerName\",\"刘明\");\n        map.put(\"accountNumber\",\"888888888\");\n        map.put(\"balance\",\"$1000000.00\");\n        map.put(\"amount\",\"$1000.00\");\n        String output = composeMessage(template, map);\n        System.out.println(output);\n    }\n\n    public static String composeMessage(String template, Map data)throws Exception{\n        Pattern pattern = Pattern.compile(\"(\\\\$\\\\{(\\\\w+?)\\\\})\");\n        Matcher matcher = pattern.matcher(template);\n        String result = template;\n        // 一开始我使用的groupCount函数进行for循环替换，但是没想到返回的结果一直是1。后来试了好几次才明白，find()函数每次只会返回一个匹配的最大group，为什么是最大group呢，也就是说满足compile函数中的正则表达式的大字符串，而在正则表达式中的小的一些group是会一起返回的。\n        while (matcher.find()){\n                String key = matcher.group(2);\n                String value = (String) data.get(key);\n                if (value==null){\n                    value=\"\";\n                }\n                else if (value.contains(\"$\")){\n                    value = \"\\\\\"+value;\n                }\n                result = result.replaceFirst(\"\\\\$\\\\{[a-zA-Z]+?\\\\}\",value);\n        }\n        return result;\n    }\n}\n```\n【原博主答案】\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexExam {\n    public static void main(String args[]) {\n        HashMap data = new HashMap();\n        String template = \"尊敬的客户${customerName}你好！本次消费金额${amount}，\"\n                + \"您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\";\n        data.put(\"customerName\", \"刘明\");\n        data.put(\"accountNumber\", \"888888888\");\n        data.put(\"balance\", \"$1000000.00\");\n        data.put(\"amount\", \"$1000.00\");\n        try {\n            System.out.println(composeMessage(template, data));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String composeMessage(String template, Map data)\n            throws Exception {\n        String regex = \"\\\\$\\\\{(.+?)\\\\}\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(template);\n        /*\n         * sb用来存储替换过的内容，它会把多次处理过的字符串按源字符串序\n         * 存储起来。\n         */\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String name = matcher.group(1);//键名\n            String value = (String) data.get(name);//键值\n            if (value == null) {\n                value = \"\";\n            } else {\n                /*\n                 * 由于$出现在replacement中时，表示对捕获组的反向引用，所以要对上面替换内容\n                 * 中的 $ 进行替换，让它们变成 \"\\$1000.00\" 或 \"\\$1000000000.00\" ，这样\n                 * 在下面使用 matcher.appendReplacement(sb, value) 进行替换时就不会把\n                 * $1 看成是对组的反向引用了，否则会使用子匹配项值amount 或 balance替换 $1\n                 * ，最后会得到错误结果：\n                 *\n                 * 尊敬的客户刘明你好！本次消费金额amount000.00，您帐户888888888上的余额\n                 * 为balance000000.00，欢迎下次光临！\n                 *\n                 * 要把 $ 替换成 \\$ ，则要使用 \\\\\\\\\\\\& 来替换，因为一个 \\ 要使用 \\\\\\ 来进\n                 * 行替换，而一个 $ 要使用 \\\\$ 来进行替换，因 \\ 与  $ 在作为替换内容时都属于\n                 * 特殊字符：$ 字符表示反向引用组，而 \\ 字符又是用来转义 $ 字符的。\n                 */\n                value = value.replaceAll(\"\\\\$\", \"\\\\\\\\\\\\$\");\n                //System.out.println(\"value=\" + value);\n            }\n            /*\n             * 经过上面的替换操作，现在的 value 中含有 $ 特殊字符的内容被换成了\"\\$1000.00\"\n             * 或 \"\\$1000000000.00\" 了，最后得到下正确的结果：\n             *\n             * 尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的\n             * 余额为$1000000.00，欢迎下次光临！\n             *\n             * 另外，我们在这里使用Matcher对象的appendReplacement()方法来进行替换操作，而\n             * 不是使用String对象的replaceAll()或replaceFirst()方法来进行替换操作，因为\n             * 它们都能只能进行一次性简单的替换操作，而且只能替换成一样的内容，而这里则是要求每\n             * 一个匹配式的替换值都不同，所以就只能在循环里使用appendReplacement方式来进行逐\n             * 个替换了。\n             */\n            matcher.appendReplacement(sb, value);\n            System.out.println(\"sb = \" + sb.toString());\n        }\n        //最后还得要把尾串接到已替换的内容后面去，这里尾串为“，欢迎下次光临！”\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n}\n\n```\n好了，正则表达式就到这里，下次见。\n\n> 参考文献\n> [1] [string.replaceAll()中的特殊字符（$ \\）与matcher.appendReplacement](http://jiangzhengjun.iteye.com/blog/513929)\n> [2] 《Java核心技术卷二》\n> [3] [菜鸟教程-java正则表达式](http://www.runoob.com/java/java-regular-expressions.html)","source":"_posts/正则表达式.md","raw":"---\ntoc: true\ntitle: 正则表达式\ndate: 2018-03-23 12:01:06\ntags: [java,正则表达式]\n---\n\n## 1. 正则表达式是什么\n> 菜鸟教程：正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n<!--more-->\n## 2. 正则语法\n构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。\n\n正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。\n### 普通字符\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n### 非打印字符\n![Alt text](https://app.yinxiang.com/shard/s15/res/1bdd80c2-7840-4ec5-a13c-6f0fe6a2a85c/1521767629685.png)\n### 特殊字符\n特殊字符就是具有特殊功能的字符，如果要匹配特殊字符本身，需要加上转义字符`\\`。\n| 特殊字符      |    描述 |\n| :-------- | --------:|\n| $  | 匹配行尾，如果设置了RegExp的MultiLine属性，则可以匹配多行，即匹配字符串尾 |\n|^|匹配行首|\n|*|匹配`*`号前面子表达式 0次或多次|\n|+|匹配`+`号前面子表达式 1次或多次|\n|.|匹配除换行符`\\n`以外的所有字符|\n|[|标记一个中括号表达式的开始|\n|{|标记限定符表达式的开始|\n|()|标记一个子表达式的开始和结束|\n|?|匹配前面子表达式0次或一次|\n|\\||指明两项中间的一个选择|\n### 限定符\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n![Alt text](https://app.yinxiang.com/shard/s15/res/9c64de64-243d-4be9-825e-647e8436af88/1521768572824.png)\n\n\n## 3. java怎么使用正则\n\n正则表达式的最简单用法就是测试某个特定的字符串是否与它匹配。\n1. 首先构建一个`Pattern`对象。\n`Pattern pattern = Pattern.compile(patternString)` #patternString为正则表达式字符串\n2. 从`pattern`中获得一个`Matcher`，并调用它的`matches`方法\n`Mathcer matcher = pattern.matcher(input)` #input是需要匹配的字符串\n这个匹配器的输入和可以是任何实现了CharSequence接口的类的对象，例如String、StringBuffer和CharBuffer。\n\n在编译这个模式时，你可以设置一个或多个标志：\n`Pattern pattern = Pattern.compile(patternString, 标志1，标志2...)`\n下面是所支持的6个标志：\n- `CASE_INSENSITIVE`：匹配字符时忽略字母的大小写。默认情况下这个标志只考虑US ASCII码字符。\n- `UNICODE_CASE`：当与`CASE_INSENSITIVE`组合时，用Unicode字符集的大小写来匹配。\n- `MULTILINE`：^和$匹配行的开头和结尾，而不是整个输入的开头和结尾。\n- `UNIX_LINES`：在多行模式中匹配^和$时，只有`\\n`被识别成行终止符。\n- `DOTALL`：当使用这个标志时，`.`符号匹配所有字符，包括行终止符。\n- `CANON_EQ`：考虑Unicode字符规范的等价性。例如，u后面跟随分音符号匹配`我打不出来的这个音标`\n\n如果正则表达式包含群组：\n可以使用\n`mather.group(int groupIndex)`来获取某一个匹配群组的字符\n但是这里需要注意，在调用这个函数前需要先调用另外`Matcher`类的两个函数中的一个：\n- `boolean matches()`这个函数会尝试匹配整个字符串，而不是字符串的某一个部分，只有整个字符串匹配上了才会返回`true`\n- `boolean find()`这个函数就会尝试匹配所有情况，而不是整个字符串都要完全匹配。\n【对比】\n```java\npackage re;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * author: jifang\n * date: 18-3-23 上午9:57\n */\n\npublic class RegexTest {\n    public static void main(String[] args) {\n        Pattern pattern = Pattern.compile(\"(1?[0-9]):([0-5][0-9])[ap]m\");\n        String input = \"11:59am11:59am\";\n        Matcher matcher = pattern.matcher(input);\n        if (matcher.matches()){\n            System.out.println(\"matches方法：\" + matcher.group(0));\n        }else {\n            System.out.println(\"matche方法没有匹配到\");\n        }\n        if (matcher.find()) {\n            System.out.println(\"find方法:\" + matcher.group(0));\n        }else {\n            System.out.println(\"find方法没有匹配到\");\n        }\n\n    }\n}\n\n```\n\nMatcher类的`replaceAll`方法将正则表达式出现的所有地方都用替换字符串来替换。\n“替换字符串可以包含对模式中`group`的引用：`$n`表示替换成第n个`group`。” 这句话的意思是把所有满足匹配的`group`都替换成第n个`group`。当我们需要在替换文本中包含一个`$`字符时，需要使用`\\$`来表示。\n如果字符串中包含$和\\，但是又不希望他们被解释成群组的替换符，那么就可以调用`matcher.replaceAll(Matcher.quoteReplacement(str))`。\n\n这里给一个题目，是我在查询Matcher.replaceAll方法时浏览到的一个博客上的题目，大家有兴趣可以自己先写一下，并不难，但是在解这个题的时候基本上关于java 正则相关的几个类的函数你都会用到，其中有很多坑，尤其是`find()`函数：\n【题目】：\n```\n字符串模板： \n    String template=\"尊敬的客户${customerName}你好！本次消费金额${amount}，您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\"; \n其中以 ${ 开始 } 结尾的为待替换的变量域。 \n数据存放于Map中，key为域名，value为域值。如： \nMap-- \n    customerName = 刘明 \n    accountNumber = 888888888\n    balance = $1000000.00\n    amount = $1000.00 \n请编写函数： \n    public static String composeMessage(String template, Map data) throw Exception \n实现将任意模板字符串中的变量域，按域名替换为data中的域值。 \n例如，上例替换结果为： \n    \"尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的余额为$1000000.00，欢迎下次光临！\" \n注：如果Map中找不到域值，以空字符串\"\"替换。 \n```\n【我的解法】\n```java\npackage re;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * author: jifang\n * date: 18-3-23 上午9:57\n */\n\npublic class RegexTest {\n    public static void main(String[] args) throws Exception {\n        String template=\"尊敬的客户${customerName}你好！本次消费金额${amount}，您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\";\n        Map<String,String> map = new HashMap<>();\n        map.put(\"customerName\",\"刘明\");\n        map.put(\"accountNumber\",\"888888888\");\n        map.put(\"balance\",\"$1000000.00\");\n        map.put(\"amount\",\"$1000.00\");\n        String output = composeMessage(template, map);\n        System.out.println(output);\n    }\n\n    public static String composeMessage(String template, Map data)throws Exception{\n        Pattern pattern = Pattern.compile(\"(\\\\$\\\\{(\\\\w+?)\\\\})\");\n        Matcher matcher = pattern.matcher(template);\n        String result = template;\n        // 一开始我使用的groupCount函数进行for循环替换，但是没想到返回的结果一直是1。后来试了好几次才明白，find()函数每次只会返回一个匹配的最大group，为什么是最大group呢，也就是说满足compile函数中的正则表达式的大字符串，而在正则表达式中的小的一些group是会一起返回的。\n        while (matcher.find()){\n                String key = matcher.group(2);\n                String value = (String) data.get(key);\n                if (value==null){\n                    value=\"\";\n                }\n                else if (value.contains(\"$\")){\n                    value = \"\\\\\"+value;\n                }\n                result = result.replaceFirst(\"\\\\$\\\\{[a-zA-Z]+?\\\\}\",value);\n        }\n        return result;\n    }\n}\n```\n【原博主答案】\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexExam {\n    public static void main(String args[]) {\n        HashMap data = new HashMap();\n        String template = \"尊敬的客户${customerName}你好！本次消费金额${amount}，\"\n                + \"您帐户${accountNumber}上的余额为${balance}，欢迎下次光临！\";\n        data.put(\"customerName\", \"刘明\");\n        data.put(\"accountNumber\", \"888888888\");\n        data.put(\"balance\", \"$1000000.00\");\n        data.put(\"amount\", \"$1000.00\");\n        try {\n            System.out.println(composeMessage(template, data));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String composeMessage(String template, Map data)\n            throws Exception {\n        String regex = \"\\\\$\\\\{(.+?)\\\\}\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(template);\n        /*\n         * sb用来存储替换过的内容，它会把多次处理过的字符串按源字符串序\n         * 存储起来。\n         */\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String name = matcher.group(1);//键名\n            String value = (String) data.get(name);//键值\n            if (value == null) {\n                value = \"\";\n            } else {\n                /*\n                 * 由于$出现在replacement中时，表示对捕获组的反向引用，所以要对上面替换内容\n                 * 中的 $ 进行替换，让它们变成 \"\\$1000.00\" 或 \"\\$1000000000.00\" ，这样\n                 * 在下面使用 matcher.appendReplacement(sb, value) 进行替换时就不会把\n                 * $1 看成是对组的反向引用了，否则会使用子匹配项值amount 或 balance替换 $1\n                 * ，最后会得到错误结果：\n                 *\n                 * 尊敬的客户刘明你好！本次消费金额amount000.00，您帐户888888888上的余额\n                 * 为balance000000.00，欢迎下次光临！\n                 *\n                 * 要把 $ 替换成 \\$ ，则要使用 \\\\\\\\\\\\& 来替换，因为一个 \\ 要使用 \\\\\\ 来进\n                 * 行替换，而一个 $ 要使用 \\\\$ 来进行替换，因 \\ 与  $ 在作为替换内容时都属于\n                 * 特殊字符：$ 字符表示反向引用组，而 \\ 字符又是用来转义 $ 字符的。\n                 */\n                value = value.replaceAll(\"\\\\$\", \"\\\\\\\\\\\\$\");\n                //System.out.println(\"value=\" + value);\n            }\n            /*\n             * 经过上面的替换操作，现在的 value 中含有 $ 特殊字符的内容被换成了\"\\$1000.00\"\n             * 或 \"\\$1000000000.00\" 了，最后得到下正确的结果：\n             *\n             * 尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的\n             * 余额为$1000000.00，欢迎下次光临！\n             *\n             * 另外，我们在这里使用Matcher对象的appendReplacement()方法来进行替换操作，而\n             * 不是使用String对象的replaceAll()或replaceFirst()方法来进行替换操作，因为\n             * 它们都能只能进行一次性简单的替换操作，而且只能替换成一样的内容，而这里则是要求每\n             * 一个匹配式的替换值都不同，所以就只能在循环里使用appendReplacement方式来进行逐\n             * 个替换了。\n             */\n            matcher.appendReplacement(sb, value);\n            System.out.println(\"sb = \" + sb.toString());\n        }\n        //最后还得要把尾串接到已替换的内容后面去，这里尾串为“，欢迎下次光临！”\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n}\n\n```\n好了，正则表达式就到这里，下次见。\n\n> 参考文献\n> [1] [string.replaceAll()中的特殊字符（$ \\）与matcher.appendReplacement](http://jiangzhengjun.iteye.com/blog/513929)\n> [2] 《Java核心技术卷二》\n> [3] [菜鸟教程-java正则表达式](http://www.runoob.com/java/java-regular-expressions.html)","slug":"正则表达式","published":1,"updated":"2018-08-13T14:28:27.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e5x00336k15iuaga48a","content":"<h2 id=\"1-正则表达式是什么\"><a href=\"#1-正则表达式是什么\" class=\"headerlink\" title=\"1. 正则表达式是什么\"></a>1. 正则表达式是什么</h2><blockquote>\n<p>菜鸟教程：正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。<br><a id=\"more\"></a></p>\n</blockquote>\n<h2 id=\"2-正则语法\"><a href=\"#2-正则语法\" class=\"headerlink\" title=\"2. 正则语法\"></a>2. 正则语法</h2><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>\n<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>\n<h3 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>\n<h3 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/1bdd80c2-7840-4ec5-a13c-6f0fe6a2a85c/1521767629685.png\" alt=\"Alt text\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>特殊字符就是具有特殊功能的字符，如果要匹配特殊字符本身，需要加上转义字符<code>\\</code>。<br>| 特殊字符      |    描述 |<br>| :——– | ——–:|<br>| $  | 匹配行尾，如果设置了RegExp的MultiLine属性，则可以匹配多行，即匹配字符串尾 |<br>|^|匹配行首|<br>|<em>|匹配`</em><code>号前面子表达式 0次或多次|\n|+|匹配</code>+<code>号前面子表达式 1次或多次|\n|.|匹配除换行符</code>\\n`以外的所有字符|<br>|[|标记一个中括号表达式的开始|<br>|{|标记限定符表达式的开始|<br>|()|标记一个子表达式的开始和结束|<br>|?|匹配前面子表达式0次或一次|<br>|||指明两项中间的一个选择|</p>\n<h3 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br><img src=\"https://app.yinxiang.com/shard/s15/res/9c64de64-243d-4be9-825e-647e8436af88/1521768572824.png\" alt=\"Alt text\"></p>\n<h2 id=\"3-java怎么使用正则\"><a href=\"#3-java怎么使用正则\" class=\"headerlink\" title=\"3. java怎么使用正则\"></a>3. java怎么使用正则</h2><p>正则表达式的最简单用法就是测试某个特定的字符串是否与它匹配。</p>\n<ol>\n<li>首先构建一个<code>Pattern</code>对象。<br><code>Pattern pattern = Pattern.compile(patternString)</code> #patternString为正则表达式字符串</li>\n<li>从<code>pattern</code>中获得一个<code>Matcher</code>，并调用它的<code>matches</code>方法<br><code>Mathcer matcher = pattern.matcher(input)</code> #input是需要匹配的字符串<br>这个匹配器的输入和可以是任何实现了CharSequence接口的类的对象，例如String、StringBuffer和CharBuffer。</li>\n</ol>\n<p>在编译这个模式时，你可以设置一个或多个标志：<br><code>Pattern pattern = Pattern.compile(patternString, 标志1，标志2...)</code><br>下面是所支持的6个标志：</p>\n<ul>\n<li><code>CASE_INSENSITIVE</code>：匹配字符时忽略字母的大小写。默认情况下这个标志只考虑US ASCII码字符。</li>\n<li><code>UNICODE_CASE</code>：当与<code>CASE_INSENSITIVE</code>组合时，用Unicode字符集的大小写来匹配。</li>\n<li><code>MULTILINE</code>：^和$匹配行的开头和结尾，而不是整个输入的开头和结尾。</li>\n<li><code>UNIX_LINES</code>：在多行模式中匹配^和$时，只有<code>\\n</code>被识别成行终止符。</li>\n<li><code>DOTALL</code>：当使用这个标志时，<code>.</code>符号匹配所有字符，包括行终止符。</li>\n<li><code>CANON_EQ</code>：考虑Unicode字符规范的等价性。例如，u后面跟随分音符号匹配<code>我打不出来的这个音标</code></li>\n</ul>\n<p>如果正则表达式包含群组：<br>可以使用<br><code>mather.group(int groupIndex)</code>来获取某一个匹配群组的字符<br>但是这里需要注意，在调用这个函数前需要先调用另外<code>Matcher</code>类的两个函数中的一个：</p>\n<ul>\n<li><code>boolean matches()</code>这个函数会尝试匹配整个字符串，而不是字符串的某一个部分，只有整个字符串匹配上了才会返回<code>true</code></li>\n<li><code>boolean find()</code>这个函数就会尝试匹配所有情况，而不是整个字符串都要完全匹配。<br>【对比】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> re;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-23 上午9:57</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(<span class=\"string\">\"(1?[0-9]):([0-5][0-9])[ap]m\"</span>);</span><br><span class=\"line\">        String input = <span class=\"string\">\"11:59am11:59am\"</span>;</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(input);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.matches())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"matches方法：\"</span> + matcher.group(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"matche方法没有匹配到\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"find方法:\"</span> + matcher.group(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"find方法没有匹配到\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Matcher类的<code>replaceAll</code>方法将正则表达式出现的所有地方都用替换字符串来替换。<br>“替换字符串可以包含对模式中<code>group</code>的引用：<code>$n</code>表示替换成第n个<code>group</code>。” 这句话的意思是把所有满足匹配的<code>group</code>都替换成第n个<code>group</code>。当我们需要在替换文本中包含一个<code>$</code>字符时，需要使用<code>\\$</code>来表示。<br>如果字符串中包含$和\\，但是又不希望他们被解释成群组的替换符，那么就可以调用<code>matcher.replaceAll(Matcher.quoteReplacement(str))</code>。</p>\n<p>这里给一个题目，是我在查询Matcher.replaceAll方法时浏览到的一个博客上的题目，大家有兴趣可以自己先写一下，并不难，但是在解这个题的时候基本上关于java 正则相关的几个类的函数你都会用到，其中有很多坑，尤其是<code>find()</code>函数：<br>【题目】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串模板： </span><br><span class=\"line\">    String template=&quot;尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！&quot;; </span><br><span class=\"line\">其中以 $&#123; 开始 &#125; 结尾的为待替换的变量域。 </span><br><span class=\"line\">数据存放于Map中，key为域名，value为域值。如： </span><br><span class=\"line\">Map-- </span><br><span class=\"line\">    customerName = 刘明 </span><br><span class=\"line\">    accountNumber = 888888888</span><br><span class=\"line\">    balance = $1000000.00</span><br><span class=\"line\">    amount = $1000.00 </span><br><span class=\"line\">请编写函数： </span><br><span class=\"line\">    public static String composeMessage(String template, Map data) throw Exception </span><br><span class=\"line\">实现将任意模板字符串中的变量域，按域名替换为data中的域值。 </span><br><span class=\"line\">例如，上例替换结果为： </span><br><span class=\"line\">    &quot;尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的余额为$1000000.00，欢迎下次光临！&quot; </span><br><span class=\"line\">注：如果Map中找不到域值，以空字符串&quot;&quot;替换。</span><br></pre></td></tr></table></figure></p>\n<p>【我的解法】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> re;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-23 上午9:57</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String template=<span class=\"string\">\"尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！\"</span>;</span><br><span class=\"line\">        Map&lt;String,String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">\"customerName\"</span>,<span class=\"string\">\"刘明\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"accountNumber\"</span>,<span class=\"string\">\"888888888\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"balance\"</span>,<span class=\"string\">\"$1000000.00\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"amount\"</span>,<span class=\"string\">\"$1000.00\"</span>);</span><br><span class=\"line\">        String output = composeMessage(template, map);</span><br><span class=\"line\">        System.out.println(output);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">composeMessage</span><span class=\"params\">(String template, Map data)</span><span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(<span class=\"string\">\"(\\\\$\\\\&#123;(\\\\w+?)\\\\&#125;)\"</span>);</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(template);</span><br><span class=\"line\">        String result = template;</span><br><span class=\"line\">        <span class=\"comment\">// 一开始我使用的groupCount函数进行for循环替换，但是没想到返回的结果一直是1。后来试了好几次才明白，find()函数每次只会返回一个匹配的最大group，为什么是最大group呢，也就是说满足compile函数中的正则表达式的大字符串，而在正则表达式中的小的一些group是会一起返回的。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (matcher.find())&#123;</span><br><span class=\"line\">                String key = matcher.group(<span class=\"number\">2</span>);</span><br><span class=\"line\">                String value = (String) data.get(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    value=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">\"$\"</span>))&#123;</span><br><span class=\"line\">                    value = <span class=\"string\">\"\\\\\"</span>+value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = result.replaceFirst(<span class=\"string\">\"\\\\$\\\\&#123;[a-zA-Z]+?\\\\&#125;\"</span>,value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【原博主答案】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexExam</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        HashMap data = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        String template = <span class=\"string\">\"尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，\"</span></span><br><span class=\"line\">                + <span class=\"string\">\"您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！\"</span>;</span><br><span class=\"line\">        data.put(<span class=\"string\">\"customerName\"</span>, <span class=\"string\">\"刘明\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"accountNumber\"</span>, <span class=\"string\">\"888888888\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"balance\"</span>, <span class=\"string\">\"$1000000.00\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"amount\"</span>, <span class=\"string\">\"$1000.00\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(composeMessage(template, data));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">composeMessage</span><span class=\"params\">(String template, Map data)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String regex = <span class=\"string\">\"\\\\$\\\\&#123;(.+?)\\\\&#125;\"</span>;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(regex);</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(template);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * sb用来存储替换过的内容，它会把多次处理过的字符串按源字符串序</span></span><br><span class=\"line\"><span class=\"comment\">         * 存储起来。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (matcher.find()) &#123;</span><br><span class=\"line\">            String name = matcher.group(<span class=\"number\">1</span>);<span class=\"comment\">//键名</span></span><br><span class=\"line\">            String value = (String) data.get(name);<span class=\"comment\">//键值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                value = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                 * 由于$出现在replacement中时，表示对捕获组的反向引用，所以要对上面替换内容</span></span><br><span class=\"line\"><span class=\"comment\">                 * 中的 $ 进行替换，让它们变成 \"\\$1000.00\" 或 \"\\$1000000000.00\" ，这样</span></span><br><span class=\"line\"><span class=\"comment\">                 * 在下面使用 matcher.appendReplacement(sb, value) 进行替换时就不会把</span></span><br><span class=\"line\"><span class=\"comment\">                 * $1 看成是对组的反向引用了，否则会使用子匹配项值amount 或 balance替换 $1</span></span><br><span class=\"line\"><span class=\"comment\">                 * ，最后会得到错误结果：</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * 尊敬的客户刘明你好！本次消费金额amount000.00，您帐户888888888上的余额</span></span><br><span class=\"line\"><span class=\"comment\">                 * 为balance000000.00，欢迎下次光临！</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * 要把 $ 替换成 \\$ ，则要使用 \\\\\\\\\\\\&amp; 来替换，因为一个 \\ 要使用 \\\\\\ 来进</span></span><br><span class=\"line\"><span class=\"comment\">                 * 行替换，而一个 $ 要使用 \\\\$ 来进行替换，因 \\ 与  $ 在作为替换内容时都属于</span></span><br><span class=\"line\"><span class=\"comment\">                 * 特殊字符：$ 字符表示反向引用组，而 \\ 字符又是用来转义 $ 字符的。</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                value = value.replaceAll(<span class=\"string\">\"\\\\$\"</span>, <span class=\"string\">\"\\\\\\\\\\\\$\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(\"value=\" + value);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * 经过上面的替换操作，现在的 value 中含有 $ 特殊字符的内容被换成了\"\\$1000.00\"</span></span><br><span class=\"line\"><span class=\"comment\">             * 或 \"\\$1000000000.00\" 了，最后得到下正确的结果：</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的</span></span><br><span class=\"line\"><span class=\"comment\">             * 余额为$1000000.00，欢迎下次光临！</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 另外，我们在这里使用Matcher对象的appendReplacement()方法来进行替换操作，而</span></span><br><span class=\"line\"><span class=\"comment\">             * 不是使用String对象的replaceAll()或replaceFirst()方法来进行替换操作，因为</span></span><br><span class=\"line\"><span class=\"comment\">             * 它们都能只能进行一次性简单的替换操作，而且只能替换成一样的内容，而这里则是要求每</span></span><br><span class=\"line\"><span class=\"comment\">             * 一个匹配式的替换值都不同，所以就只能在循环里使用appendReplacement方式来进行逐</span></span><br><span class=\"line\"><span class=\"comment\">             * 个替换了。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            matcher.appendReplacement(sb, value);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"sb = \"</span> + sb.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最后还得要把尾串接到已替换的内容后面去，这里尾串为“，欢迎下次光临！”</span></span><br><span class=\"line\">        matcher.appendTail(sb);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，正则表达式就到这里，下次见。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://jiangzhengjun.iteye.com/blog/513929\" target=\"_blank\" rel=\"noopener\">string.replaceAll()中的特殊字符（$ \\）与matcher.appendReplacement</a><br>[2] 《Java核心技术卷二》<br>[3] <a href=\"http://www.runoob.com/java/java-regular-expressions.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-java正则表达式</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-正则表达式是什么\"><a href=\"#1-正则表达式是什么\" class=\"headerlink\" title=\"1. 正则表达式是什么\"></a>1. 正则表达式是什么</h2><blockquote>\n<p>菜鸟教程：正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。<br>","more":"</p>\n</blockquote>\n<h2 id=\"2-正则语法\"><a href=\"#2-正则语法\" class=\"headerlink\" title=\"2. 正则语法\"></a>2. 正则语法</h2><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>\n<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>\n<h3 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>\n<h3 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h3><p><img src=\"https://app.yinxiang.com/shard/s15/res/1bdd80c2-7840-4ec5-a13c-6f0fe6a2a85c/1521767629685.png\" alt=\"Alt text\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>特殊字符就是具有特殊功能的字符，如果要匹配特殊字符本身，需要加上转义字符<code>\\</code>。<br>| 特殊字符      |    描述 |<br>| :——– | ——–:|<br>| $  | 匹配行尾，如果设置了RegExp的MultiLine属性，则可以匹配多行，即匹配字符串尾 |<br>|^|匹配行首|<br>|<em>|匹配`</em><code>号前面子表达式 0次或多次|\n|+|匹配</code>+<code>号前面子表达式 1次或多次|\n|.|匹配除换行符</code>\\n`以外的所有字符|<br>|[|标记一个中括号表达式的开始|<br>|{|标记限定符表达式的开始|<br>|()|标记一个子表达式的开始和结束|<br>|?|匹配前面子表达式0次或一次|<br>|||指明两项中间的一个选择|</p>\n<h3 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。<br><img src=\"https://app.yinxiang.com/shard/s15/res/9c64de64-243d-4be9-825e-647e8436af88/1521768572824.png\" alt=\"Alt text\"></p>\n<h2 id=\"3-java怎么使用正则\"><a href=\"#3-java怎么使用正则\" class=\"headerlink\" title=\"3. java怎么使用正则\"></a>3. java怎么使用正则</h2><p>正则表达式的最简单用法就是测试某个特定的字符串是否与它匹配。</p>\n<ol>\n<li>首先构建一个<code>Pattern</code>对象。<br><code>Pattern pattern = Pattern.compile(patternString)</code> #patternString为正则表达式字符串</li>\n<li>从<code>pattern</code>中获得一个<code>Matcher</code>，并调用它的<code>matches</code>方法<br><code>Mathcer matcher = pattern.matcher(input)</code> #input是需要匹配的字符串<br>这个匹配器的输入和可以是任何实现了CharSequence接口的类的对象，例如String、StringBuffer和CharBuffer。</li>\n</ol>\n<p>在编译这个模式时，你可以设置一个或多个标志：<br><code>Pattern pattern = Pattern.compile(patternString, 标志1，标志2...)</code><br>下面是所支持的6个标志：</p>\n<ul>\n<li><code>CASE_INSENSITIVE</code>：匹配字符时忽略字母的大小写。默认情况下这个标志只考虑US ASCII码字符。</li>\n<li><code>UNICODE_CASE</code>：当与<code>CASE_INSENSITIVE</code>组合时，用Unicode字符集的大小写来匹配。</li>\n<li><code>MULTILINE</code>：^和$匹配行的开头和结尾，而不是整个输入的开头和结尾。</li>\n<li><code>UNIX_LINES</code>：在多行模式中匹配^和$时，只有<code>\\n</code>被识别成行终止符。</li>\n<li><code>DOTALL</code>：当使用这个标志时，<code>.</code>符号匹配所有字符，包括行终止符。</li>\n<li><code>CANON_EQ</code>：考虑Unicode字符规范的等价性。例如，u后面跟随分音符号匹配<code>我打不出来的这个音标</code></li>\n</ul>\n<p>如果正则表达式包含群组：<br>可以使用<br><code>mather.group(int groupIndex)</code>来获取某一个匹配群组的字符<br>但是这里需要注意，在调用这个函数前需要先调用另外<code>Matcher</code>类的两个函数中的一个：</p>\n<ul>\n<li><code>boolean matches()</code>这个函数会尝试匹配整个字符串，而不是字符串的某一个部分，只有整个字符串匹配上了才会返回<code>true</code></li>\n<li><code>boolean find()</code>这个函数就会尝试匹配所有情况，而不是整个字符串都要完全匹配。<br>【对比】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> re;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-23 上午9:57</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(<span class=\"string\">\"(1?[0-9]):([0-5][0-9])[ap]m\"</span>);</span><br><span class=\"line\">        String input = <span class=\"string\">\"11:59am11:59am\"</span>;</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(input);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.matches())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"matches方法：\"</span> + matcher.group(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"matche方法没有匹配到\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matcher.find()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"find方法:\"</span> + matcher.group(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"find方法没有匹配到\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Matcher类的<code>replaceAll</code>方法将正则表达式出现的所有地方都用替换字符串来替换。<br>“替换字符串可以包含对模式中<code>group</code>的引用：<code>$n</code>表示替换成第n个<code>group</code>。” 这句话的意思是把所有满足匹配的<code>group</code>都替换成第n个<code>group</code>。当我们需要在替换文本中包含一个<code>$</code>字符时，需要使用<code>\\$</code>来表示。<br>如果字符串中包含$和\\，但是又不希望他们被解释成群组的替换符，那么就可以调用<code>matcher.replaceAll(Matcher.quoteReplacement(str))</code>。</p>\n<p>这里给一个题目，是我在查询Matcher.replaceAll方法时浏览到的一个博客上的题目，大家有兴趣可以自己先写一下，并不难，但是在解这个题的时候基本上关于java 正则相关的几个类的函数你都会用到，其中有很多坑，尤其是<code>find()</code>函数：<br>【题目】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串模板： </span><br><span class=\"line\">    String template=&quot;尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！&quot;; </span><br><span class=\"line\">其中以 $&#123; 开始 &#125; 结尾的为待替换的变量域。 </span><br><span class=\"line\">数据存放于Map中，key为域名，value为域值。如： </span><br><span class=\"line\">Map-- </span><br><span class=\"line\">    customerName = 刘明 </span><br><span class=\"line\">    accountNumber = 888888888</span><br><span class=\"line\">    balance = $1000000.00</span><br><span class=\"line\">    amount = $1000.00 </span><br><span class=\"line\">请编写函数： </span><br><span class=\"line\">    public static String composeMessage(String template, Map data) throw Exception </span><br><span class=\"line\">实现将任意模板字符串中的变量域，按域名替换为data中的域值。 </span><br><span class=\"line\">例如，上例替换结果为： </span><br><span class=\"line\">    &quot;尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的余额为$1000000.00，欢迎下次光临！&quot; </span><br><span class=\"line\">注：如果Map中找不到域值，以空字符串&quot;&quot;替换。</span><br></pre></td></tr></table></figure></p>\n<p>【我的解法】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> re;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-23 上午9:57</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String template=<span class=\"string\">\"尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！\"</span>;</span><br><span class=\"line\">        Map&lt;String,String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">\"customerName\"</span>,<span class=\"string\">\"刘明\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"accountNumber\"</span>,<span class=\"string\">\"888888888\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"balance\"</span>,<span class=\"string\">\"$1000000.00\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"amount\"</span>,<span class=\"string\">\"$1000.00\"</span>);</span><br><span class=\"line\">        String output = composeMessage(template, map);</span><br><span class=\"line\">        System.out.println(output);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">composeMessage</span><span class=\"params\">(String template, Map data)</span><span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(<span class=\"string\">\"(\\\\$\\\\&#123;(\\\\w+?)\\\\&#125;)\"</span>);</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(template);</span><br><span class=\"line\">        String result = template;</span><br><span class=\"line\">        <span class=\"comment\">// 一开始我使用的groupCount函数进行for循环替换，但是没想到返回的结果一直是1。后来试了好几次才明白，find()函数每次只会返回一个匹配的最大group，为什么是最大group呢，也就是说满足compile函数中的正则表达式的大字符串，而在正则表达式中的小的一些group是会一起返回的。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (matcher.find())&#123;</span><br><span class=\"line\">                String key = matcher.group(<span class=\"number\">2</span>);</span><br><span class=\"line\">                String value = (String) data.get(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    value=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.contains(<span class=\"string\">\"$\"</span>))&#123;</span><br><span class=\"line\">                    value = <span class=\"string\">\"\\\\\"</span>+value;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = result.replaceFirst(<span class=\"string\">\"\\\\$\\\\&#123;[a-zA-Z]+?\\\\&#125;\"</span>,value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【原博主答案】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Matcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.Pattern;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegexExam</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        HashMap data = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        String template = <span class=\"string\">\"尊敬的客户$&#123;customerName&#125;你好！本次消费金额$&#123;amount&#125;，\"</span></span><br><span class=\"line\">                + <span class=\"string\">\"您帐户$&#123;accountNumber&#125;上的余额为$&#123;balance&#125;，欢迎下次光临！\"</span>;</span><br><span class=\"line\">        data.put(<span class=\"string\">\"customerName\"</span>, <span class=\"string\">\"刘明\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"accountNumber\"</span>, <span class=\"string\">\"888888888\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"balance\"</span>, <span class=\"string\">\"$1000000.00\"</span>);</span><br><span class=\"line\">        data.put(<span class=\"string\">\"amount\"</span>, <span class=\"string\">\"$1000.00\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(composeMessage(template, data));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">composeMessage</span><span class=\"params\">(String template, Map data)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String regex = <span class=\"string\">\"\\\\$\\\\&#123;(.+?)\\\\&#125;\"</span>;</span><br><span class=\"line\">        Pattern pattern = Pattern.compile(regex);</span><br><span class=\"line\">        Matcher matcher = pattern.matcher(template);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * sb用来存储替换过的内容，它会把多次处理过的字符串按源字符串序</span></span><br><span class=\"line\"><span class=\"comment\">         * 存储起来。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (matcher.find()) &#123;</span><br><span class=\"line\">            String name = matcher.group(<span class=\"number\">1</span>);<span class=\"comment\">//键名</span></span><br><span class=\"line\">            String value = (String) data.get(name);<span class=\"comment\">//键值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                value = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                 * 由于$出现在replacement中时，表示对捕获组的反向引用，所以要对上面替换内容</span></span><br><span class=\"line\"><span class=\"comment\">                 * 中的 $ 进行替换，让它们变成 \"\\$1000.00\" 或 \"\\$1000000000.00\" ，这样</span></span><br><span class=\"line\"><span class=\"comment\">                 * 在下面使用 matcher.appendReplacement(sb, value) 进行替换时就不会把</span></span><br><span class=\"line\"><span class=\"comment\">                 * $1 看成是对组的反向引用了，否则会使用子匹配项值amount 或 balance替换 $1</span></span><br><span class=\"line\"><span class=\"comment\">                 * ，最后会得到错误结果：</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * 尊敬的客户刘明你好！本次消费金额amount000.00，您帐户888888888上的余额</span></span><br><span class=\"line\"><span class=\"comment\">                 * 为balance000000.00，欢迎下次光临！</span></span><br><span class=\"line\"><span class=\"comment\">                 *</span></span><br><span class=\"line\"><span class=\"comment\">                 * 要把 $ 替换成 \\$ ，则要使用 \\\\\\\\\\\\&amp; 来替换，因为一个 \\ 要使用 \\\\\\ 来进</span></span><br><span class=\"line\"><span class=\"comment\">                 * 行替换，而一个 $ 要使用 \\\\$ 来进行替换，因 \\ 与  $ 在作为替换内容时都属于</span></span><br><span class=\"line\"><span class=\"comment\">                 * 特殊字符：$ 字符表示反向引用组，而 \\ 字符又是用来转义 $ 字符的。</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                value = value.replaceAll(<span class=\"string\">\"\\\\$\"</span>, <span class=\"string\">\"\\\\\\\\\\\\$\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(\"value=\" + value);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * 经过上面的替换操作，现在的 value 中含有 $ 特殊字符的内容被换成了\"\\$1000.00\"</span></span><br><span class=\"line\"><span class=\"comment\">             * 或 \"\\$1000000000.00\" 了，最后得到下正确的结果：</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 尊敬的客户刘明你好！本次消费金额$1000.00，您帐户888888888上的</span></span><br><span class=\"line\"><span class=\"comment\">             * 余额为$1000000.00，欢迎下次光临！</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 另外，我们在这里使用Matcher对象的appendReplacement()方法来进行替换操作，而</span></span><br><span class=\"line\"><span class=\"comment\">             * 不是使用String对象的replaceAll()或replaceFirst()方法来进行替换操作，因为</span></span><br><span class=\"line\"><span class=\"comment\">             * 它们都能只能进行一次性简单的替换操作，而且只能替换成一样的内容，而这里则是要求每</span></span><br><span class=\"line\"><span class=\"comment\">             * 一个匹配式的替换值都不同，所以就只能在循环里使用appendReplacement方式来进行逐</span></span><br><span class=\"line\"><span class=\"comment\">             * 个替换了。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            matcher.appendReplacement(sb, value);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"sb = \"</span> + sb.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最后还得要把尾串接到已替换的内容后面去，这里尾串为“，欢迎下次光临！”</span></span><br><span class=\"line\">        matcher.appendTail(sb);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，正则表达式就到这里，下次见。</p>\n<blockquote>\n<p>参考文献<br>[1] <a href=\"http://jiangzhengjun.iteye.com/blog/513929\" target=\"_blank\" rel=\"noopener\">string.replaceAll()中的特殊字符（$ \\）与matcher.appendReplacement</a><br>[2] 《Java核心技术卷二》<br>[3] <a href=\"http://www.runoob.com/java/java-regular-expressions.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程-java正则表达式</a></p>\n</blockquote>"},{"toc":true,"title":"Java网络编程","date":"2018-03-26T14:56:32.000Z","_content":"\n这一篇博客将介绍怎么进行Java网络编程，首先我们回顾网络的基本概念，然后进一步介绍Java socket，并演示网络客户端和服务器是如何实现的，最后将介绍如果通过Java程序发送E-mail，以及如何从Web服务器获得信息。\n<!--more-->\n### 1. Socket\n#### 1.1 连接到服务器\n在Linux和windows操作系统中都预装了`telnet`工具，它对我们调试网络程序非常有帮助。\n首先尝试下面的命令：\n`telnet time-A.timefreq.bldrdoc.gov 13`\n在你的控制台将返回下面一行类似的信息：\n`58203 18-03-26 15:01:27 50 0 0 631.0 UTC(NIST) * `\n如果你得到上面这行信息，说明你已经连接到了大多数UNIX计算机都支持的“当日时间”服务\n\n**socket概念**\n在计算机网络课程中我们学习了ISO七层协议，其中讲述了socket是指ip地址加port端口号组成的通道，当通道连接之后我们就可以使用socket进行数据传输。\n\n下面这个程序的作用和telnet工具是一样的，即连接到某个端口并打印出它所找到的信息。\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * 这个类的作用与telnet工具是一致的，即连接到某个端口并打印出它所找到的信息\n * author: jifang\n * date: 18-3-26 下午2:01\n */\n\npublic class SocketTest {\n    public static void main(String[] args) throws IOException {\n        //打开一个套接字\n        try (Socket s = new Socket(\"time-A.timefreq.bldrdoc.gov\", 13)) {\n            s.setSoTimeout(10000);\n            //一旦套接字被打开，就可以得到一个InputStream对象，使用它进行读取数据\n            InputStream in = s.getInputStream();\n            Scanner sc = new Scanner(in);\n            while (sc.hasNextLine()){\n                System.out.println(sc.nextLine());\n            }\n        }\n    }\n}\n\n```\n**套接字超时**\n从套接字读取信息时，在有数据可以访问之前，读操作将会被阻塞。如果此时主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制而最终会导致超时。\n对于不同的应用，应当确定合理的超时值。调用`setSoTimeout`方法设置超时时间（单位：毫秒）。\n`Socket s = new SOcket(...)`\n`s.setSoTimeout(10000)` # 设置超时时间为10秒\n如果已经为套接字设置了超时时间，并且之后的读操作和写操作在没有完成之前就超过了时间限制，那么这些操作就会抛出`SocketTimeoutException`异常。你可以捕获这个异常，并对超时做出反应。\n\n另外还有一个超时问题是必须解决的。下面这个构造器：\n`Socket s = new Socket(String host, int port)`\n会一直无限期的阻塞下去，知道建立了到达主机的初始连接为止。\n可以先通过建立一个无连接的套接字，然后再使用一个超时来进行连接的方法解决这个问题。\n`Socket s = new Socket();`\n`s.connect(new InetSocketAddress(host, port), timeout);`\n\n**InetAddress**\n因特网地址类，使用它在主机名和因特网地址之间进行转换。\n静态的`getByName(String host)`方法可以返回代表某个主机的InetAddress对象，使用`getAddress`返回对应的ip地址字节数组。\n使用`InetAddress.getAllByName()`获得所有的主机。\n```java\npackage socket;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:11\n */\n\npublic class InetAddressTest {\n    public static void main(String[] args) throws UnknownHostException {\n        if (args.length>0){\n            String host = args[0];\n            InetAddress[] addresses = InetAddress.getAllByName(host);\n            for (InetAddress a:addresses)\n                System.out.println(a);\n        }\n        else\n        {\n            InetAddress localHostAddress = InetAddress.getLocalHost();\n            System.out.println(localHostAddress);\n        }\n    }\n}\n\n```\n###  2. Client/Server通信\n#### 2.1 实现客户端\n现在我们实现一个简单的服务器，它可以向客户端发送信息。\n整个代码的大致情况：\n1. 通过输入数据流从客户端接受一个命令\n2. 解码这个客户端命令\n3. 收集客户端所请求的信息\n4. 通过输出数据流发送信息给客户端\n\n【代码清单】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:20\n */\n\npublic class EchoServer {\n    public static void main(String[] args) throws IOException {\n        try(ServerSocket s = new ServerSocket(8189)){\n            try (Socket incoming = s.accept()){\n                InputStream in = incoming.getInputStream();\n                OutputStream out = incoming.getOutputStream();\n                try (Scanner sc = new Scanner(in)){\n                    PrintWriter pw = new PrintWriter(out, true);\n                    pw.println(\"hello! Enter BYE to exit.\");\n                    boolean done = false;\n                    while (!done && sc.hasNextLine()){\n                        String line = sc.nextLine();\n                        pw.println(\"Echo: \"+line);\n                        if (line.trim().equals(\"BYE\"))done=true;\n                    }\n                }\n            }\n        }\n\n    }\n}\n\n```\n运行这个程序，然后使用`telnet`或再次运行之前的程序`SocketTest`连接本地`8189`端口，当你的客户端连接到这个端口后会立马接收到这条信息：\n`Hello! Enter BYE to exit.`\n之后客户端的输入便是服务器返回的数据。\n```bash\njifang@jifang:~/workspace/javastudy/java/src/main/java/socket% telnet localhost 8189\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nhello! Enter BYE to exit.\n1\nEcho: 1\n2\nEcho: 2\nBYE\nEcho: BYE\nConnection closed by foreign host.\n```\n#### 2.2 为多个客户端服务\n前面的例子中的简单服务器存在一个问题：服务器同一时间只能为一个客户端服务。我们访问各种网站一般都可以处理成千上万个请求，所以我们来写一个多线程的服务器。\n\n每当程序建立一个新的套接字连接，也就是说当调用accept时，将启动一个新的线程来处理服务器与客户端之间的连接，而主程序将立即返回并等待下一个连接。\n【ThreadedEchoServer.java】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:35\n */\n\npublic class ThreadedEchoServer {\n    public static void main(String[] args)  {\n        try {\n            int i = 1;\n            ServerSocket s = new ServerSocket(8189);\n            while (true){\n                Socket incoming = s.accept();\n                System.out.println(\"Spawning \"+i);\n                ThreadEchoHandler r = new ThreadEchoHandler(incoming);\n                Thread thread = new Thread(r);\n                thread.start();\n                i++;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n【ThreadEchoHandler.java】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:30\n */\n\npublic class ThreadEchoHandler implements Runnable {\n\n    private Socket incoming;\n\n    public ThreadEchoHandler(Socket incoming) {\n        this.incoming = incoming;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream inStream = incoming.getInputStream();\n            OutputStream outStream = incoming.getOutputStream();\n            Scanner sc = new Scanner(inStream);\n            PrintWriter pw = new PrintWriter(outStream,true);\n            pw.println(\"Hello! Enter BYE to exit.\");\n            boolean done = false;\n            while (!done && sc.hasNextLine()){\n                String line = sc.nextLine();\n                pw.println(\"Echo: \"+line);\n                if (line.trim().equals(\"BYE\"))done=true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                incoming.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n在这个程序中我们为每个连接生成一个单独的线程。这种方法并不能满足高性能服务器的要求。为使服务器实现更高的吞吐量，可以使用java.nio包中的一些特性，我们将在下一篇博客中讲述**NIO**。\n\n### 3. URL和URLConnection\n为了更高级别的处理网络服务，我们将讨论专门用于此目的的Java类库中的各个类。\n#### 3.1 URI、URL、URN\n#### 3.2 使用URLConnection获取信息\n如果想从某个Web资源获取更多的信息，那么应该使用URLConnection类，通过它能够得到比基本的URL类更多的控制功能。\n\n操作步骤：\n1. 调用URL类中的`openConnection`方法获得URLConection对象：\n`URLConnection connection = url.openConnection()`\n2. 使用以下方法设置 HTTP Header属性：\n`setDoInput`\n`SetDoOutput`\n`setIfmodifiedSince`\n`setUseCaches`\n`setReadTimeout`\n...\n3. 调用connect方法链接远程资源：\n`connection.connect()`\n除了与服务器建立套接字连接外，该方法还可用于向服务器查询头信息（header）\n4. 与服务器建立连接后，你可以查询头信息。getHeaderFieldKey和getHeaderField两个方法枚举了消息头的所有字段。`getHeaderFields`方法返回一个包含了消息头中所有字段的标准Map对象。\n`getContentType`\n`getContentLength`\n`getContentEncoding`\n`getDate`\n...\n5. 最后，访问资源数据。使用`getInputStream`方法获取一个输入流用以读取信息。\n\n**注意：** *默认情况下URLConnection发送一个HTTP GET请求到web服务器。如果你想发送一个HTTP POST请求，要调用URLConnection.setDoOutput(true)方法，如下：* \n```java\nURL url = new URL(\"http://jenkov.com\");\nURLConnection urlConnection = url.openConnection();\nurlConnection.setDoOutput(true);\n```\n*一旦你调用了setDoOutput(true)，你就可以打开URLConnection的OutputStream，如下：*\n```java\nOutputStream output = urlConnection.getOutputStream();\n```\n你可以使用这个OutputStream向相应的HTTP请求中写任何数据，但你要记得将其转换成URL编码。\n```java\noutput.print(name1+\"=\"+URLEncoder.encode(value1,\"UTF-8\")+\"&\");\noutput.print(name2+\"=\"+URLEncoder.encode(value2,\"UTF-8\"));\noutput.close()\n```\n\n### 4. 发送Email\n\n过去，编写程序通过创建到SMTP专用的端口25来发送邮件是一个很简单的事。SMTP用于描述E-mail消息的格式。一旦连接到服务器，就可以发送一个邮件报头（采用SMTP格式）。\n\n操作过程：\n1. 打开一个到达主机的套接字\n```java\nSocket s = new Socket(\"mail.youserver.com\",25); // 25 is SMTP\nPrintWriter out = new PrintWriter(s.getOutputStream());\n```\n2. 发送一下信息到输出流\n```\nHELO sending host\nMAIL FROM: sender e-mail address\nRCPT TO: recipient e-mail address\nDATA\nSubject: subject\n(blank line)\nmail message(邮件内容)\n\nQUIT\n```\nSMTP规范规定，每一行都要以`\\r`再紧跟一个`\\n`来结尾。\nSMTP之前总是路由任何人的e-mail，在垃圾邮件泛滥的今天，大多数服务器都内置了检查功能，并且只接收来自授信用户或IP地址范围的请求。其中，认证是通过安全套接字连接来实现的，非常冗长乏味。所以我们使用JavaMailAPI在Java程序中发送email。\n\n这里以QQ邮箱来演示如何用JavaMail发送一封邮件\n#### 4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码\nQQ邮箱-->账户-->POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务-->开启POP3/SMTP服务\n发送短信验证通过之后可以看到授权码\n![Alt text](https://app.yinxiang.com/shard/s15/res/a836d720-dcca-42c8-86b1-d21ea60395bc/1522074780596.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/e5374a0f-acba-41e0-9aa8-cd2a6ccbdd3c/1522074797444.png)\n#### 4.2 导入JavaMail jar包\n我使用的maven进行jar包管理\n```xml\n<dependency>\n   <groupId>javax.mail</groupId>\n   <artifactId>mail</artifactId>\n   <version>1.4.7</version>\n</dependency>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/d2fa064e-d387-427b-b21d-e04b2cc25c83/1522074945736.png)\n#### 4.3 代码实现\n【MailTest】\n```java\npackage socket;\n\nimport com.sun.mail.util.MailSSLSocketFactory;\n\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * author: jifang\n * date: 18-3-26 下午5:07\n */\n\npublic class MailTest {\n    public static void main(String[] args) throws IOException, MessagingException {\n        Properties props = new Properties();\n        try (InputStream in = Files.newInputStream(Paths.get(\"src/main/java/socket\",\"mail.properties\"))){\n            // 1. 创建参数配置, 用于连接邮件服务器的参数配置\n            props.load(in);\n            // PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启),\n            //     如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误,\n            //     打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。\n            // SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接,\n            //                  需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助,\n            //                  QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看)\n            /*MailSSLSocketFactory sf = new MailSSLSocketFactory();\n            sf.setTrustAllHosts(true);\n            props.put(\"mail.smtp.ssl.enable\", \"true\");\n            props.put(\"mail.smtp.ssl.socketFactory\", sf);*/\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        List<String> lines = Files.readAllLines(Paths.get(args[0]), Charset.forName(\"utf-8\"));\n\n        String from = lines.get(0);\n        String to = lines.get(1);\n        String subject = lines.get(2);\n        StringBuilder builder = new StringBuilder();\n        for (int i=3;i<lines.size();i++){\n            builder.append(lines.get(i)+\"\\n\");\n        }\n\n        // 2. 根据配置创建会话对象, 用于和邮件服务器交互\n        Session mailSession = Session.getDefaultInstance(props);\n        // 3. 创建一封邮件\n        MimeMessage message = new MimeMessage(mailSession);\n        // 发件人\n        message.setFrom(new InternetAddress(from, \"jifang\", \"UTF-8\"));\n        // 收件人（可以增加多个收件人(RecipientType.To)、抄送(RecipientType.CC)、密送(RecipientType.BCC)）\n        message.addRecipient(Message.RecipientType.TO, new InternetAddress(to,\"jifang\",\"UTF-8\"));\n        //主题\n        message.setSubject(subject);\n        //邮件内容\n        message.setText(builder.toString());\n        // 4. 根据 Session 获取邮件传输对象\n        Transport tr = mailSession.getTransport();\n        try{\n            // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错\n            //\n            //    PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log,\n            //           仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误\n            //           类型到对应邮件服务器的帮助网站上查看具体失败原因。\n            //\n            //    PS_02: 连接失败的原因通常为以下几点, 仔细检查代码:\n            //           (1) 邮箱没有开启 SMTP 服务;\n            //           (2) 邮箱密码错误, 例如某些邮箱开启了独立密码;\n            //           (3) 邮箱服务器要求必须要使用 SSL 安全连接;\n            //           (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务;\n            //           (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。\n            //\n            //    PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。\n            tr.connect(\"smtp.qq.com\",\"1579461369\",\"pjyfztifsbcthbad\");\n            // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人\n            tr.sendMessage(message,message.getAllRecipients());\n        }finally {\n            // 7. 关闭连接\n            tr.close();\n        }\n\n    }\n}\n```\n【mail.properties】\n```xml\nmail.transport.protocol=smtps\nmail.smtps.auth=true\n# 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com\n# QQ邮箱的 SMTP 服务器地址为: smtp.qq.com\nmail.smtps.host=smtp.qq.com\n```\n【message.txt】\n```\nxxx@qq.com\nyyy@qq.com\n测试\n你已经收到了邮件！\n```\n运行`java MailTest message.txt`（message.txt可随意放置，如果你不知道相对路径可以写绝对路径）\n接下来你可以查看收件箱，你就会发现收到邮件啦。\n\n\n> 参考文献\n> [1] 《Java核心技术卷二》\n> [2] [基于JavaMail的Java邮件发送：简单邮件发送](https://blog.csdn.net/xietansheng/article/details/51673073)\n> [3] [用JavaMail通过QQ邮箱来发送邮件（第一篇博客，备忘）](https://www.cnblogs.com/xyzq/p/5704358.html)\n","source":"_posts/Java网络编程.md","raw":"---\ntoc: true\ntitle: Java网络编程\ndate: 2018-03-26 22:56:32\ntags: [Java网络编程,socket,JavaMail]\n---\n\n这一篇博客将介绍怎么进行Java网络编程，首先我们回顾网络的基本概念，然后进一步介绍Java socket，并演示网络客户端和服务器是如何实现的，最后将介绍如果通过Java程序发送E-mail，以及如何从Web服务器获得信息。\n<!--more-->\n### 1. Socket\n#### 1.1 连接到服务器\n在Linux和windows操作系统中都预装了`telnet`工具，它对我们调试网络程序非常有帮助。\n首先尝试下面的命令：\n`telnet time-A.timefreq.bldrdoc.gov 13`\n在你的控制台将返回下面一行类似的信息：\n`58203 18-03-26 15:01:27 50 0 0 631.0 UTC(NIST) * `\n如果你得到上面这行信息，说明你已经连接到了大多数UNIX计算机都支持的“当日时间”服务\n\n**socket概念**\n在计算机网络课程中我们学习了ISO七层协议，其中讲述了socket是指ip地址加port端口号组成的通道，当通道连接之后我们就可以使用socket进行数据传输。\n\n下面这个程序的作用和telnet工具是一样的，即连接到某个端口并打印出它所找到的信息。\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * 这个类的作用与telnet工具是一致的，即连接到某个端口并打印出它所找到的信息\n * author: jifang\n * date: 18-3-26 下午2:01\n */\n\npublic class SocketTest {\n    public static void main(String[] args) throws IOException {\n        //打开一个套接字\n        try (Socket s = new Socket(\"time-A.timefreq.bldrdoc.gov\", 13)) {\n            s.setSoTimeout(10000);\n            //一旦套接字被打开，就可以得到一个InputStream对象，使用它进行读取数据\n            InputStream in = s.getInputStream();\n            Scanner sc = new Scanner(in);\n            while (sc.hasNextLine()){\n                System.out.println(sc.nextLine());\n            }\n        }\n    }\n}\n\n```\n**套接字超时**\n从套接字读取信息时，在有数据可以访问之前，读操作将会被阻塞。如果此时主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制而最终会导致超时。\n对于不同的应用，应当确定合理的超时值。调用`setSoTimeout`方法设置超时时间（单位：毫秒）。\n`Socket s = new SOcket(...)`\n`s.setSoTimeout(10000)` # 设置超时时间为10秒\n如果已经为套接字设置了超时时间，并且之后的读操作和写操作在没有完成之前就超过了时间限制，那么这些操作就会抛出`SocketTimeoutException`异常。你可以捕获这个异常，并对超时做出反应。\n\n另外还有一个超时问题是必须解决的。下面这个构造器：\n`Socket s = new Socket(String host, int port)`\n会一直无限期的阻塞下去，知道建立了到达主机的初始连接为止。\n可以先通过建立一个无连接的套接字，然后再使用一个超时来进行连接的方法解决这个问题。\n`Socket s = new Socket();`\n`s.connect(new InetSocketAddress(host, port), timeout);`\n\n**InetAddress**\n因特网地址类，使用它在主机名和因特网地址之间进行转换。\n静态的`getByName(String host)`方法可以返回代表某个主机的InetAddress对象，使用`getAddress`返回对应的ip地址字节数组。\n使用`InetAddress.getAllByName()`获得所有的主机。\n```java\npackage socket;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:11\n */\n\npublic class InetAddressTest {\n    public static void main(String[] args) throws UnknownHostException {\n        if (args.length>0){\n            String host = args[0];\n            InetAddress[] addresses = InetAddress.getAllByName(host);\n            for (InetAddress a:addresses)\n                System.out.println(a);\n        }\n        else\n        {\n            InetAddress localHostAddress = InetAddress.getLocalHost();\n            System.out.println(localHostAddress);\n        }\n    }\n}\n\n```\n###  2. Client/Server通信\n#### 2.1 实现客户端\n现在我们实现一个简单的服务器，它可以向客户端发送信息。\n整个代码的大致情况：\n1. 通过输入数据流从客户端接受一个命令\n2. 解码这个客户端命令\n3. 收集客户端所请求的信息\n4. 通过输出数据流发送信息给客户端\n\n【代码清单】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:20\n */\n\npublic class EchoServer {\n    public static void main(String[] args) throws IOException {\n        try(ServerSocket s = new ServerSocket(8189)){\n            try (Socket incoming = s.accept()){\n                InputStream in = incoming.getInputStream();\n                OutputStream out = incoming.getOutputStream();\n                try (Scanner sc = new Scanner(in)){\n                    PrintWriter pw = new PrintWriter(out, true);\n                    pw.println(\"hello! Enter BYE to exit.\");\n                    boolean done = false;\n                    while (!done && sc.hasNextLine()){\n                        String line = sc.nextLine();\n                        pw.println(\"Echo: \"+line);\n                        if (line.trim().equals(\"BYE\"))done=true;\n                    }\n                }\n            }\n        }\n\n    }\n}\n\n```\n运行这个程序，然后使用`telnet`或再次运行之前的程序`SocketTest`连接本地`8189`端口，当你的客户端连接到这个端口后会立马接收到这条信息：\n`Hello! Enter BYE to exit.`\n之后客户端的输入便是服务器返回的数据。\n```bash\njifang@jifang:~/workspace/javastudy/java/src/main/java/socket% telnet localhost 8189\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nhello! Enter BYE to exit.\n1\nEcho: 1\n2\nEcho: 2\nBYE\nEcho: BYE\nConnection closed by foreign host.\n```\n#### 2.2 为多个客户端服务\n前面的例子中的简单服务器存在一个问题：服务器同一时间只能为一个客户端服务。我们访问各种网站一般都可以处理成千上万个请求，所以我们来写一个多线程的服务器。\n\n每当程序建立一个新的套接字连接，也就是说当调用accept时，将启动一个新的线程来处理服务器与客户端之间的连接，而主程序将立即返回并等待下一个连接。\n【ThreadedEchoServer.java】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:35\n */\n\npublic class ThreadedEchoServer {\n    public static void main(String[] args)  {\n        try {\n            int i = 1;\n            ServerSocket s = new ServerSocket(8189);\n            while (true){\n                Socket incoming = s.accept();\n                System.out.println(\"Spawning \"+i);\n                ThreadEchoHandler r = new ThreadEchoHandler(incoming);\n                Thread thread = new Thread(r);\n                thread.start();\n                i++;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n【ThreadEchoHandler.java】\n```java\npackage socket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n * author: jifang\n * date: 18-3-26 下午2:30\n */\n\npublic class ThreadEchoHandler implements Runnable {\n\n    private Socket incoming;\n\n    public ThreadEchoHandler(Socket incoming) {\n        this.incoming = incoming;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream inStream = incoming.getInputStream();\n            OutputStream outStream = incoming.getOutputStream();\n            Scanner sc = new Scanner(inStream);\n            PrintWriter pw = new PrintWriter(outStream,true);\n            pw.println(\"Hello! Enter BYE to exit.\");\n            boolean done = false;\n            while (!done && sc.hasNextLine()){\n                String line = sc.nextLine();\n                pw.println(\"Echo: \"+line);\n                if (line.trim().equals(\"BYE\"))done=true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                incoming.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n在这个程序中我们为每个连接生成一个单独的线程。这种方法并不能满足高性能服务器的要求。为使服务器实现更高的吞吐量，可以使用java.nio包中的一些特性，我们将在下一篇博客中讲述**NIO**。\n\n### 3. URL和URLConnection\n为了更高级别的处理网络服务，我们将讨论专门用于此目的的Java类库中的各个类。\n#### 3.1 URI、URL、URN\n#### 3.2 使用URLConnection获取信息\n如果想从某个Web资源获取更多的信息，那么应该使用URLConnection类，通过它能够得到比基本的URL类更多的控制功能。\n\n操作步骤：\n1. 调用URL类中的`openConnection`方法获得URLConection对象：\n`URLConnection connection = url.openConnection()`\n2. 使用以下方法设置 HTTP Header属性：\n`setDoInput`\n`SetDoOutput`\n`setIfmodifiedSince`\n`setUseCaches`\n`setReadTimeout`\n...\n3. 调用connect方法链接远程资源：\n`connection.connect()`\n除了与服务器建立套接字连接外，该方法还可用于向服务器查询头信息（header）\n4. 与服务器建立连接后，你可以查询头信息。getHeaderFieldKey和getHeaderField两个方法枚举了消息头的所有字段。`getHeaderFields`方法返回一个包含了消息头中所有字段的标准Map对象。\n`getContentType`\n`getContentLength`\n`getContentEncoding`\n`getDate`\n...\n5. 最后，访问资源数据。使用`getInputStream`方法获取一个输入流用以读取信息。\n\n**注意：** *默认情况下URLConnection发送一个HTTP GET请求到web服务器。如果你想发送一个HTTP POST请求，要调用URLConnection.setDoOutput(true)方法，如下：* \n```java\nURL url = new URL(\"http://jenkov.com\");\nURLConnection urlConnection = url.openConnection();\nurlConnection.setDoOutput(true);\n```\n*一旦你调用了setDoOutput(true)，你就可以打开URLConnection的OutputStream，如下：*\n```java\nOutputStream output = urlConnection.getOutputStream();\n```\n你可以使用这个OutputStream向相应的HTTP请求中写任何数据，但你要记得将其转换成URL编码。\n```java\noutput.print(name1+\"=\"+URLEncoder.encode(value1,\"UTF-8\")+\"&\");\noutput.print(name2+\"=\"+URLEncoder.encode(value2,\"UTF-8\"));\noutput.close()\n```\n\n### 4. 发送Email\n\n过去，编写程序通过创建到SMTP专用的端口25来发送邮件是一个很简单的事。SMTP用于描述E-mail消息的格式。一旦连接到服务器，就可以发送一个邮件报头（采用SMTP格式）。\n\n操作过程：\n1. 打开一个到达主机的套接字\n```java\nSocket s = new Socket(\"mail.youserver.com\",25); // 25 is SMTP\nPrintWriter out = new PrintWriter(s.getOutputStream());\n```\n2. 发送一下信息到输出流\n```\nHELO sending host\nMAIL FROM: sender e-mail address\nRCPT TO: recipient e-mail address\nDATA\nSubject: subject\n(blank line)\nmail message(邮件内容)\n\nQUIT\n```\nSMTP规范规定，每一行都要以`\\r`再紧跟一个`\\n`来结尾。\nSMTP之前总是路由任何人的e-mail，在垃圾邮件泛滥的今天，大多数服务器都内置了检查功能，并且只接收来自授信用户或IP地址范围的请求。其中，认证是通过安全套接字连接来实现的，非常冗长乏味。所以我们使用JavaMailAPI在Java程序中发送email。\n\n这里以QQ邮箱来演示如何用JavaMail发送一封邮件\n#### 4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码\nQQ邮箱-->账户-->POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务-->开启POP3/SMTP服务\n发送短信验证通过之后可以看到授权码\n![Alt text](https://app.yinxiang.com/shard/s15/res/a836d720-dcca-42c8-86b1-d21ea60395bc/1522074780596.png)\n![Alt text](https://app.yinxiang.com/shard/s15/res/e5374a0f-acba-41e0-9aa8-cd2a6ccbdd3c/1522074797444.png)\n#### 4.2 导入JavaMail jar包\n我使用的maven进行jar包管理\n```xml\n<dependency>\n   <groupId>javax.mail</groupId>\n   <artifactId>mail</artifactId>\n   <version>1.4.7</version>\n</dependency>\n```\n![Alt text](https://app.yinxiang.com/shard/s15/res/d2fa064e-d387-427b-b21d-e04b2cc25c83/1522074945736.png)\n#### 4.3 代码实现\n【MailTest】\n```java\npackage socket;\n\nimport com.sun.mail.util.MailSSLSocketFactory;\n\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * author: jifang\n * date: 18-3-26 下午5:07\n */\n\npublic class MailTest {\n    public static void main(String[] args) throws IOException, MessagingException {\n        Properties props = new Properties();\n        try (InputStream in = Files.newInputStream(Paths.get(\"src/main/java/socket\",\"mail.properties\"))){\n            // 1. 创建参数配置, 用于连接邮件服务器的参数配置\n            props.load(in);\n            // PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启),\n            //     如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误,\n            //     打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。\n            // SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接,\n            //                  需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助,\n            //                  QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看)\n            /*MailSSLSocketFactory sf = new MailSSLSocketFactory();\n            sf.setTrustAllHosts(true);\n            props.put(\"mail.smtp.ssl.enable\", \"true\");\n            props.put(\"mail.smtp.ssl.socketFactory\", sf);*/\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        List<String> lines = Files.readAllLines(Paths.get(args[0]), Charset.forName(\"utf-8\"));\n\n        String from = lines.get(0);\n        String to = lines.get(1);\n        String subject = lines.get(2);\n        StringBuilder builder = new StringBuilder();\n        for (int i=3;i<lines.size();i++){\n            builder.append(lines.get(i)+\"\\n\");\n        }\n\n        // 2. 根据配置创建会话对象, 用于和邮件服务器交互\n        Session mailSession = Session.getDefaultInstance(props);\n        // 3. 创建一封邮件\n        MimeMessage message = new MimeMessage(mailSession);\n        // 发件人\n        message.setFrom(new InternetAddress(from, \"jifang\", \"UTF-8\"));\n        // 收件人（可以增加多个收件人(RecipientType.To)、抄送(RecipientType.CC)、密送(RecipientType.BCC)）\n        message.addRecipient(Message.RecipientType.TO, new InternetAddress(to,\"jifang\",\"UTF-8\"));\n        //主题\n        message.setSubject(subject);\n        //邮件内容\n        message.setText(builder.toString());\n        // 4. 根据 Session 获取邮件传输对象\n        Transport tr = mailSession.getTransport();\n        try{\n            // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错\n            //\n            //    PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log,\n            //           仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误\n            //           类型到对应邮件服务器的帮助网站上查看具体失败原因。\n            //\n            //    PS_02: 连接失败的原因通常为以下几点, 仔细检查代码:\n            //           (1) 邮箱没有开启 SMTP 服务;\n            //           (2) 邮箱密码错误, 例如某些邮箱开启了独立密码;\n            //           (3) 邮箱服务器要求必须要使用 SSL 安全连接;\n            //           (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务;\n            //           (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。\n            //\n            //    PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。\n            tr.connect(\"smtp.qq.com\",\"1579461369\",\"pjyfztifsbcthbad\");\n            // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人\n            tr.sendMessage(message,message.getAllRecipients());\n        }finally {\n            // 7. 关闭连接\n            tr.close();\n        }\n\n    }\n}\n```\n【mail.properties】\n```xml\nmail.transport.protocol=smtps\nmail.smtps.auth=true\n# 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com\n# QQ邮箱的 SMTP 服务器地址为: smtp.qq.com\nmail.smtps.host=smtp.qq.com\n```\n【message.txt】\n```\nxxx@qq.com\nyyy@qq.com\n测试\n你已经收到了邮件！\n```\n运行`java MailTest message.txt`（message.txt可随意放置，如果你不知道相对路径可以写绝对路径）\n接下来你可以查看收件箱，你就会发现收到邮件啦。\n\n\n> 参考文献\n> [1] 《Java核心技术卷二》\n> [2] [基于JavaMail的Java邮件发送：简单邮件发送](https://blog.csdn.net/xietansheng/article/details/51673073)\n> [3] [用JavaMail通过QQ邮箱来发送邮件（第一篇博客，备忘）](https://www.cnblogs.com/xyzq/p/5704358.html)\n","slug":"Java网络编程","published":1,"updated":"2018-08-13T14:28:27.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e6g00436k158sjrsqm9","content":"<p>这一篇博客将介绍怎么进行Java网络编程，首先我们回顾网络的基本概念，然后进一步介绍Java socket，并演示网络客户端和服务器是如何实现的，最后将介绍如果通过Java程序发送E-mail，以及如何从Web服务器获得信息。<br><a id=\"more\"></a></p>\n<h3 id=\"1-Socket\"><a href=\"#1-Socket\" class=\"headerlink\" title=\"1. Socket\"></a>1. Socket</h3><h4 id=\"1-1-连接到服务器\"><a href=\"#1-1-连接到服务器\" class=\"headerlink\" title=\"1.1 连接到服务器\"></a>1.1 连接到服务器</h4><p>在Linux和windows操作系统中都预装了<code>telnet</code>工具，它对我们调试网络程序非常有帮助。<br>首先尝试下面的命令：<br><code>telnet time-A.timefreq.bldrdoc.gov 13</code><br>在你的控制台将返回下面一行类似的信息：<br><code>58203 18-03-26 15:01:27 50 0 0 631.0 UTC(NIST) *</code><br>如果你得到上面这行信息，说明你已经连接到了大多数UNIX计算机都支持的“当日时间”服务</p>\n<p><strong>socket概念</strong><br>在计算机网络课程中我们学习了ISO七层协议，其中讲述了socket是指ip地址加port端口号组成的通道，当通道连接之后我们就可以使用socket进行数据传输。</p>\n<p>下面这个程序的作用和telnet工具是一样的，即连接到某个端口并打印出它所找到的信息。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个类的作用与telnet工具是一致的，即连接到某个端口并打印出它所找到的信息</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:01</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//打开一个套接字</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"time-A.timefreq.bldrdoc.gov\"</span>, <span class=\"number\">13</span>)) &#123;</span><br><span class=\"line\">            s.setSoTimeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">            <span class=\"comment\">//一旦套接字被打开，就可以得到一个InputStream对象，使用它进行读取数据</span></span><br><span class=\"line\">            InputStream in = s.getInputStream();</span><br><span class=\"line\">            Scanner sc = <span class=\"keyword\">new</span> Scanner(in);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sc.hasNextLine())&#123;</span><br><span class=\"line\">                System.out.println(sc.nextLine());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>套接字超时</strong><br>从套接字读取信息时，在有数据可以访问之前，读操作将会被阻塞。如果此时主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制而最终会导致超时。<br>对于不同的应用，应当确定合理的超时值。调用<code>setSoTimeout</code>方法设置超时时间（单位：毫秒）。<br><code>Socket s = new SOcket(...)</code><br><code>s.setSoTimeout(10000)</code> # 设置超时时间为10秒<br>如果已经为套接字设置了超时时间，并且之后的读操作和写操作在没有完成之前就超过了时间限制，那么这些操作就会抛出<code>SocketTimeoutException</code>异常。你可以捕获这个异常，并对超时做出反应。</p>\n<p>另外还有一个超时问题是必须解决的。下面这个构造器：<br><code>Socket s = new Socket(String host, int port)</code><br>会一直无限期的阻塞下去，知道建立了到达主机的初始连接为止。<br>可以先通过建立一个无连接的套接字，然后再使用一个超时来进行连接的方法解决这个问题。<br><code>Socket s = new Socket();</code><br><code>s.connect(new InetSocketAddress(host, port), timeout);</code></p>\n<p><strong>InetAddress</strong><br>因特网地址类，使用它在主机名和因特网地址之间进行转换。<br>静态的<code>getByName(String host)</code>方法可以返回代表某个主机的InetAddress对象，使用<code>getAddress</code>返回对应的ip地址字节数组。<br>使用<code>InetAddress.getAllByName()</code>获得所有的主机。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.UnknownHostException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InetAddressTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">            InetAddress[] addresses = InetAddress.getAllByName(host);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (InetAddress a:addresses)</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            InetAddress localHostAddress = InetAddress.getLocalHost();</span><br><span class=\"line\">            System.out.println(localHostAddress);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Client-Server通信\"><a href=\"#2-Client-Server通信\" class=\"headerlink\" title=\"2. Client/Server通信\"></a>2. Client/Server通信</h3><h4 id=\"2-1-实现客户端\"><a href=\"#2-1-实现客户端\" class=\"headerlink\" title=\"2.1 实现客户端\"></a>2.1 实现客户端</h4><p>现在我们实现一个简单的服务器，它可以向客户端发送信息。<br>整个代码的大致情况：</p>\n<ol>\n<li>通过输入数据流从客户端接受一个命令</li>\n<li>解码这个客户端命令</li>\n<li>收集客户端所请求的信息</li>\n<li>通过输出数据流发送信息给客户端</li>\n</ol>\n<p>【代码清单】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(ServerSocket s = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8189</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket incoming = s.accept())&#123;</span><br><span class=\"line\">                InputStream in = incoming.getInputStream();</span><br><span class=\"line\">                OutputStream out = incoming.getOutputStream();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> (Scanner sc = <span class=\"keyword\">new</span> Scanner(in))&#123;</span><br><span class=\"line\">                    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(out, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    pw.println(<span class=\"string\">\"hello! Enter BYE to exit.\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!done &amp;&amp; sc.hasNextLine())&#123;</span><br><span class=\"line\">                        String line = sc.nextLine();</span><br><span class=\"line\">                        pw.println(<span class=\"string\">\"Echo: \"</span>+line);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (line.trim().equals(<span class=\"string\">\"BYE\"</span>))done=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行这个程序，然后使用<code>telnet</code>或再次运行之前的程序<code>SocketTest</code>连接本地<code>8189</code>端口，当你的客户端连接到这个端口后会立马接收到这条信息：<br><code>Hello! Enter BYE to exit.</code><br>之后客户端的输入便是服务器返回的数据。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jifang@jifang:~/workspace/javastudy/java/src/main/java/socket% telnet localhost 8189</span><br><span class=\"line\">Trying 127.0.0.1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is <span class=\"string\">'^]'</span>.</span><br><span class=\"line\">hello! Enter BYE to <span class=\"built_in\">exit</span>.</span><br><span class=\"line\">1</span><br><span class=\"line\">Echo: 1</span><br><span class=\"line\">2</span><br><span class=\"line\">Echo: 2</span><br><span class=\"line\">BYE</span><br><span class=\"line\">Echo: BYE</span><br><span class=\"line\">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-为多个客户端服务\"><a href=\"#2-2-为多个客户端服务\" class=\"headerlink\" title=\"2.2 为多个客户端服务\"></a>2.2 为多个客户端服务</h4><p>前面的例子中的简单服务器存在一个问题：服务器同一时间只能为一个客户端服务。我们访问各种网站一般都可以处理成千上万个请求，所以我们来写一个多线程的服务器。</p>\n<p>每当程序建立一个新的套接字连接，也就是说当调用accept时，将启动一个新的线程来处理服务器与客户端之间的连接，而主程序将立即返回并等待下一个连接。<br>【ThreadedEchoServer.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:35</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadedEchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            ServerSocket s = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8189</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Socket incoming = s.accept();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Spawning \"</span>+i);</span><br><span class=\"line\">                ThreadEchoHandler r = <span class=\"keyword\">new</span> ThreadEchoHandler(incoming);</span><br><span class=\"line\">                Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">                thread.start();</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【ThreadEchoHandler.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:30</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadEchoHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Socket incoming;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadEchoHandler</span><span class=\"params\">(Socket incoming)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.incoming = incoming;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            InputStream inStream = incoming.getInputStream();</span><br><span class=\"line\">            OutputStream outStream = incoming.getOutputStream();</span><br><span class=\"line\">            Scanner sc = <span class=\"keyword\">new</span> Scanner(inStream);</span><br><span class=\"line\">            PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(outStream,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            pw.println(<span class=\"string\">\"Hello! Enter BYE to exit.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!done &amp;&amp; sc.hasNextLine())&#123;</span><br><span class=\"line\">                String line = sc.nextLine();</span><br><span class=\"line\">                pw.println(<span class=\"string\">\"Echo: \"</span>+line);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line.trim().equals(<span class=\"string\">\"BYE\"</span>))done=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                incoming.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个程序中我们为每个连接生成一个单独的线程。这种方法并不能满足高性能服务器的要求。为使服务器实现更高的吞吐量，可以使用java.nio包中的一些特性，我们将在下一篇博客中讲述<strong>NIO</strong>。</p>\n<h3 id=\"3-URL和URLConnection\"><a href=\"#3-URL和URLConnection\" class=\"headerlink\" title=\"3. URL和URLConnection\"></a>3. URL和URLConnection</h3><p>为了更高级别的处理网络服务，我们将讨论专门用于此目的的Java类库中的各个类。</p>\n<h4 id=\"3-1-URI、URL、URN\"><a href=\"#3-1-URI、URL、URN\" class=\"headerlink\" title=\"3.1 URI、URL、URN\"></a>3.1 URI、URL、URN</h4><h4 id=\"3-2-使用URLConnection获取信息\"><a href=\"#3-2-使用URLConnection获取信息\" class=\"headerlink\" title=\"3.2 使用URLConnection获取信息\"></a>3.2 使用URLConnection获取信息</h4><p>如果想从某个Web资源获取更多的信息，那么应该使用URLConnection类，通过它能够得到比基本的URL类更多的控制功能。</p>\n<p>操作步骤：</p>\n<ol>\n<li>调用URL类中的<code>openConnection</code>方法获得URLConection对象：<br><code>URLConnection connection = url.openConnection()</code></li>\n<li>使用以下方法设置 HTTP Header属性：<br><code>setDoInput</code><br><code>SetDoOutput</code><br><code>setIfmodifiedSince</code><br><code>setUseCaches</code><br><code>setReadTimeout</code><br>…</li>\n<li>调用connect方法链接远程资源：<br><code>connection.connect()</code><br>除了与服务器建立套接字连接外，该方法还可用于向服务器查询头信息（header）</li>\n<li>与服务器建立连接后，你可以查询头信息。getHeaderFieldKey和getHeaderField两个方法枚举了消息头的所有字段。<code>getHeaderFields</code>方法返回一个包含了消息头中所有字段的标准Map对象。<br><code>getContentType</code><br><code>getContentLength</code><br><code>getContentEncoding</code><br><code>getDate</code><br>…</li>\n<li>最后，访问资源数据。使用<code>getInputStream</code>方法获取一个输入流用以读取信息。</li>\n</ol>\n<p><strong>注意：</strong> <em>默认情况下URLConnection发送一个HTTP GET请求到web服务器。如果你想发送一个HTTP POST请求，要调用URLConnection.setDoOutput(true)方法，如下：</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http://jenkov.com\"</span>);</span><br><span class=\"line\">URLConnection urlConnection = url.openConnection();</span><br><span class=\"line\">urlConnection.setDoOutput(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p><em>一旦你调用了setDoOutput(true)，你就可以打开URLConnection的OutputStream，如下：</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStream output = urlConnection.getOutputStream();</span><br></pre></td></tr></table></figure></p>\n<p>你可以使用这个OutputStream向相应的HTTP请求中写任何数据，但你要记得将其转换成URL编码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output.print(name1+<span class=\"string\">\"=\"</span>+URLEncoder.encode(value1,<span class=\"string\">\"UTF-8\"</span>)+<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">output.print(name2+<span class=\"string\">\"=\"</span>+URLEncoder.encode(value2,<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">output.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-发送Email\"><a href=\"#4-发送Email\" class=\"headerlink\" title=\"4. 发送Email\"></a>4. 发送Email</h3><p>过去，编写程序通过创建到SMTP专用的端口25来发送邮件是一个很简单的事。SMTP用于描述E-mail消息的格式。一旦连接到服务器，就可以发送一个邮件报头（采用SMTP格式）。</p>\n<p>操作过程：</p>\n<ol>\n<li><p>打开一个到达主机的套接字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"mail.youserver.com\"</span>,<span class=\"number\">25</span>); <span class=\"comment\">// 25 is SMTP</span></span><br><span class=\"line\">PrintWriter out = <span class=\"keyword\">new</span> PrintWriter(s.getOutputStream());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送一下信息到输出流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELO sending host</span><br><span class=\"line\">MAIL FROM: sender e-mail address</span><br><span class=\"line\">RCPT TO: recipient e-mail address</span><br><span class=\"line\">DATA</span><br><span class=\"line\">Subject: subject</span><br><span class=\"line\">(blank line)</span><br><span class=\"line\">mail message(邮件内容)</span><br><span class=\"line\"></span><br><span class=\"line\">QUIT</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>SMTP规范规定，每一行都要以<code>\\r</code>再紧跟一个<code>\\n</code>来结尾。<br>SMTP之前总是路由任何人的e-mail，在垃圾邮件泛滥的今天，大多数服务器都内置了检查功能，并且只接收来自授信用户或IP地址范围的请求。其中，认证是通过安全套接字连接来实现的，非常冗长乏味。所以我们使用JavaMailAPI在Java程序中发送email。</p>\n<p>这里以QQ邮箱来演示如何用JavaMail发送一封邮件</p>\n<h4 id=\"4-1-先启用QQ邮箱里POP3-STMP服务，生成授权码\"><a href=\"#4-1-先启用QQ邮箱里POP3-STMP服务，生成授权码\" class=\"headerlink\" title=\"4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码\"></a>4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码</h4><p>QQ邮箱–&gt;账户–&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务–&gt;开启POP3/SMTP服务<br>发送短信验证通过之后可以看到授权码<br><img src=\"https://app.yinxiang.com/shard/s15/res/a836d720-dcca-42c8-86b1-d21ea60395bc/1522074780596.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/e5374a0f-acba-41e0-9aa8-cd2a6ccbdd3c/1522074797444.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-2-导入JavaMail-jar包\"><a href=\"#4-2-导入JavaMail-jar包\" class=\"headerlink\" title=\"4.2 导入JavaMail jar包\"></a>4.2 导入JavaMail jar包</h4><p>我使用的maven进行jar包管理<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.mail<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mail<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/d2fa064e-d387-427b-b21d-e04b2cc25c83/1522074945736.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-代码实现\"><a href=\"#4-3-代码实现\" class=\"headerlink\" title=\"4.3 代码实现\"></a>4.3 代码实现</h4><p>【MailTest】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.MessagingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Session;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Transport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.internet.InternetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.internet.MimeMessage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.Charset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Files;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Paths;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.GeneralSecurityException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午5:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, MessagingException </span>&#123;</span><br><span class=\"line\">        Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream in = Files.newInputStream(Paths.get(<span class=\"string\">\"src/main/java/socket\"</span>,<span class=\"string\">\"mail.properties\"</span>)))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 创建参数配置, 用于连接邮件服务器的参数配置</span></span><br><span class=\"line\">            props.load(in);</span><br><span class=\"line\">            <span class=\"comment\">// PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启),</span></span><br><span class=\"line\">            <span class=\"comment\">//     如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误,</span></span><br><span class=\"line\">            <span class=\"comment\">//     打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。</span></span><br><span class=\"line\">            <span class=\"comment\">// SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接,</span></span><br><span class=\"line\">            <span class=\"comment\">//                  需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助,</span></span><br><span class=\"line\">            <span class=\"comment\">//                  QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看)</span></span><br><span class=\"line\">            <span class=\"comment\">/*MailSSLSocketFactory sf = new MailSSLSocketFactory();</span></span><br><span class=\"line\"><span class=\"comment\">            sf.setTrustAllHosts(true);</span></span><br><span class=\"line\"><span class=\"comment\">            props.put(\"mail.smtp.ssl.enable\", \"true\");</span></span><br><span class=\"line\"><span class=\"comment\">            props.put(\"mail.smtp.ssl.socketFactory\", sf);*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(args[<span class=\"number\">0</span>]), Charset.forName(<span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String from = lines.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        String to = lines.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        String subject = lines.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">        StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>;i&lt;lines.size();i++)&#123;</span><br><span class=\"line\">            builder.append(lines.get(i)+<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 根据配置创建会话对象, 用于和邮件服务器交互</span></span><br><span class=\"line\">        Session mailSession = Session.getDefaultInstance(props);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 创建一封邮件</span></span><br><span class=\"line\">        MimeMessage message = <span class=\"keyword\">new</span> MimeMessage(mailSession);</span><br><span class=\"line\">        <span class=\"comment\">// 发件人</span></span><br><span class=\"line\">        message.setFrom(<span class=\"keyword\">new</span> InternetAddress(from, <span class=\"string\">\"jifang\"</span>, <span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 收件人（可以增加多个收件人(RecipientType.To)、抄送(RecipientType.CC)、密送(RecipientType.BCC)）</span></span><br><span class=\"line\">        message.addRecipient(Message.RecipientType.TO, <span class=\"keyword\">new</span> InternetAddress(to,<span class=\"string\">\"jifang\"</span>,<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//主题</span></span><br><span class=\"line\">        message.setSubject(subject);</span><br><span class=\"line\">        <span class=\"comment\">//邮件内容</span></span><br><span class=\"line\">        message.setText(builder.toString());</span><br><span class=\"line\">        <span class=\"comment\">// 4. 根据 Session 获取邮件传输对象</span></span><br><span class=\"line\">        Transport tr = mailSession.getTransport();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log,</span></span><br><span class=\"line\">            <span class=\"comment\">//           仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误</span></span><br><span class=\"line\">            <span class=\"comment\">//           类型到对应邮件服务器的帮助网站上查看具体失败原因。</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_02: 连接失败的原因通常为以下几点, 仔细检查代码:</span></span><br><span class=\"line\">            <span class=\"comment\">//           (1) 邮箱没有开启 SMTP 服务;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (2) 邮箱密码错误, 例如某些邮箱开启了独立密码;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (3) 邮箱服务器要求必须要使用 SSL 安全连接;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。</span></span><br><span class=\"line\">            tr.connect(<span class=\"string\">\"smtp.qq.com\"</span>,<span class=\"string\">\"1579461369\"</span>,<span class=\"string\">\"pjyfztifsbcthbad\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class=\"line\">            tr.sendMessage(message,message.getAllRecipients());</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7. 关闭连接</span></span><br><span class=\"line\">            tr.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【mail.properties】<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mail.transport.protocol=smtps</span><br><span class=\"line\">mail.smtps.auth=true</span><br><span class=\"line\"># 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com</span><br><span class=\"line\"># QQ邮箱的 SMTP 服务器地址为: smtp.qq.com</span><br><span class=\"line\">mail.smtps.host=smtp.qq.com</span><br></pre></td></tr></table></figure></p>\n<p>【message.txt】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx@qq.com</span><br><span class=\"line\">yyy@qq.com</span><br><span class=\"line\">测试</span><br><span class=\"line\">你已经收到了邮件！</span><br></pre></td></tr></table></figure></p>\n<p>运行<code>java MailTest message.txt</code>（message.txt可随意放置，如果你不知道相对路径可以写绝对路径）<br>接下来你可以查看收件箱，你就会发现收到邮件啦。</p>\n<blockquote>\n<p>参考文献<br>[1] 《Java核心技术卷二》<br>[2] <a href=\"https://blog.csdn.net/xietansheng/article/details/51673073\" target=\"_blank\" rel=\"noopener\">基于JavaMail的Java邮件发送：简单邮件发送</a><br>[3] <a href=\"https://www.cnblogs.com/xyzq/p/5704358.html\" target=\"_blank\" rel=\"noopener\">用JavaMail通过QQ邮箱来发送邮件（第一篇博客，备忘）</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>这一篇博客将介绍怎么进行Java网络编程，首先我们回顾网络的基本概念，然后进一步介绍Java socket，并演示网络客户端和服务器是如何实现的，最后将介绍如果通过Java程序发送E-mail，以及如何从Web服务器获得信息。<br>","more":"</p>\n<h3 id=\"1-Socket\"><a href=\"#1-Socket\" class=\"headerlink\" title=\"1. Socket\"></a>1. Socket</h3><h4 id=\"1-1-连接到服务器\"><a href=\"#1-1-连接到服务器\" class=\"headerlink\" title=\"1.1 连接到服务器\"></a>1.1 连接到服务器</h4><p>在Linux和windows操作系统中都预装了<code>telnet</code>工具，它对我们调试网络程序非常有帮助。<br>首先尝试下面的命令：<br><code>telnet time-A.timefreq.bldrdoc.gov 13</code><br>在你的控制台将返回下面一行类似的信息：<br><code>58203 18-03-26 15:01:27 50 0 0 631.0 UTC(NIST) *</code><br>如果你得到上面这行信息，说明你已经连接到了大多数UNIX计算机都支持的“当日时间”服务</p>\n<p><strong>socket概念</strong><br>在计算机网络课程中我们学习了ISO七层协议，其中讲述了socket是指ip地址加port端口号组成的通道，当通道连接之后我们就可以使用socket进行数据传输。</p>\n<p>下面这个程序的作用和telnet工具是一样的，即连接到某个端口并打印出它所找到的信息。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个类的作用与telnet工具是一致的，即连接到某个端口并打印出它所找到的信息</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:01</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//打开一个套接字</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"time-A.timefreq.bldrdoc.gov\"</span>, <span class=\"number\">13</span>)) &#123;</span><br><span class=\"line\">            s.setSoTimeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">            <span class=\"comment\">//一旦套接字被打开，就可以得到一个InputStream对象，使用它进行读取数据</span></span><br><span class=\"line\">            InputStream in = s.getInputStream();</span><br><span class=\"line\">            Scanner sc = <span class=\"keyword\">new</span> Scanner(in);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sc.hasNextLine())&#123;</span><br><span class=\"line\">                System.out.println(sc.nextLine());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>套接字超时</strong><br>从套接字读取信息时，在有数据可以访问之前，读操作将会被阻塞。如果此时主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制而最终会导致超时。<br>对于不同的应用，应当确定合理的超时值。调用<code>setSoTimeout</code>方法设置超时时间（单位：毫秒）。<br><code>Socket s = new SOcket(...)</code><br><code>s.setSoTimeout(10000)</code> # 设置超时时间为10秒<br>如果已经为套接字设置了超时时间，并且之后的读操作和写操作在没有完成之前就超过了时间限制，那么这些操作就会抛出<code>SocketTimeoutException</code>异常。你可以捕获这个异常，并对超时做出反应。</p>\n<p>另外还有一个超时问题是必须解决的。下面这个构造器：<br><code>Socket s = new Socket(String host, int port)</code><br>会一直无限期的阻塞下去，知道建立了到达主机的初始连接为止。<br>可以先通过建立一个无连接的套接字，然后再使用一个超时来进行连接的方法解决这个问题。<br><code>Socket s = new Socket();</code><br><code>s.connect(new InetSocketAddress(host, port), timeout);</code></p>\n<p><strong>InetAddress</strong><br>因特网地址类，使用它在主机名和因特网地址之间进行转换。<br>静态的<code>getByName(String host)</code>方法可以返回代表某个主机的InetAddress对象，使用<code>getAddress</code>返回对应的ip地址字节数组。<br>使用<code>InetAddress.getAllByName()</code>获得所有的主机。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.UnknownHostException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:11</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InetAddressTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">            InetAddress[] addresses = InetAddress.getAllByName(host);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (InetAddress a:addresses)</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            InetAddress localHostAddress = InetAddress.getLocalHost();</span><br><span class=\"line\">            System.out.println(localHostAddress);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Client-Server通信\"><a href=\"#2-Client-Server通信\" class=\"headerlink\" title=\"2. Client/Server通信\"></a>2. Client/Server通信</h3><h4 id=\"2-1-实现客户端\"><a href=\"#2-1-实现客户端\" class=\"headerlink\" title=\"2.1 实现客户端\"></a>2.1 实现客户端</h4><p>现在我们实现一个简单的服务器，它可以向客户端发送信息。<br>整个代码的大致情况：</p>\n<ol>\n<li>通过输入数据流从客户端接受一个命令</li>\n<li>解码这个客户端命令</li>\n<li>收集客户端所请求的信息</li>\n<li>通过输出数据流发送信息给客户端</li>\n</ol>\n<p>【代码清单】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(ServerSocket s = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8189</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket incoming = s.accept())&#123;</span><br><span class=\"line\">                InputStream in = incoming.getInputStream();</span><br><span class=\"line\">                OutputStream out = incoming.getOutputStream();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> (Scanner sc = <span class=\"keyword\">new</span> Scanner(in))&#123;</span><br><span class=\"line\">                    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(out, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    pw.println(<span class=\"string\">\"hello! Enter BYE to exit.\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!done &amp;&amp; sc.hasNextLine())&#123;</span><br><span class=\"line\">                        String line = sc.nextLine();</span><br><span class=\"line\">                        pw.println(<span class=\"string\">\"Echo: \"</span>+line);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (line.trim().equals(<span class=\"string\">\"BYE\"</span>))done=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行这个程序，然后使用<code>telnet</code>或再次运行之前的程序<code>SocketTest</code>连接本地<code>8189</code>端口，当你的客户端连接到这个端口后会立马接收到这条信息：<br><code>Hello! Enter BYE to exit.</code><br>之后客户端的输入便是服务器返回的数据。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jifang@jifang:~/workspace/javastudy/java/src/main/java/socket% telnet localhost 8189</span><br><span class=\"line\">Trying 127.0.0.1...</span><br><span class=\"line\">Connected to localhost.</span><br><span class=\"line\">Escape character is <span class=\"string\">'^]'</span>.</span><br><span class=\"line\">hello! Enter BYE to <span class=\"built_in\">exit</span>.</span><br><span class=\"line\">1</span><br><span class=\"line\">Echo: 1</span><br><span class=\"line\">2</span><br><span class=\"line\">Echo: 2</span><br><span class=\"line\">BYE</span><br><span class=\"line\">Echo: BYE</span><br><span class=\"line\">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-为多个客户端服务\"><a href=\"#2-2-为多个客户端服务\" class=\"headerlink\" title=\"2.2 为多个客户端服务\"></a>2.2 为多个客户端服务</h4><p>前面的例子中的简单服务器存在一个问题：服务器同一时间只能为一个客户端服务。我们访问各种网站一般都可以处理成千上万个请求，所以我们来写一个多线程的服务器。</p>\n<p>每当程序建立一个新的套接字连接，也就是说当调用accept时，将启动一个新的线程来处理服务器与客户端之间的连接，而主程序将立即返回并等待下一个连接。<br>【ThreadedEchoServer.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:35</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadedEchoServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            ServerSocket s = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8189</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Socket incoming = s.accept();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Spawning \"</span>+i);</span><br><span class=\"line\">                ThreadEchoHandler r = <span class=\"keyword\">new</span> ThreadEchoHandler(incoming);</span><br><span class=\"line\">                Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">                thread.start();</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【ThreadEchoHandler.java】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午2:30</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadEchoHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Socket incoming;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadEchoHandler</span><span class=\"params\">(Socket incoming)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.incoming = incoming;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            InputStream inStream = incoming.getInputStream();</span><br><span class=\"line\">            OutputStream outStream = incoming.getOutputStream();</span><br><span class=\"line\">            Scanner sc = <span class=\"keyword\">new</span> Scanner(inStream);</span><br><span class=\"line\">            PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(outStream,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            pw.println(<span class=\"string\">\"Hello! Enter BYE to exit.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!done &amp;&amp; sc.hasNextLine())&#123;</span><br><span class=\"line\">                String line = sc.nextLine();</span><br><span class=\"line\">                pw.println(<span class=\"string\">\"Echo: \"</span>+line);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line.trim().equals(<span class=\"string\">\"BYE\"</span>))done=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                incoming.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个程序中我们为每个连接生成一个单独的线程。这种方法并不能满足高性能服务器的要求。为使服务器实现更高的吞吐量，可以使用java.nio包中的一些特性，我们将在下一篇博客中讲述<strong>NIO</strong>。</p>\n<h3 id=\"3-URL和URLConnection\"><a href=\"#3-URL和URLConnection\" class=\"headerlink\" title=\"3. URL和URLConnection\"></a>3. URL和URLConnection</h3><p>为了更高级别的处理网络服务，我们将讨论专门用于此目的的Java类库中的各个类。</p>\n<h4 id=\"3-1-URI、URL、URN\"><a href=\"#3-1-URI、URL、URN\" class=\"headerlink\" title=\"3.1 URI、URL、URN\"></a>3.1 URI、URL、URN</h4><h4 id=\"3-2-使用URLConnection获取信息\"><a href=\"#3-2-使用URLConnection获取信息\" class=\"headerlink\" title=\"3.2 使用URLConnection获取信息\"></a>3.2 使用URLConnection获取信息</h4><p>如果想从某个Web资源获取更多的信息，那么应该使用URLConnection类，通过它能够得到比基本的URL类更多的控制功能。</p>\n<p>操作步骤：</p>\n<ol>\n<li>调用URL类中的<code>openConnection</code>方法获得URLConection对象：<br><code>URLConnection connection = url.openConnection()</code></li>\n<li>使用以下方法设置 HTTP Header属性：<br><code>setDoInput</code><br><code>SetDoOutput</code><br><code>setIfmodifiedSince</code><br><code>setUseCaches</code><br><code>setReadTimeout</code><br>…</li>\n<li>调用connect方法链接远程资源：<br><code>connection.connect()</code><br>除了与服务器建立套接字连接外，该方法还可用于向服务器查询头信息（header）</li>\n<li>与服务器建立连接后，你可以查询头信息。getHeaderFieldKey和getHeaderField两个方法枚举了消息头的所有字段。<code>getHeaderFields</code>方法返回一个包含了消息头中所有字段的标准Map对象。<br><code>getContentType</code><br><code>getContentLength</code><br><code>getContentEncoding</code><br><code>getDate</code><br>…</li>\n<li>最后，访问资源数据。使用<code>getInputStream</code>方法获取一个输入流用以读取信息。</li>\n</ol>\n<p><strong>注意：</strong> <em>默认情况下URLConnection发送一个HTTP GET请求到web服务器。如果你想发送一个HTTP POST请求，要调用URLConnection.setDoOutput(true)方法，如下：</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http://jenkov.com\"</span>);</span><br><span class=\"line\">URLConnection urlConnection = url.openConnection();</span><br><span class=\"line\">urlConnection.setDoOutput(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p><em>一旦你调用了setDoOutput(true)，你就可以打开URLConnection的OutputStream，如下：</em><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStream output = urlConnection.getOutputStream();</span><br></pre></td></tr></table></figure></p>\n<p>你可以使用这个OutputStream向相应的HTTP请求中写任何数据，但你要记得将其转换成URL编码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output.print(name1+<span class=\"string\">\"=\"</span>+URLEncoder.encode(value1,<span class=\"string\">\"UTF-8\"</span>)+<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">output.print(name2+<span class=\"string\">\"=\"</span>+URLEncoder.encode(value2,<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">output.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-发送Email\"><a href=\"#4-发送Email\" class=\"headerlink\" title=\"4. 发送Email\"></a>4. 发送Email</h3><p>过去，编写程序通过创建到SMTP专用的端口25来发送邮件是一个很简单的事。SMTP用于描述E-mail消息的格式。一旦连接到服务器，就可以发送一个邮件报头（采用SMTP格式）。</p>\n<p>操作过程：</p>\n<ol>\n<li><p>打开一个到达主机的套接字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"mail.youserver.com\"</span>,<span class=\"number\">25</span>); <span class=\"comment\">// 25 is SMTP</span></span><br><span class=\"line\">PrintWriter out = <span class=\"keyword\">new</span> PrintWriter(s.getOutputStream());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发送一下信息到输出流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELO sending host</span><br><span class=\"line\">MAIL FROM: sender e-mail address</span><br><span class=\"line\">RCPT TO: recipient e-mail address</span><br><span class=\"line\">DATA</span><br><span class=\"line\">Subject: subject</span><br><span class=\"line\">(blank line)</span><br><span class=\"line\">mail message(邮件内容)</span><br><span class=\"line\"></span><br><span class=\"line\">QUIT</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>SMTP规范规定，每一行都要以<code>\\r</code>再紧跟一个<code>\\n</code>来结尾。<br>SMTP之前总是路由任何人的e-mail，在垃圾邮件泛滥的今天，大多数服务器都内置了检查功能，并且只接收来自授信用户或IP地址范围的请求。其中，认证是通过安全套接字连接来实现的，非常冗长乏味。所以我们使用JavaMailAPI在Java程序中发送email。</p>\n<p>这里以QQ邮箱来演示如何用JavaMail发送一封邮件</p>\n<h4 id=\"4-1-先启用QQ邮箱里POP3-STMP服务，生成授权码\"><a href=\"#4-1-先启用QQ邮箱里POP3-STMP服务，生成授权码\" class=\"headerlink\" title=\"4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码\"></a>4.1 先启用QQ邮箱里POP3/STMP服务，生成授权码</h4><p>QQ邮箱–&gt;账户–&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务–&gt;开启POP3/SMTP服务<br>发送短信验证通过之后可以看到授权码<br><img src=\"https://app.yinxiang.com/shard/s15/res/a836d720-dcca-42c8-86b1-d21ea60395bc/1522074780596.png\" alt=\"Alt text\"><br><img src=\"https://app.yinxiang.com/shard/s15/res/e5374a0f-acba-41e0-9aa8-cd2a6ccbdd3c/1522074797444.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-2-导入JavaMail-jar包\"><a href=\"#4-2-导入JavaMail-jar包\" class=\"headerlink\" title=\"4.2 导入JavaMail jar包\"></a>4.2 导入JavaMail jar包</h4><p>我使用的maven进行jar包管理<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.mail<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mail<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://app.yinxiang.com/shard/s15/res/d2fa064e-d387-427b-b21d-e04b2cc25c83/1522074945736.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-代码实现\"><a href=\"#4-3-代码实现\" class=\"headerlink\" title=\"4.3 代码实现\"></a>4.3 代码实现</h4><p>【MailTest】<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.MessagingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Session;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.Transport;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.internet.InternetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.mail.internet.MimeMessage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.Charset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Files;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.Paths;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.GeneralSecurityException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * author: jifang</span></span><br><span class=\"line\"><span class=\"comment\"> * date: 18-3-26 下午5:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, MessagingException </span>&#123;</span><br><span class=\"line\">        Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream in = Files.newInputStream(Paths.get(<span class=\"string\">\"src/main/java/socket\"</span>,<span class=\"string\">\"mail.properties\"</span>)))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 创建参数配置, 用于连接邮件服务器的参数配置</span></span><br><span class=\"line\">            props.load(in);</span><br><span class=\"line\">            <span class=\"comment\">// PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启),</span></span><br><span class=\"line\">            <span class=\"comment\">//     如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误,</span></span><br><span class=\"line\">            <span class=\"comment\">//     打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。</span></span><br><span class=\"line\">            <span class=\"comment\">// SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接,</span></span><br><span class=\"line\">            <span class=\"comment\">//                  需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助,</span></span><br><span class=\"line\">            <span class=\"comment\">//                  QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看)</span></span><br><span class=\"line\">            <span class=\"comment\">/*MailSSLSocketFactory sf = new MailSSLSocketFactory();</span></span><br><span class=\"line\"><span class=\"comment\">            sf.setTrustAllHosts(true);</span></span><br><span class=\"line\"><span class=\"comment\">            props.put(\"mail.smtp.ssl.enable\", \"true\");</span></span><br><span class=\"line\"><span class=\"comment\">            props.put(\"mail.smtp.ssl.socketFactory\", sf);*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(args[<span class=\"number\">0</span>]), Charset.forName(<span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        String from = lines.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        String to = lines.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        String subject = lines.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">        StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">3</span>;i&lt;lines.size();i++)&#123;</span><br><span class=\"line\">            builder.append(lines.get(i)+<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 根据配置创建会话对象, 用于和邮件服务器交互</span></span><br><span class=\"line\">        Session mailSession = Session.getDefaultInstance(props);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 创建一封邮件</span></span><br><span class=\"line\">        MimeMessage message = <span class=\"keyword\">new</span> MimeMessage(mailSession);</span><br><span class=\"line\">        <span class=\"comment\">// 发件人</span></span><br><span class=\"line\">        message.setFrom(<span class=\"keyword\">new</span> InternetAddress(from, <span class=\"string\">\"jifang\"</span>, <span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 收件人（可以增加多个收件人(RecipientType.To)、抄送(RecipientType.CC)、密送(RecipientType.BCC)）</span></span><br><span class=\"line\">        message.addRecipient(Message.RecipientType.TO, <span class=\"keyword\">new</span> InternetAddress(to,<span class=\"string\">\"jifang\"</span>,<span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//主题</span></span><br><span class=\"line\">        message.setSubject(subject);</span><br><span class=\"line\">        <span class=\"comment\">//邮件内容</span></span><br><span class=\"line\">        message.setText(builder.toString());</span><br><span class=\"line\">        <span class=\"comment\">// 4. 根据 Session 获取邮件传输对象</span></span><br><span class=\"line\">        Transport tr = mailSession.getTransport();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log,</span></span><br><span class=\"line\">            <span class=\"comment\">//           仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误</span></span><br><span class=\"line\">            <span class=\"comment\">//           类型到对应邮件服务器的帮助网站上查看具体失败原因。</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_02: 连接失败的原因通常为以下几点, 仔细检查代码:</span></span><br><span class=\"line\">            <span class=\"comment\">//           (1) 邮箱没有开启 SMTP 服务;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (2) 邮箱密码错误, 例如某些邮箱开启了独立密码;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (3) 邮箱服务器要求必须要使用 SSL 安全连接;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务;</span></span><br><span class=\"line\">            <span class=\"comment\">//           (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。</span></span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"comment\">//    PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。</span></span><br><span class=\"line\">            tr.connect(<span class=\"string\">\"smtp.qq.com\"</span>,<span class=\"string\">\"1579461369\"</span>,<span class=\"string\">\"pjyfztifsbcthbad\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class=\"line\">            tr.sendMessage(message,message.getAllRecipients());</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 7. 关闭连接</span></span><br><span class=\"line\">            tr.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>【mail.properties】<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mail.transport.protocol=smtps</span><br><span class=\"line\">mail.smtps.auth=true</span><br><span class=\"line\"># 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com</span><br><span class=\"line\"># QQ邮箱的 SMTP 服务器地址为: smtp.qq.com</span><br><span class=\"line\">mail.smtps.host=smtp.qq.com</span><br></pre></td></tr></table></figure></p>\n<p>【message.txt】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx@qq.com</span><br><span class=\"line\">yyy@qq.com</span><br><span class=\"line\">测试</span><br><span class=\"line\">你已经收到了邮件！</span><br></pre></td></tr></table></figure></p>\n<p>运行<code>java MailTest message.txt</code>（message.txt可随意放置，如果你不知道相对路径可以写绝对路径）<br>接下来你可以查看收件箱，你就会发现收到邮件啦。</p>\n<blockquote>\n<p>参考文献<br>[1] 《Java核心技术卷二》<br>[2] <a href=\"https://blog.csdn.net/xietansheng/article/details/51673073\" target=\"_blank\" rel=\"noopener\">基于JavaMail的Java邮件发送：简单邮件发送</a><br>[3] <a href=\"https://www.cnblogs.com/xyzq/p/5704358.html\" target=\"_blank\" rel=\"noopener\">用JavaMail通过QQ邮箱来发送邮件（第一篇博客，备忘）</a></p>\n</blockquote>"},{"toc":true,"title":"maven入门","comments":1,"date":"2017-10-23T02:56:10.000Z","_content":"\n今天整理一下对于Maven的学习。和学习其他知识一样，我在看完各种关于Maven的介绍以及文档之后，按照what，how，why来温习。\n<!--more-->\n### 1. What（Maven是什么？）\nMaven是一个强大的Java项目构建工具，构建工具：将软件项目构建相关的过程自动化的工具。\n\n构建一个软件项目通常包含以下一个或多个过程：\n- 生成源码（如果项目使用自动生成源码）；\n- 从源码生成项目文档；\n- 编译源码；\n- 将编译后的源码打包成JAR文件或者ZIP文件；\n- 将打包好的代码安装到服务器、仓库或者其他的地方；\n\n##### 安装Maven\n[【项目管理和构建】——Maven下载、安装和配置（二）](http://blog.csdn.net/jiuqiyuliang/article/details/45390313)\n\n##### Maven概览-核心概念\nMaven的中心思想是**POM文件**（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。\n\n下图说明了Maven是如何使用POM文件的，以及POM文件的主要组成部分：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-overview-1.png)\n\n##### 构建生命周期、构建阶段、构建目标\nMaven的构建过程被分解为构建生命周期、阶段和目标。一个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的构建目标组成。当你运行Maven的时候，你会传入一条命令。这条命令就是构建生命周期、阶段或目标的名字。如果执行一个生命周期，该生命周期内的所有构建阶段都会被执行。如果执行一个构建阶段，在预定义的构建阶段中，所有处于当前构建阶段之前的阶段也都会被执行。  \n\n##### 依赖和仓库\nMaven执行时，其中一个首要目标就是检查项目的依赖。依赖是你的项目用到的jar文件（java库）。如果在本地仓库中不存在该依赖，则Maven会从中央仓库下载并放到本地仓库。本地仓库只是你电脑硬盘上的一个目录。你可以根据需要制定本地仓库的位置。你也可以指定下载依赖的远程仓库的地址。\n\n##### 插件\n构建插件可以向构建阶段中增加额外的构建目标。如果Maven标准的构建阶段和目标无法满足项目构建的需求，你可以在POM文件里增加插件。Maven有一些标准的插件供选用，如果需要你可以自己实现插件。\n\n##### 配置文件\n*不同的开发环境会使用不同的配置*\n配置文件用于以不同的方式构建项目。比如，你可能需要在本地环境构建，用于开发和测试，你也可能需要构建后用于开发环境。这两个构建过程是不同的。在POM文件中增加不同的构建配置，可以启用不同的构建过程。当运行Maven时，可以指定要使用的配置。\n\n##### 父pom\n所有的Maven pom文件都继承自一个父pom。如果没有指定父pom，则该pom文件继承自根pom。pom文件的继承关系如下图所示：\n![](http://ifeve.com/wp-content/uploads/2014/06/super-pom.png)\n可以让一个pom文件显式地继承另一个pom文件。这样，可以通过修改公共父pom文件的设置来修改所有子pom文件的设置。在pom文件的起始处指定父pom，例如：\n```xml\n<project xmlns=”http://maven.apache.org/POM/4.0.0″\nxmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”\nxsi:schemaLocation=”http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/xsd/maven-4.0.0.xsd”>\n<modelVersion>4.0.0</modelVersion>\n\n<parent>\n<groupId>org.codehaus.mojo</groupId>\n<artifactId>my-parent</artifactId>\n<version>2.0</version>\n<relativePath>../my-parent</relativePath>\n</parent>\n\n<artifactId>my-project</artifactId>\n…\n</project>\n```\n子pom文件的设置可以覆盖父pom文件的设置，只需要在子pom文件里指定新的设置即可。\n\n##### Maven配置文件\nMaven配置文件\n\nMaven有两个配置文件。配置文件里的设置，对所有的pom文件都是有效的。比如，你可以配置：\n\n本地仓库的路径；\n当前的编译配置选项\n等等\n配置文件名为settings.xml，两个配置文件分别为：\n\n+ Maven安装目录中：$M2_HOME/conf/settings.xml\n+ 用户主目录中：${user.home}/.m2/settings.xml\n\n两个配置文件都是可选的。如果两个文件都存在，则用户目录下的配置会覆盖Maven安装目录中的配置。\n\n##### Maven运行\n[maven常用命令行及解释](http://blog.csdn.net/phantomes/article/details/8110779)\n\n### 2. How(Maven具体使用)\n##### Maven安装目录\n四个文件夹：\nbin：包含mvn运行的脚本,m2.conf配置文件\nboot：boot目录包含一个类加载器的框架\nconf：是配置文件目录\nlib：类库\n\n##### Maven目录结构\nMaven有一个标准的目录结构。如果你在项目中遵循Maven的目录结构，就无需在pom文件中指定源代码、测试代码等目录。\n以下为最重要的目录：\n```xml\n- src\n  - main\n    - java\n    - resources\n    - webapp\n  - test\n    - java\n    - resources\n\n- target\n```\n[Maven标准目录结构介绍](http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)\nsrc目录是源代码和测试代码的根目录。main目录是应用的源代码目录。test目录是测试代码的目录。main和test下的java目录，分别表示应用的java源代码和测试代码。\n\nresources目录包含项目的资源文件，比如应用的国际化配置的属性文件等。\n\n如果是一个web项目，则webapp目录为web项目的根目录，其中包含如WEB-INF等子目录。\n\ntarget目录是由Maven创建的，其中包含编译后的类文件、jar文件等。当执行maven的clean目标后，target目录会被清空。\n\n##### POM文件\n[《Maven官方文档》POM文件](http://ifeve.com/maven-pom/)\n[Maven之（七）pom.xml配置文件详解](http://blog.csdn.net/u012152619/article/details/51485297)\n\n##### 外部依赖\nMaven的外部依赖指的是不在Maven的仓库（包括本地仓库、中央仓库和远程仓库）中的依赖（jar包）。它可能位于你本地硬盘的某个地方，比如web应用的lib目录下。这里的“外部”是对Maven仓库系统而言的，不仅仅是对项目而言的。大部分的外部依赖都是针对项目的，很少的外部依赖是针对仓库系统的（即不在仓库中）。\n\n配置外部依赖的示例如下：\n<pre><code>\n&lt;dependency&gt;\n  &lt;groupId&gt;mydependency&lt;/groupId&gt;\n  &lt;artifactId&gt;mydependency&lt;/artifactId&gt;\n  &lt;scope&gt;system&lt;/scope&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;systemPath&gt;${basedir}\\war\\WEB-INF\\lib\\mydependency.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n </code></pre>\ngroupId和artifactId为依赖的名称，即API的名称。scope属性为system。systemPath属性为jar文件的路径。${basedir}为pom文件所在的目录，路径中的其它部分是相对于该目录而言的。\n\n##### 快照依赖\n快照依赖指的是那些还在开发中的依赖（jar包）。与其经常地更新版本号来获取最新版本，不如你直接依赖项目的快照版本。快照版本的每一个build版本都会被下载到本地仓库，即使该快照版本已经在本地仓库了。总是下载快照依赖可以确保本地仓库中的每一个build版本都是最新的。\n\n在pom文件的最开头（设置groupId和artifactId的地方），在版本号后追加-SNAPSHOT，则告诉Maven你的项目是一个快照版本。如：\n<pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    </code></pre>\n可以看到加到版本号后的-SNAPSHOT。\n\n在配置依赖时，在版本号后追加-SNAPSHOT表明依赖的是一个快照版本。如：\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.jenkov&lt;/groupId&gt;\n    &lt;artifactId&gt;java-web-crawler&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n追加在version后的-SNAPSHOT告诉Maven这是一个快照版本。\n\n可以在Maven配置文件中设置快照版本下载的频率。\n\n##### Maven仓库\nMaven仓库就是存储jar包和一些元数据信息的目录。其中的元数据即pom文件，描述了该jar包属于哪个项目，以及jar包所需的外部依赖。该元数据信息使得Maven可以递归地下载所有的依赖，直到整个依赖树都下载完毕并放到你的本地仓库中。\nMaven有三种类型的仓库：\n\n本地仓库\n中央仓库\n远程仓库\nMaven根据以上的顺序去仓库中搜索依赖。首先是本地仓库，然后是中央仓库，最后，如果pom文件中配置了远程仓库，则会去远程仓库中查找。\n\n下图说明了三种仓库的类型以及位置：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-repo-types-loc-300x185.png)\n本地仓库\n\n本地仓库就是开发者电脑上的一个目录。该仓库包含了Maven下载的所有依赖。一般来讲，一个本地仓库为多个不同的项目服务。因此，Maven只需下载一次，即使有多个项目都依赖它（如junit）。\n\n通过mvn install命令可以将你自己的项目构建并安装到本地仓库中。这样，你的其它项目就可以通过在pom文件将该jar包作为外部依赖来使用。\n\nMaven的本地仓库默认在你本机的用户目录下。不过，你可以在Maven的配置文件中修改本地仓库的路径。Maven的配置文件也在用户目录下(user-home/.m2)，文件名为settings.xml。以下示例为本地仓库指定其它的路径：\n<pre><code>&lt;settings&gt;\n    &lt;localRepository&gt;\n        d:\\data\\java\\products\\maven\\repository\n    &lt;/localRepository&gt;\n&lt;/settings&gt;</code></pre>\n##### 中央仓库\n\nMaven的中央仓库由Maven社区提供。默认情况下，所有不在本地仓库中的依赖都会去这个中央仓库查找。然后Maven会将这些依赖下载到你的本地仓库。访问中央仓库不需要做额外的配置。\n\n##### 远程仓库\n\n远程仓库是位于web服务器上的一个仓库，Maven可以从该仓库下载依赖，就像从中央仓库下载依赖一样。远程仓库可以位于Internet上的任何地方，也可以是位于本地网络中。\n\n远程仓库一般用于放置组织内部的项目，该项目由多个项目共享。比如，由多个内部项目共用的安全项目。该安全项目不能被外部访问，因此不能放在公开的中央仓库下，而应该放到内部的远程仓库中。\n\n远程仓库中的依赖也会被Maven下载到本地仓库中。\n\n可以在pom文件里配置远程仓库。将以下的xml片段放到属性之后：\n<pre><code>&lt;repositories&gt;\n   &lt;repository&gt;\n       &lt;id&gt;jenkov.code&lt;/id&gt;\n       &lt;url&gt;http://maven.jenkov.com/maven2/lib&lt;/url&gt;\n   &lt;/repository&gt;\n&lt;/repositories&gt;</code></pre>\n\n##### 生命周期\n一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven的生命周期是抽象的，其中的具体任务都交由插件来完成。Maven为大多数构建任务编写并绑定了默认的插件，如针对编译的插件：maven-compiler-plugin。用户也可自行配置或编写插件。\n**1. 三套生命周期**\nMaven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。\n**1.1 clean生命周期**\n1.\tpre-clean    ：执行清理前的工作；\n2.\tclean    ：清理上一次构建生成的所有文件；\n3.\tpost-clean    ：执行清理后的工作\n\n**1.2 default生命周期**\ndefault生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。\n<ol>\n<li>validate</li>\n<li>initialize</li>\n<li>generate-sources</li>\n<li>process-sources</li>\n<li>generate-resources</li>\n<li>process-resources &nbsp; &nbsp;：复制和处理资源文件到target目录，准备打包；</li>\n<li>compile &nbsp; &nbsp;：编译项目的源代码；</li>\n<li>process-classes</li>\n<li>generate-test-sources</li>\n<li>process-test-sources</li>\n<li>generate-test-resources</li>\n<li>process-test-resources</li>\n<li>test-compile &nbsp; &nbsp;：编译测试源代码；</li>\n<li>process-test-classes</li>\n<li>test &nbsp; &nbsp;：运行测试代码；</li>\n<li>prepare-package</li>\n<li>package &nbsp; &nbsp;：打包成jar或者war或者其他格式的分发包；</li>\n<li>pre-integration-test</li>\n<li>integration-test</li>\n<li>post-integration-test</li>\n<li>verify</li>\n<li>install &nbsp; &nbsp;：将打好的包安装到本地仓库，供其他项目使用；</li>\n<li>deploy &nbsp; &nbsp;：将打好的包安装到远程仓库，供其他项目使用；</li>\n</ol>\n**1.3 site生命周期**\n<ol>\n<li>pre-site</li>\n<li>site &nbsp; &nbsp;：生成项目的站点文档；</li>\n<li>post-site</li>\n<li>site-deploy &nbsp; &nbsp;：发布生成的站点文档</li>\n</ol>\n\n##### 插件\nMaven的核心文件很小，主要的任务都是由插件来完成。定位到：%本地仓库%\\org\\apache\\maven\\plugins，可以看到一些下载好的插件：\n![](http://images.cnitblog.com/i/293735/201407/012038215279940.png)\n具体参考的这篇文章，写作风格真棒，很漂亮的排版。\n[Maven入门指南⑦：Maven的生命周期和插件](http://www.cnblogs.com/luotaoyeah/p/3819001.html)\n\n##### maven 命令\n\n> 编译源代码：mvn compile\n> 编译测试代码：mvn test-compile\n> 运行测试：mvn test (会运行前面的三个命令)\n> 打包：mvn package\n> 部署到本地：mvn install \n> 在远程部署jar：mvn deploy\n> 清除产生的项目：mvn clean\n> 窥探SuperPom：mvn help:effective-pom\n> maven依赖树：mvn dependency:tree\n> 打包的时候过滤test：mvn clean package -Pdev -Dmaven.test.skip=true\n\n##### maven的生命周期\n- 构建生命周期\n\t- clean\n\t\t- Pre-clean 做移除准备\n\t\t- Clean 移除jar\n\t\t- Post-clean 移除target\n\t- default（项目构建真正需要执行的所有步骤：23个阶段，执行某个执行阶段前的阶段都会被执行，避免重复工作）\t\t\n\t\t- pre-resource\n\t\t- compile\n\t\t- test-compile\n\t\t- test\n\t\t- package\n\t\t- install\n\t\t- deploy \n\t- site （项目所有的资源文件放在一个站点服务器上，用户可以通过站点访问我们的api文档等）\n\t\t- Pre-site\n\t\t- Site\n\t\t- Post-site\n\t\t- Site-deploy\n\t\n##### shapshot和release版本\nsnapshot 快照版会经常更新，maven会实时下载\nrelease 稳定版\n防止版本号的滥用，以及及时的协作更新\n\n##### 依赖\ntype:\nscope:\noptional:\nexclusions:\n依赖特性：依赖传递、\n依赖冲突：路径优先、声明优先\n依赖排除：dependencymanagement、execlusion\n\n##### maven的聚合与继承\n聚合：使用一个命令同时构建多个模块\n< modules > < package >pom< >\n继承： 子模块可以使用父模块的依赖\n\n##### maven测试\n快捷键？？？\n\n\n\n---\n\n### 3. WHY（为什么要使用maven）\n首先，为什么有maven？构建是程序员每天要做的工作，而且相当长的时间花在了这上面，而maven使这系列的工作完全自动化。 我们一直在寻找避免重复的方法，设计的重复，文档的重复，编码的重复，构建的重复等，maven是跨平台的，最大的消除了构建的重复。\n\nmaven的其他优势：\n1.  maven不仅是构建工具，它还是依赖管理工具和项目管理工具，提供了中央仓库，能够帮我们自动下载构件。\n2.  为了解决的依赖的增多，版本不一致，版本冲突，依赖臃肿等问题，它通过一个坐标系统来精确地定位每一个构件（artifact）。\n3.  还能帮助我们分散在各个角落的项目信息，包括项目描述，开发者列表，版本控制系统，许可证，缺陷管理系统地址。\n4.  maven还为全世界的java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源软件。通过衍生工具(Nexus),我们还能对其进行快速搜索\n5.  maven对于目录结构有要求，约定优于配置，用户在项目间切换就省去了学习成本。\n\nMaven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。\n\n在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。\n\n> **参考文献：**\n> http://www.cnblogs.com/luotaoyeah/p/3819001.html Maven入门指南⑦：Maven的生命周期和插件\n> http://ifeve.com/maven-1/ Maven入门指南（一）\n> http://ifeve.com/maven-2/ Maven入门指南（二）\n> http://blog.csdn.net/nancy_feng/article/details/38148625 maven学习-----maven的优势\n\n\n\n\n\n\n","source":"_posts/Maven初探.md","raw":"---\ntoc: true\ntitle: maven入门\ncomments: true\ndate: 2017-10-23 10:56:10\ntags: maven\n---\n\n今天整理一下对于Maven的学习。和学习其他知识一样，我在看完各种关于Maven的介绍以及文档之后，按照what，how，why来温习。\n<!--more-->\n### 1. What（Maven是什么？）\nMaven是一个强大的Java项目构建工具，构建工具：将软件项目构建相关的过程自动化的工具。\n\n构建一个软件项目通常包含以下一个或多个过程：\n- 生成源码（如果项目使用自动生成源码）；\n- 从源码生成项目文档；\n- 编译源码；\n- 将编译后的源码打包成JAR文件或者ZIP文件；\n- 将打包好的代码安装到服务器、仓库或者其他的地方；\n\n##### 安装Maven\n[【项目管理和构建】——Maven下载、安装和配置（二）](http://blog.csdn.net/jiuqiyuliang/article/details/45390313)\n\n##### Maven概览-核心概念\nMaven的中心思想是**POM文件**（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。\n\n下图说明了Maven是如何使用POM文件的，以及POM文件的主要组成部分：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-overview-1.png)\n\n##### 构建生命周期、构建阶段、构建目标\nMaven的构建过程被分解为构建生命周期、阶段和目标。一个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的构建目标组成。当你运行Maven的时候，你会传入一条命令。这条命令就是构建生命周期、阶段或目标的名字。如果执行一个生命周期，该生命周期内的所有构建阶段都会被执行。如果执行一个构建阶段，在预定义的构建阶段中，所有处于当前构建阶段之前的阶段也都会被执行。  \n\n##### 依赖和仓库\nMaven执行时，其中一个首要目标就是检查项目的依赖。依赖是你的项目用到的jar文件（java库）。如果在本地仓库中不存在该依赖，则Maven会从中央仓库下载并放到本地仓库。本地仓库只是你电脑硬盘上的一个目录。你可以根据需要制定本地仓库的位置。你也可以指定下载依赖的远程仓库的地址。\n\n##### 插件\n构建插件可以向构建阶段中增加额外的构建目标。如果Maven标准的构建阶段和目标无法满足项目构建的需求，你可以在POM文件里增加插件。Maven有一些标准的插件供选用，如果需要你可以自己实现插件。\n\n##### 配置文件\n*不同的开发环境会使用不同的配置*\n配置文件用于以不同的方式构建项目。比如，你可能需要在本地环境构建，用于开发和测试，你也可能需要构建后用于开发环境。这两个构建过程是不同的。在POM文件中增加不同的构建配置，可以启用不同的构建过程。当运行Maven时，可以指定要使用的配置。\n\n##### 父pom\n所有的Maven pom文件都继承自一个父pom。如果没有指定父pom，则该pom文件继承自根pom。pom文件的继承关系如下图所示：\n![](http://ifeve.com/wp-content/uploads/2014/06/super-pom.png)\n可以让一个pom文件显式地继承另一个pom文件。这样，可以通过修改公共父pom文件的设置来修改所有子pom文件的设置。在pom文件的起始处指定父pom，例如：\n```xml\n<project xmlns=”http://maven.apache.org/POM/4.0.0″\nxmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”\nxsi:schemaLocation=”http://maven.apache.org/POM/4.0.0\nhttp://maven.apache.org/xsd/maven-4.0.0.xsd”>\n<modelVersion>4.0.0</modelVersion>\n\n<parent>\n<groupId>org.codehaus.mojo</groupId>\n<artifactId>my-parent</artifactId>\n<version>2.0</version>\n<relativePath>../my-parent</relativePath>\n</parent>\n\n<artifactId>my-project</artifactId>\n…\n</project>\n```\n子pom文件的设置可以覆盖父pom文件的设置，只需要在子pom文件里指定新的设置即可。\n\n##### Maven配置文件\nMaven配置文件\n\nMaven有两个配置文件。配置文件里的设置，对所有的pom文件都是有效的。比如，你可以配置：\n\n本地仓库的路径；\n当前的编译配置选项\n等等\n配置文件名为settings.xml，两个配置文件分别为：\n\n+ Maven安装目录中：$M2_HOME/conf/settings.xml\n+ 用户主目录中：${user.home}/.m2/settings.xml\n\n两个配置文件都是可选的。如果两个文件都存在，则用户目录下的配置会覆盖Maven安装目录中的配置。\n\n##### Maven运行\n[maven常用命令行及解释](http://blog.csdn.net/phantomes/article/details/8110779)\n\n### 2. How(Maven具体使用)\n##### Maven安装目录\n四个文件夹：\nbin：包含mvn运行的脚本,m2.conf配置文件\nboot：boot目录包含一个类加载器的框架\nconf：是配置文件目录\nlib：类库\n\n##### Maven目录结构\nMaven有一个标准的目录结构。如果你在项目中遵循Maven的目录结构，就无需在pom文件中指定源代码、测试代码等目录。\n以下为最重要的目录：\n```xml\n- src\n  - main\n    - java\n    - resources\n    - webapp\n  - test\n    - java\n    - resources\n\n- target\n```\n[Maven标准目录结构介绍](http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)\nsrc目录是源代码和测试代码的根目录。main目录是应用的源代码目录。test目录是测试代码的目录。main和test下的java目录，分别表示应用的java源代码和测试代码。\n\nresources目录包含项目的资源文件，比如应用的国际化配置的属性文件等。\n\n如果是一个web项目，则webapp目录为web项目的根目录，其中包含如WEB-INF等子目录。\n\ntarget目录是由Maven创建的，其中包含编译后的类文件、jar文件等。当执行maven的clean目标后，target目录会被清空。\n\n##### POM文件\n[《Maven官方文档》POM文件](http://ifeve.com/maven-pom/)\n[Maven之（七）pom.xml配置文件详解](http://blog.csdn.net/u012152619/article/details/51485297)\n\n##### 外部依赖\nMaven的外部依赖指的是不在Maven的仓库（包括本地仓库、中央仓库和远程仓库）中的依赖（jar包）。它可能位于你本地硬盘的某个地方，比如web应用的lib目录下。这里的“外部”是对Maven仓库系统而言的，不仅仅是对项目而言的。大部分的外部依赖都是针对项目的，很少的外部依赖是针对仓库系统的（即不在仓库中）。\n\n配置外部依赖的示例如下：\n<pre><code>\n&lt;dependency&gt;\n  &lt;groupId&gt;mydependency&lt;/groupId&gt;\n  &lt;artifactId&gt;mydependency&lt;/artifactId&gt;\n  &lt;scope&gt;system&lt;/scope&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;systemPath&gt;${basedir}\\war\\WEB-INF\\lib\\mydependency.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n </code></pre>\ngroupId和artifactId为依赖的名称，即API的名称。scope属性为system。systemPath属性为jar文件的路径。${basedir}为pom文件所在的目录，路径中的其它部分是相对于该目录而言的。\n\n##### 快照依赖\n快照依赖指的是那些还在开发中的依赖（jar包）。与其经常地更新版本号来获取最新版本，不如你直接依赖项目的快照版本。快照版本的每一个build版本都会被下载到本地仓库，即使该快照版本已经在本地仓库了。总是下载快照依赖可以确保本地仓库中的每一个build版本都是最新的。\n\n在pom文件的最开头（设置groupId和artifactId的地方），在版本号后追加-SNAPSHOT，则告诉Maven你的项目是一个快照版本。如：\n<pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    </code></pre>\n可以看到加到版本号后的-SNAPSHOT。\n\n在配置依赖时，在版本号后追加-SNAPSHOT表明依赖的是一个快照版本。如：\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.jenkov&lt;/groupId&gt;\n    &lt;artifactId&gt;java-web-crawler&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n追加在version后的-SNAPSHOT告诉Maven这是一个快照版本。\n\n可以在Maven配置文件中设置快照版本下载的频率。\n\n##### Maven仓库\nMaven仓库就是存储jar包和一些元数据信息的目录。其中的元数据即pom文件，描述了该jar包属于哪个项目，以及jar包所需的外部依赖。该元数据信息使得Maven可以递归地下载所有的依赖，直到整个依赖树都下载完毕并放到你的本地仓库中。\nMaven有三种类型的仓库：\n\n本地仓库\n中央仓库\n远程仓库\nMaven根据以上的顺序去仓库中搜索依赖。首先是本地仓库，然后是中央仓库，最后，如果pom文件中配置了远程仓库，则会去远程仓库中查找。\n\n下图说明了三种仓库的类型以及位置：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-repo-types-loc-300x185.png)\n本地仓库\n\n本地仓库就是开发者电脑上的一个目录。该仓库包含了Maven下载的所有依赖。一般来讲，一个本地仓库为多个不同的项目服务。因此，Maven只需下载一次，即使有多个项目都依赖它（如junit）。\n\n通过mvn install命令可以将你自己的项目构建并安装到本地仓库中。这样，你的其它项目就可以通过在pom文件将该jar包作为外部依赖来使用。\n\nMaven的本地仓库默认在你本机的用户目录下。不过，你可以在Maven的配置文件中修改本地仓库的路径。Maven的配置文件也在用户目录下(user-home/.m2)，文件名为settings.xml。以下示例为本地仓库指定其它的路径：\n<pre><code>&lt;settings&gt;\n    &lt;localRepository&gt;\n        d:\\data\\java\\products\\maven\\repository\n    &lt;/localRepository&gt;\n&lt;/settings&gt;</code></pre>\n##### 中央仓库\n\nMaven的中央仓库由Maven社区提供。默认情况下，所有不在本地仓库中的依赖都会去这个中央仓库查找。然后Maven会将这些依赖下载到你的本地仓库。访问中央仓库不需要做额外的配置。\n\n##### 远程仓库\n\n远程仓库是位于web服务器上的一个仓库，Maven可以从该仓库下载依赖，就像从中央仓库下载依赖一样。远程仓库可以位于Internet上的任何地方，也可以是位于本地网络中。\n\n远程仓库一般用于放置组织内部的项目，该项目由多个项目共享。比如，由多个内部项目共用的安全项目。该安全项目不能被外部访问，因此不能放在公开的中央仓库下，而应该放到内部的远程仓库中。\n\n远程仓库中的依赖也会被Maven下载到本地仓库中。\n\n可以在pom文件里配置远程仓库。将以下的xml片段放到属性之后：\n<pre><code>&lt;repositories&gt;\n   &lt;repository&gt;\n       &lt;id&gt;jenkov.code&lt;/id&gt;\n       &lt;url&gt;http://maven.jenkov.com/maven2/lib&lt;/url&gt;\n   &lt;/repository&gt;\n&lt;/repositories&gt;</code></pre>\n\n##### 生命周期\n一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven的生命周期是抽象的，其中的具体任务都交由插件来完成。Maven为大多数构建任务编写并绑定了默认的插件，如针对编译的插件：maven-compiler-plugin。用户也可自行配置或编写插件。\n**1. 三套生命周期**\nMaven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。\n**1.1 clean生命周期**\n1.\tpre-clean    ：执行清理前的工作；\n2.\tclean    ：清理上一次构建生成的所有文件；\n3.\tpost-clean    ：执行清理后的工作\n\n**1.2 default生命周期**\ndefault生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。\n<ol>\n<li>validate</li>\n<li>initialize</li>\n<li>generate-sources</li>\n<li>process-sources</li>\n<li>generate-resources</li>\n<li>process-resources &nbsp; &nbsp;：复制和处理资源文件到target目录，准备打包；</li>\n<li>compile &nbsp; &nbsp;：编译项目的源代码；</li>\n<li>process-classes</li>\n<li>generate-test-sources</li>\n<li>process-test-sources</li>\n<li>generate-test-resources</li>\n<li>process-test-resources</li>\n<li>test-compile &nbsp; &nbsp;：编译测试源代码；</li>\n<li>process-test-classes</li>\n<li>test &nbsp; &nbsp;：运行测试代码；</li>\n<li>prepare-package</li>\n<li>package &nbsp; &nbsp;：打包成jar或者war或者其他格式的分发包；</li>\n<li>pre-integration-test</li>\n<li>integration-test</li>\n<li>post-integration-test</li>\n<li>verify</li>\n<li>install &nbsp; &nbsp;：将打好的包安装到本地仓库，供其他项目使用；</li>\n<li>deploy &nbsp; &nbsp;：将打好的包安装到远程仓库，供其他项目使用；</li>\n</ol>\n**1.3 site生命周期**\n<ol>\n<li>pre-site</li>\n<li>site &nbsp; &nbsp;：生成项目的站点文档；</li>\n<li>post-site</li>\n<li>site-deploy &nbsp; &nbsp;：发布生成的站点文档</li>\n</ol>\n\n##### 插件\nMaven的核心文件很小，主要的任务都是由插件来完成。定位到：%本地仓库%\\org\\apache\\maven\\plugins，可以看到一些下载好的插件：\n![](http://images.cnitblog.com/i/293735/201407/012038215279940.png)\n具体参考的这篇文章，写作风格真棒，很漂亮的排版。\n[Maven入门指南⑦：Maven的生命周期和插件](http://www.cnblogs.com/luotaoyeah/p/3819001.html)\n\n##### maven 命令\n\n> 编译源代码：mvn compile\n> 编译测试代码：mvn test-compile\n> 运行测试：mvn test (会运行前面的三个命令)\n> 打包：mvn package\n> 部署到本地：mvn install \n> 在远程部署jar：mvn deploy\n> 清除产生的项目：mvn clean\n> 窥探SuperPom：mvn help:effective-pom\n> maven依赖树：mvn dependency:tree\n> 打包的时候过滤test：mvn clean package -Pdev -Dmaven.test.skip=true\n\n##### maven的生命周期\n- 构建生命周期\n\t- clean\n\t\t- Pre-clean 做移除准备\n\t\t- Clean 移除jar\n\t\t- Post-clean 移除target\n\t- default（项目构建真正需要执行的所有步骤：23个阶段，执行某个执行阶段前的阶段都会被执行，避免重复工作）\t\t\n\t\t- pre-resource\n\t\t- compile\n\t\t- test-compile\n\t\t- test\n\t\t- package\n\t\t- install\n\t\t- deploy \n\t- site （项目所有的资源文件放在一个站点服务器上，用户可以通过站点访问我们的api文档等）\n\t\t- Pre-site\n\t\t- Site\n\t\t- Post-site\n\t\t- Site-deploy\n\t\n##### shapshot和release版本\nsnapshot 快照版会经常更新，maven会实时下载\nrelease 稳定版\n防止版本号的滥用，以及及时的协作更新\n\n##### 依赖\ntype:\nscope:\noptional:\nexclusions:\n依赖特性：依赖传递、\n依赖冲突：路径优先、声明优先\n依赖排除：dependencymanagement、execlusion\n\n##### maven的聚合与继承\n聚合：使用一个命令同时构建多个模块\n< modules > < package >pom< >\n继承： 子模块可以使用父模块的依赖\n\n##### maven测试\n快捷键？？？\n\n\n\n---\n\n### 3. WHY（为什么要使用maven）\n首先，为什么有maven？构建是程序员每天要做的工作，而且相当长的时间花在了这上面，而maven使这系列的工作完全自动化。 我们一直在寻找避免重复的方法，设计的重复，文档的重复，编码的重复，构建的重复等，maven是跨平台的，最大的消除了构建的重复。\n\nmaven的其他优势：\n1.  maven不仅是构建工具，它还是依赖管理工具和项目管理工具，提供了中央仓库，能够帮我们自动下载构件。\n2.  为了解决的依赖的增多，版本不一致，版本冲突，依赖臃肿等问题，它通过一个坐标系统来精确地定位每一个构件（artifact）。\n3.  还能帮助我们分散在各个角落的项目信息，包括项目描述，开发者列表，版本控制系统，许可证，缺陷管理系统地址。\n4.  maven还为全世界的java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源软件。通过衍生工具(Nexus),我们还能对其进行快速搜索\n5.  maven对于目录结构有要求，约定优于配置，用户在项目间切换就省去了学习成本。\n\nMaven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。\n\n在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。\n\n> **参考文献：**\n> http://www.cnblogs.com/luotaoyeah/p/3819001.html Maven入门指南⑦：Maven的生命周期和插件\n> http://ifeve.com/maven-1/ Maven入门指南（一）\n> http://ifeve.com/maven-2/ Maven入门指南（二）\n> http://blog.csdn.net/nancy_feng/article/details/38148625 maven学习-----maven的优势\n\n\n\n\n\n\n","slug":"Maven初探","published":1,"updated":"2018-08-13T14:28:27.553Z","layout":"post","photos":[],"link":"","_id":"cjloh3e6h00446k156j99wkhu","content":"<p>今天整理一下对于Maven的学习。和学习其他知识一样，我在看完各种关于Maven的介绍以及文档之后，按照what，how，why来温习。<br><a id=\"more\"></a></p>\n<h3 id=\"1-What（Maven是什么？）\"><a href=\"#1-What（Maven是什么？）\" class=\"headerlink\" title=\"1. What（Maven是什么？）\"></a>1. What（Maven是什么？）</h3><p>Maven是一个强大的Java项目构建工具，构建工具：将软件项目构建相关的过程自动化的工具。</p>\n<p>构建一个软件项目通常包含以下一个或多个过程：</p>\n<ul>\n<li>生成源码（如果项目使用自动生成源码）；</li>\n<li>从源码生成项目文档；</li>\n<li>编译源码；</li>\n<li>将编译后的源码打包成JAR文件或者ZIP文件；</li>\n<li>将打包好的代码安装到服务器、仓库或者其他的地方；</li>\n</ul>\n<h5 id=\"安装Maven\"><a href=\"#安装Maven\" class=\"headerlink\" title=\"安装Maven\"></a>安装Maven</h5><p><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/45390313\" target=\"_blank\" rel=\"noopener\">【项目管理和构建】——Maven下载、安装和配置（二）</a></p>\n<h5 id=\"Maven概览-核心概念\"><a href=\"#Maven概览-核心概念\" class=\"headerlink\" title=\"Maven概览-核心概念\"></a>Maven概览-核心概念</h5><p>Maven的中心思想是<strong>POM文件</strong>（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。</p>\n<p>下图说明了Maven是如何使用POM文件的，以及POM文件的主要组成部分：<br><img src=\"http://ifeve.com/wp-content/uploads/2014/06/maven-overview-1.png\" alt=\"\"></p>\n<h5 id=\"构建生命周期、构建阶段、构建目标\"><a href=\"#构建生命周期、构建阶段、构建目标\" class=\"headerlink\" title=\"构建生命周期、构建阶段、构建目标\"></a>构建生命周期、构建阶段、构建目标</h5><p>Maven的构建过程被分解为构建生命周期、阶段和目标。一个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的构建目标组成。当你运行Maven的时候，你会传入一条命令。这条命令就是构建生命周期、阶段或目标的名字。如果执行一个生命周期，该生命周期内的所有构建阶段都会被执行。如果执行一个构建阶段，在预定义的构建阶段中，所有处于当前构建阶段之前的阶段也都会被执行。  </p>\n<h5 id=\"依赖和仓库\"><a href=\"#依赖和仓库\" class=\"headerlink\" title=\"依赖和仓库\"></a>依赖和仓库</h5><p>Maven执行时，其中一个首要目标就是检查项目的依赖。依赖是你的项目用到的jar文件（java库）。如果在本地仓库中不存在该依赖，则Maven会从中央仓库下载并放到本地仓库。本地仓库只是你电脑硬盘上的一个目录。你可以根据需要制定本地仓库的位置。你也可以指定下载依赖的远程仓库的地址。</p>\n<h5 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h5><p>构建插件可以向构建阶段中增加额外的构建目标。如果Maven标准的构建阶段和目标无法满足项目构建的需求，你可以在POM文件里增加插件。Maven有一些标准的插件供选用，如果需要你可以自己实现插件。</p>\n<h5 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h5><p><em>不同的开发环境会使用不同的配置</em><br>配置文件用于以不同的方式构建项目。比如，你可能需要在本地环境构建，用于开发和测试，你也可能需要构建后用于开发环境。这两个构建过程是不同的。在POM文件中增加不同的构建配置，可以启用不同的构建过程。当运行Maven时，可以指定要使用的配置。</p>\n<h5 id=\"父pom\"><a href=\"#父pom\" class=\"headerlink\" title=\"父pom\"></a>父pom</h5><p>所有的Maven pom文件都继承自一个父pom。如果没有指定父pom，则该pom文件继承自根pom。pom文件的继承关系如下图所示：<br><img src=\"http://ifeve.com/wp-content/uploads/2014/06/super-pom.png\" alt=\"\"><br>可以让一个pom文件显式地继承另一个pom文件。这样，可以通过修改公共父pom文件的设置来修改所有子pom文件的设置。在pom文件的起始处指定父pom，例如：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">”http://maven.apache.org/POM/4.0.0″</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">”http://www.w3.org/2001/XMLSchema-instance”</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">”http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">http:</span>//<span class=\"attr\">maven.apache.org</span>/<span class=\"attr\">xsd</span>/<span class=\"attr\">maven-4.0.0.xsd</span>”&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>my-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../my-parent<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>my-project<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>子pom文件的设置可以覆盖父pom文件的设置，只需要在子pom文件里指定新的设置即可。</p>\n<h5 id=\"Maven配置文件\"><a href=\"#Maven配置文件\" class=\"headerlink\" title=\"Maven配置文件\"></a>Maven配置文件</h5><p>Maven配置文件</p>\n<p>Maven有两个配置文件。配置文件里的设置，对所有的pom文件都是有效的。比如，你可以配置：</p>\n<p>本地仓库的路径；<br>当前的编译配置选项<br>等等<br>配置文件名为settings.xml，两个配置文件分别为：</p>\n<ul>\n<li>Maven安装目录中：$M2_HOME/conf/settings.xml</li>\n<li>用户主目录中：${user.home}/.m2/settings.xml</li>\n</ul>\n<p>两个配置文件都是可选的。如果两个文件都存在，则用户目录下的配置会覆盖Maven安装目录中的配置。</p>\n<h5 id=\"Maven运行\"><a href=\"#Maven运行\" class=\"headerlink\" title=\"Maven运行\"></a>Maven运行</h5><p><a href=\"http://blog.csdn.net/phantomes/article/details/8110779\" target=\"_blank\" rel=\"noopener\">maven常用命令行及解释</a></p>\n<h3 id=\"2-How-Maven具体使用\"><a href=\"#2-How-Maven具体使用\" class=\"headerlink\" title=\"2. How(Maven具体使用)\"></a>2. How(Maven具体使用)</h3><h5 id=\"Maven安装目录\"><a href=\"#Maven安装目录\" class=\"headerlink\" title=\"Maven安装目录\"></a>Maven安装目录</h5><p>四个文件夹：<br>bin：包含mvn运行的脚本,m2.conf配置文件<br>boot：boot目录包含一个类加载器的框架<br>conf：是配置文件目录<br>lib：类库</p>\n<h5 id=\"Maven目录结构\"><a href=\"#Maven目录结构\" class=\"headerlink\" title=\"Maven目录结构\"></a>Maven目录结构</h5><p>Maven有一个标准的目录结构。如果你在项目中遵循Maven的目录结构，就无需在pom文件中指定源代码、测试代码等目录。<br>以下为最重要的目录：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">  - main</span><br><span class=\"line\">    - java</span><br><span class=\"line\">    - resources</span><br><span class=\"line\">    - webapp</span><br><span class=\"line\">  - test</span><br><span class=\"line\">    - java</span><br><span class=\"line\">    - resources</span><br><span class=\"line\"></span><br><span class=\"line\">- target</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\" target=\"_blank\" rel=\"noopener\">Maven标准目录结构介绍</a><br>src目录是源代码和测试代码的根目录。main目录是应用的源代码目录。test目录是测试代码的目录。main和test下的java目录，分别表示应用的java源代码和测试代码。</p>\n<p>resources目录包含项目的资源文件，比如应用的国际化配置的属性文件等。</p>\n<p>如果是一个web项目，则webapp目录为web项目的根目录，其中包含如WEB-INF等子目录。</p>\n<p>target目录是由Maven创建的，其中包含编译后的类文件、jar文件等。当执行maven的clean目标后，target目录会被清空。</p>\n<h5 id=\"POM文件\"><a href=\"#POM文件\" class=\"headerlink\" title=\"POM文件\"></a>POM文件</h5><p><a href=\"http://ifeve.com/maven-pom/\" target=\"_blank\" rel=\"noopener\">《Maven官方文档》POM文件</a><br><a href=\"http://blog.csdn.net/u012152619/article/details/51485297\" target=\"_blank\" rel=\"noopener\">Maven之（七）pom.xml配置文件详解</a></p>\n<h5 id=\"外部依赖\"><a href=\"#外部依赖\" class=\"headerlink\" title=\"外部依赖\"></a>外部依赖</h5><p>Maven的外部依赖指的是不在Maven的仓库（包括本地仓库、中央仓库和远程仓库）中的依赖（jar包）。它可能位于你本地硬盘的某个地方，比如web应用的lib目录下。这里的“外部”是对Maven仓库系统而言的，不仅仅是对项目而言的。大部分的外部依赖都是针对项目的，很少的外部依赖是针对仓库系统的（即不在仓库中）。</p>\n<p>配置外部依赖的示例如下：</p>\n<pre><code>\n&lt;dependency&gt;\n  &lt;groupId&gt;mydependency&lt;/groupId&gt;\n  &lt;artifactId&gt;mydependency&lt;/artifactId&gt;\n  &lt;scope&gt;system&lt;/scope&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;systemPath&gt;${basedir}\\war\\WEB-INF\\lib\\mydependency.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n </code></pre>\ngroupId和artifactId为依赖的名称，即API的名称。scope属性为system。systemPath属性为jar文件的路径。${basedir}为pom文件所在的目录，路径中的其它部分是相对于该目录而言的。\n\n##### 快照依赖\n快照依赖指的是那些还在开发中的依赖（jar包）。与其经常地更新版本号来获取最新版本，不如你直接依赖项目的快照版本。快照版本的每一个build版本都会被下载到本地仓库，即使该快照版本已经在本地仓库了。总是下载快照依赖可以确保本地仓库中的每一个build版本都是最新的。\n\n在pom文件的最开头（设置groupId和artifactId的地方），在版本号后追加-SNAPSHOT，则告诉Maven你的项目是一个快照版本。如：\n<pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    </code></pre>\n可以看到加到版本号后的-SNAPSHOT。\n\n在配置依赖时，在版本号后追加-SNAPSHOT表明依赖的是一个快照版本。如：\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.jenkov&lt;/groupId&gt;\n    &lt;artifactId&gt;java-web-crawler&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n追加在version后的-SNAPSHOT告诉Maven这是一个快照版本。\n\n可以在Maven配置文件中设置快照版本下载的频率。\n\n##### Maven仓库\nMaven仓库就是存储jar包和一些元数据信息的目录。其中的元数据即pom文件，描述了该jar包属于哪个项目，以及jar包所需的外部依赖。该元数据信息使得Maven可以递归地下载所有的依赖，直到整个依赖树都下载完毕并放到你的本地仓库中。\nMaven有三种类型的仓库：\n\n本地仓库\n中央仓库\n远程仓库\nMaven根据以上的顺序去仓库中搜索依赖。首先是本地仓库，然后是中央仓库，最后，如果pom文件中配置了远程仓库，则会去远程仓库中查找。\n\n下图说明了三种仓库的类型以及位置：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-repo-types-loc-300x185.png)\n本地仓库\n\n本地仓库就是开发者电脑上的一个目录。该仓库包含了Maven下载的所有依赖。一般来讲，一个本地仓库为多个不同的项目服务。因此，Maven只需下载一次，即使有多个项目都依赖它（如junit）。\n\n通过mvn install命令可以将你自己的项目构建并安装到本地仓库中。这样，你的其它项目就可以通过在pom文件将该jar包作为外部依赖来使用。\n\nMaven的本地仓库默认在你本机的用户目录下。不过，你可以在Maven的配置文件中修改本地仓库的路径。Maven的配置文件也在用户目录下(user-home/.m2)，文件名为settings.xml。以下示例为本地仓库指定其它的路径：\n<pre><code>&lt;settings&gt;\n    &lt;localRepository&gt;\n        d:\\data\\java\\products\\maven\\repository\n    &lt;/localRepository&gt;\n&lt;/settings&gt;</code></pre>\n##### 中央仓库\n\nMaven的中央仓库由Maven社区提供。默认情况下，所有不在本地仓库中的依赖都会去这个中央仓库查找。然后Maven会将这些依赖下载到你的本地仓库。访问中央仓库不需要做额外的配置。\n\n##### 远程仓库\n\n远程仓库是位于web服务器上的一个仓库，Maven可以从该仓库下载依赖，就像从中央仓库下载依赖一样。远程仓库可以位于Internet上的任何地方，也可以是位于本地网络中。\n\n远程仓库一般用于放置组织内部的项目，该项目由多个项目共享。比如，由多个内部项目共用的安全项目。该安全项目不能被外部访问，因此不能放在公开的中央仓库下，而应该放到内部的远程仓库中。\n\n远程仓库中的依赖也会被Maven下载到本地仓库中。\n\n可以在pom文件里配置远程仓库。将以下的xml片段放到属性之后：\n<pre><code>&lt;repositories&gt;\n   &lt;repository&gt;\n       &lt;id&gt;jenkov.code&lt;/id&gt;\n       &lt;url&gt;http://maven.jenkov.com/maven2/lib&lt;/url&gt;\n   &lt;/repository&gt;\n&lt;/repositories&gt;</code></pre>\n\n<h5 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h5><p>一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven的生命周期是抽象的，其中的具体任务都交由插件来完成。Maven为大多数构建任务编写并绑定了默认的插件，如针对编译的插件：maven-compiler-plugin。用户也可自行配置或编写插件。<br><strong>1. 三套生命周期</strong><br>Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。<br><strong>1.1 clean生命周期</strong></p>\n<ol>\n<li>pre-clean    ：执行清理前的工作；</li>\n<li>clean    ：清理上一次构建生成的所有文件；</li>\n<li>post-clean    ：执行清理后的工作</li>\n</ol>\n<p><strong>1.2 default生命周期</strong><br>default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。</p>\n<ol><br><li>validate</li><br><li>initialize</li><br><li>generate-sources</li><br><li>process-sources</li><br><li>generate-resources</li><br><li>process-resources &nbsp; &nbsp;：复制和处理资源文件到target目录，准备打包；</li><br><li>compile &nbsp; &nbsp;：编译项目的源代码；</li><br><li>process-classes</li><br><li>generate-test-sources</li><br><li>process-test-sources</li><br><li>generate-test-resources</li><br><li>process-test-resources</li><br><li>test-compile &nbsp; &nbsp;：编译测试源代码；</li><br><li>process-test-classes</li><br><li>test &nbsp; &nbsp;：运行测试代码；</li><br><li>prepare-package</li><br><li>package &nbsp; &nbsp;：打包成jar或者war或者其他格式的分发包；</li><br><li>pre-integration-test</li><br><li>integration-test</li><br><li>post-integration-test</li><br><li>verify</li><br><li>install &nbsp; &nbsp;：将打好的包安装到本地仓库，供其他项目使用；</li><br><li>deploy &nbsp; &nbsp;：将打好的包安装到远程仓库，供其他项目使用；</li><br></ol><br><strong>1.3 site生命周期</strong><br><ol><br><li>pre-site</li><br><li>site &nbsp; &nbsp;：生成项目的站点文档；</li><br><li>post-site</li><br><li>site-deploy &nbsp; &nbsp;：发布生成的站点文档</li><br></ol>\n\n<h5 id=\"插件-1\"><a href=\"#插件-1\" class=\"headerlink\" title=\"插件\"></a>插件</h5><p>Maven的核心文件很小，主要的任务都是由插件来完成。定位到：%本地仓库%\\org\\apache\\maven\\plugins，可以看到一些下载好的插件：<br><img src=\"http://images.cnitblog.com/i/293735/201407/012038215279940.png\" alt=\"\"><br>具体参考的这篇文章，写作风格真棒，很漂亮的排版。<br><a href=\"http://www.cnblogs.com/luotaoyeah/p/3819001.html\" target=\"_blank\" rel=\"noopener\">Maven入门指南⑦：Maven的生命周期和插件</a></p>\n<h5 id=\"maven-命令\"><a href=\"#maven-命令\" class=\"headerlink\" title=\"maven 命令\"></a>maven 命令</h5><blockquote>\n<p>编译源代码：mvn compile<br>编译测试代码：mvn test-compile<br>运行测试：mvn test (会运行前面的三个命令)<br>打包：mvn package<br>部署到本地：mvn install<br>在远程部署jar：mvn deploy<br>清除产生的项目：mvn clean<br>窥探SuperPom：mvn help:effective-pom<br>maven依赖树：mvn dependency:tree<br>打包的时候过滤test：mvn clean package -Pdev -Dmaven.test.skip=true</p>\n</blockquote>\n<h5 id=\"maven的生命周期\"><a href=\"#maven的生命周期\" class=\"headerlink\" title=\"maven的生命周期\"></a>maven的生命周期</h5><ul>\n<li>构建生命周期<ul>\n<li>clean<ul>\n<li>Pre-clean 做移除准备</li>\n<li>Clean 移除jar</li>\n<li>Post-clean 移除target</li>\n</ul>\n</li>\n<li>default（项目构建真正需要执行的所有步骤：23个阶段，执行某个执行阶段前的阶段都会被执行，避免重复工作）        <ul>\n<li>pre-resource</li>\n<li>compile</li>\n<li>test-compile</li>\n<li>test</li>\n<li>package</li>\n<li>install</li>\n<li>deploy </li>\n</ul>\n</li>\n<li>site （项目所有的资源文件放在一个站点服务器上，用户可以通过站点访问我们的api文档等）<ul>\n<li>Pre-site</li>\n<li>Site</li>\n<li>Post-site</li>\n<li>Site-deploy</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"shapshot和release版本\"><a href=\"#shapshot和release版本\" class=\"headerlink\" title=\"shapshot和release版本\"></a>shapshot和release版本</h5><p>snapshot 快照版会经常更新，maven会实时下载<br>release 稳定版<br>防止版本号的滥用，以及及时的协作更新</p>\n<h5 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h5><p>type:<br>scope:<br>optional:<br>exclusions:<br>依赖特性：依赖传递、<br>依赖冲突：路径优先、声明优先<br>依赖排除：dependencymanagement、execlusion</p>\n<h5 id=\"maven的聚合与继承\"><a href=\"#maven的聚合与继承\" class=\"headerlink\" title=\"maven的聚合与继承\"></a>maven的聚合与继承</h5><p>聚合：使用一个命令同时构建多个模块<br>&lt; modules &gt; &lt; package &gt;pom&lt; &gt;<br>继承： 子模块可以使用父模块的依赖</p>\n<h5 id=\"maven测试\"><a href=\"#maven测试\" class=\"headerlink\" title=\"maven测试\"></a>maven测试</h5><p>快捷键？？？</p>\n<hr>\n<h3 id=\"3-WHY（为什么要使用maven）\"><a href=\"#3-WHY（为什么要使用maven）\" class=\"headerlink\" title=\"3. WHY（为什么要使用maven）\"></a>3. WHY（为什么要使用maven）</h3><p>首先，为什么有maven？构建是程序员每天要做的工作，而且相当长的时间花在了这上面，而maven使这系列的工作完全自动化。 我们一直在寻找避免重复的方法，设计的重复，文档的重复，编码的重复，构建的重复等，maven是跨平台的，最大的消除了构建的重复。</p>\n<p>maven的其他优势：</p>\n<ol>\n<li>maven不仅是构建工具，它还是依赖管理工具和项目管理工具，提供了中央仓库，能够帮我们自动下载构件。</li>\n<li>为了解决的依赖的增多，版本不一致，版本冲突，依赖臃肿等问题，它通过一个坐标系统来精确地定位每一个构件（artifact）。</li>\n<li>还能帮助我们分散在各个角落的项目信息，包括项目描述，开发者列表，版本控制系统，许可证，缺陷管理系统地址。</li>\n<li>maven还为全世界的java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源软件。通过衍生工具(Nexus),我们还能对其进行快速搜索</li>\n<li>maven对于目录结构有要求，约定优于配置，用户在项目间切换就省去了学习成本。</li>\n</ol>\n<p>Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。</p>\n<p>在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。</p>\n<blockquote>\n<p><strong>参考文献：</strong><br><a href=\"http://www.cnblogs.com/luotaoyeah/p/3819001.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/luotaoyeah/p/3819001.html</a> Maven入门指南⑦：Maven的生命周期和插件<br><a href=\"http://ifeve.com/maven-1/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/maven-1/</a> Maven入门指南（一）<br><a href=\"http://ifeve.com/maven-2/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/maven-2/</a> Maven入门指南（二）<br><a href=\"http://blog.csdn.net/nancy_feng/article/details/38148625\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/nancy_feng/article/details/38148625</a> maven学习—–maven的优势</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>今天整理一下对于Maven的学习。和学习其他知识一样，我在看完各种关于Maven的介绍以及文档之后，按照what，how，why来温习。<br>","more":"</p>\n<h3 id=\"1-What（Maven是什么？）\"><a href=\"#1-What（Maven是什么？）\" class=\"headerlink\" title=\"1. What（Maven是什么？）\"></a>1. What（Maven是什么？）</h3><p>Maven是一个强大的Java项目构建工具，构建工具：将软件项目构建相关的过程自动化的工具。</p>\n<p>构建一个软件项目通常包含以下一个或多个过程：</p>\n<ul>\n<li>生成源码（如果项目使用自动生成源码）；</li>\n<li>从源码生成项目文档；</li>\n<li>编译源码；</li>\n<li>将编译后的源码打包成JAR文件或者ZIP文件；</li>\n<li>将打包好的代码安装到服务器、仓库或者其他的地方；</li>\n</ul>\n<h5 id=\"安装Maven\"><a href=\"#安装Maven\" class=\"headerlink\" title=\"安装Maven\"></a>安装Maven</h5><p><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/45390313\" target=\"_blank\" rel=\"noopener\">【项目管理和构建】——Maven下载、安装和配置（二）</a></p>\n<h5 id=\"Maven概览-核心概念\"><a href=\"#Maven概览-核心概念\" class=\"headerlink\" title=\"Maven概览-核心概念\"></a>Maven概览-核心概念</h5><p>Maven的中心思想是<strong>POM文件</strong>（项目对象模型）。POM文件是以XML文件的形式表述项目的资源，如源码、测试代码、依赖（用到的外部Jar包）等。POM文件应该位于项目的根目录下。</p>\n<p>下图说明了Maven是如何使用POM文件的，以及POM文件的主要组成部分：<br><img src=\"http://ifeve.com/wp-content/uploads/2014/06/maven-overview-1.png\" alt=\"\"></p>\n<h5 id=\"构建生命周期、构建阶段、构建目标\"><a href=\"#构建生命周期、构建阶段、构建目标\" class=\"headerlink\" title=\"构建生命周期、构建阶段、构建目标\"></a>构建生命周期、构建阶段、构建目标</h5><p>Maven的构建过程被分解为构建生命周期、阶段和目标。一个构建周期由一系列的构建阶段组成，每一个构建阶段由一系列的构建目标组成。当你运行Maven的时候，你会传入一条命令。这条命令就是构建生命周期、阶段或目标的名字。如果执行一个生命周期，该生命周期内的所有构建阶段都会被执行。如果执行一个构建阶段，在预定义的构建阶段中，所有处于当前构建阶段之前的阶段也都会被执行。  </p>\n<h5 id=\"依赖和仓库\"><a href=\"#依赖和仓库\" class=\"headerlink\" title=\"依赖和仓库\"></a>依赖和仓库</h5><p>Maven执行时，其中一个首要目标就是检查项目的依赖。依赖是你的项目用到的jar文件（java库）。如果在本地仓库中不存在该依赖，则Maven会从中央仓库下载并放到本地仓库。本地仓库只是你电脑硬盘上的一个目录。你可以根据需要制定本地仓库的位置。你也可以指定下载依赖的远程仓库的地址。</p>\n<h5 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h5><p>构建插件可以向构建阶段中增加额外的构建目标。如果Maven标准的构建阶段和目标无法满足项目构建的需求，你可以在POM文件里增加插件。Maven有一些标准的插件供选用，如果需要你可以自己实现插件。</p>\n<h5 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h5><p><em>不同的开发环境会使用不同的配置</em><br>配置文件用于以不同的方式构建项目。比如，你可能需要在本地环境构建，用于开发和测试，你也可能需要构建后用于开发环境。这两个构建过程是不同的。在POM文件中增加不同的构建配置，可以启用不同的构建过程。当运行Maven时，可以指定要使用的配置。</p>\n<h5 id=\"父pom\"><a href=\"#父pom\" class=\"headerlink\" title=\"父pom\"></a>父pom</h5><p>所有的Maven pom文件都继承自一个父pom。如果没有指定父pom，则该pom文件继承自根pom。pom文件的继承关系如下图所示：<br><img src=\"http://ifeve.com/wp-content/uploads/2014/06/super-pom.png\" alt=\"\"><br>可以让一个pom文件显式地继承另一个pom文件。这样，可以通过修改公共父pom文件的设置来修改所有子pom文件的设置。在pom文件的起始处指定父pom，例如：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">”http://maven.apache.org/POM/4.0.0″</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">”http://www.w3.org/2001/XMLSchema-instance”</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">”http://maven.apache.org/POM/4.0.0</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">http:</span>//<span class=\"attr\">maven.apache.org</span>/<span class=\"attr\">xsd</span>/<span class=\"attr\">maven-4.0.0.xsd</span>”&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>my-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../my-parent<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>my-project<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>子pom文件的设置可以覆盖父pom文件的设置，只需要在子pom文件里指定新的设置即可。</p>\n<h5 id=\"Maven配置文件\"><a href=\"#Maven配置文件\" class=\"headerlink\" title=\"Maven配置文件\"></a>Maven配置文件</h5><p>Maven配置文件</p>\n<p>Maven有两个配置文件。配置文件里的设置，对所有的pom文件都是有效的。比如，你可以配置：</p>\n<p>本地仓库的路径；<br>当前的编译配置选项<br>等等<br>配置文件名为settings.xml，两个配置文件分别为：</p>\n<ul>\n<li>Maven安装目录中：$M2_HOME/conf/settings.xml</li>\n<li>用户主目录中：${user.home}/.m2/settings.xml</li>\n</ul>\n<p>两个配置文件都是可选的。如果两个文件都存在，则用户目录下的配置会覆盖Maven安装目录中的配置。</p>\n<h5 id=\"Maven运行\"><a href=\"#Maven运行\" class=\"headerlink\" title=\"Maven运行\"></a>Maven运行</h5><p><a href=\"http://blog.csdn.net/phantomes/article/details/8110779\" target=\"_blank\" rel=\"noopener\">maven常用命令行及解释</a></p>\n<h3 id=\"2-How-Maven具体使用\"><a href=\"#2-How-Maven具体使用\" class=\"headerlink\" title=\"2. How(Maven具体使用)\"></a>2. How(Maven具体使用)</h3><h5 id=\"Maven安装目录\"><a href=\"#Maven安装目录\" class=\"headerlink\" title=\"Maven安装目录\"></a>Maven安装目录</h5><p>四个文件夹：<br>bin：包含mvn运行的脚本,m2.conf配置文件<br>boot：boot目录包含一个类加载器的框架<br>conf：是配置文件目录<br>lib：类库</p>\n<h5 id=\"Maven目录结构\"><a href=\"#Maven目录结构\" class=\"headerlink\" title=\"Maven目录结构\"></a>Maven目录结构</h5><p>Maven有一个标准的目录结构。如果你在项目中遵循Maven的目录结构，就无需在pom文件中指定源代码、测试代码等目录。<br>以下为最重要的目录：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">  - main</span><br><span class=\"line\">    - java</span><br><span class=\"line\">    - resources</span><br><span class=\"line\">    - webapp</span><br><span class=\"line\">  - test</span><br><span class=\"line\">    - java</span><br><span class=\"line\">    - resources</span><br><span class=\"line\"></span><br><span class=\"line\">- target</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\" target=\"_blank\" rel=\"noopener\">Maven标准目录结构介绍</a><br>src目录是源代码和测试代码的根目录。main目录是应用的源代码目录。test目录是测试代码的目录。main和test下的java目录，分别表示应用的java源代码和测试代码。</p>\n<p>resources目录包含项目的资源文件，比如应用的国际化配置的属性文件等。</p>\n<p>如果是一个web项目，则webapp目录为web项目的根目录，其中包含如WEB-INF等子目录。</p>\n<p>target目录是由Maven创建的，其中包含编译后的类文件、jar文件等。当执行maven的clean目标后，target目录会被清空。</p>\n<h5 id=\"POM文件\"><a href=\"#POM文件\" class=\"headerlink\" title=\"POM文件\"></a>POM文件</h5><p><a href=\"http://ifeve.com/maven-pom/\" target=\"_blank\" rel=\"noopener\">《Maven官方文档》POM文件</a><br><a href=\"http://blog.csdn.net/u012152619/article/details/51485297\" target=\"_blank\" rel=\"noopener\">Maven之（七）pom.xml配置文件详解</a></p>\n<h5 id=\"外部依赖\"><a href=\"#外部依赖\" class=\"headerlink\" title=\"外部依赖\"></a>外部依赖</h5><p>Maven的外部依赖指的是不在Maven的仓库（包括本地仓库、中央仓库和远程仓库）中的依赖（jar包）。它可能位于你本地硬盘的某个地方，比如web应用的lib目录下。这里的“外部”是对Maven仓库系统而言的，不仅仅是对项目而言的。大部分的外部依赖都是针对项目的，很少的外部依赖是针对仓库系统的（即不在仓库中）。</p>\n<p>配置外部依赖的示例如下：</p>\n<pre><code>\n&lt;dependency&gt;\n  &lt;groupId&gt;mydependency&lt;/groupId&gt;\n  &lt;artifactId&gt;mydependency&lt;/artifactId&gt;\n  &lt;scope&gt;system&lt;/scope&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;systemPath&gt;${basedir}\\war\\WEB-INF\\lib\\mydependency.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n </code></pre>\ngroupId和artifactId为依赖的名称，即API的名称。scope属性为system。systemPath属性为jar文件的路径。${basedir}为pom文件所在的目录，路径中的其它部分是相对于该目录而言的。\n\n##### 快照依赖\n快照依赖指的是那些还在开发中的依赖（jar包）。与其经常地更新版本号来获取最新版本，不如你直接依赖项目的快照版本。快照版本的每一个build版本都会被下载到本地仓库，即使该快照版本已经在本地仓库了。总是下载快照依赖可以确保本地仓库中的每一个build版本都是最新的。\n\n在pom文件的最开头（设置groupId和artifactId的地方），在版本号后追加-SNAPSHOT，则告诉Maven你的项目是一个快照版本。如：\n<pre><code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    </code></pre>\n可以看到加到版本号后的-SNAPSHOT。\n\n在配置依赖时，在版本号后追加-SNAPSHOT表明依赖的是一个快照版本。如：\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.jenkov&lt;/groupId&gt;\n    &lt;artifactId&gt;java-web-crawler&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n追加在version后的-SNAPSHOT告诉Maven这是一个快照版本。\n\n可以在Maven配置文件中设置快照版本下载的频率。\n\n##### Maven仓库\nMaven仓库就是存储jar包和一些元数据信息的目录。其中的元数据即pom文件，描述了该jar包属于哪个项目，以及jar包所需的外部依赖。该元数据信息使得Maven可以递归地下载所有的依赖，直到整个依赖树都下载完毕并放到你的本地仓库中。\nMaven有三种类型的仓库：\n\n本地仓库\n中央仓库\n远程仓库\nMaven根据以上的顺序去仓库中搜索依赖。首先是本地仓库，然后是中央仓库，最后，如果pom文件中配置了远程仓库，则会去远程仓库中查找。\n\n下图说明了三种仓库的类型以及位置：\n![](http://ifeve.com/wp-content/uploads/2014/06/maven-repo-types-loc-300x185.png)\n本地仓库\n\n本地仓库就是开发者电脑上的一个目录。该仓库包含了Maven下载的所有依赖。一般来讲，一个本地仓库为多个不同的项目服务。因此，Maven只需下载一次，即使有多个项目都依赖它（如junit）。\n\n通过mvn install命令可以将你自己的项目构建并安装到本地仓库中。这样，你的其它项目就可以通过在pom文件将该jar包作为外部依赖来使用。\n\nMaven的本地仓库默认在你本机的用户目录下。不过，你可以在Maven的配置文件中修改本地仓库的路径。Maven的配置文件也在用户目录下(user-home/.m2)，文件名为settings.xml。以下示例为本地仓库指定其它的路径：\n<pre><code>&lt;settings&gt;\n    &lt;localRepository&gt;\n        d:\\data\\java\\products\\maven\\repository\n    &lt;/localRepository&gt;\n&lt;/settings&gt;</code></pre>\n##### 中央仓库\n\nMaven的中央仓库由Maven社区提供。默认情况下，所有不在本地仓库中的依赖都会去这个中央仓库查找。然后Maven会将这些依赖下载到你的本地仓库。访问中央仓库不需要做额外的配置。\n\n##### 远程仓库\n\n远程仓库是位于web服务器上的一个仓库，Maven可以从该仓库下载依赖，就像从中央仓库下载依赖一样。远程仓库可以位于Internet上的任何地方，也可以是位于本地网络中。\n\n远程仓库一般用于放置组织内部的项目，该项目由多个项目共享。比如，由多个内部项目共用的安全项目。该安全项目不能被外部访问，因此不能放在公开的中央仓库下，而应该放到内部的远程仓库中。\n\n远程仓库中的依赖也会被Maven下载到本地仓库中。\n\n可以在pom文件里配置远程仓库。将以下的xml片段放到属性之后：\n<pre><code>&lt;repositories&gt;\n   &lt;repository&gt;\n       &lt;id&gt;jenkov.code&lt;/id&gt;\n       &lt;url&gt;http://maven.jenkov.com/maven2/lib&lt;/url&gt;\n   &lt;/repository&gt;\n&lt;/repositories&gt;</code></pre>\n\n<h5 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h5><p>一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven的生命周期是抽象的，其中的具体任务都交由插件来完成。Maven为大多数构建任务编写并绑定了默认的插件，如针对编译的插件：maven-compiler-plugin。用户也可自行配置或编写插件。<br><strong>1. 三套生命周期</strong><br>Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。<br><strong>1.1 clean生命周期</strong></p>\n<ol>\n<li>pre-clean    ：执行清理前的工作；</li>\n<li>clean    ：清理上一次构建生成的所有文件；</li>\n<li>post-clean    ：执行清理后的工作</li>\n</ol>\n<p><strong>1.2 default生命周期</strong><br>default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。</p>\n<ol><br><li>validate</li><br><li>initialize</li><br><li>generate-sources</li><br><li>process-sources</li><br><li>generate-resources</li><br><li>process-resources &nbsp; &nbsp;：复制和处理资源文件到target目录，准备打包；</li><br><li>compile &nbsp; &nbsp;：编译项目的源代码；</li><br><li>process-classes</li><br><li>generate-test-sources</li><br><li>process-test-sources</li><br><li>generate-test-resources</li><br><li>process-test-resources</li><br><li>test-compile &nbsp; &nbsp;：编译测试源代码；</li><br><li>process-test-classes</li><br><li>test &nbsp; &nbsp;：运行测试代码；</li><br><li>prepare-package</li><br><li>package &nbsp; &nbsp;：打包成jar或者war或者其他格式的分发包；</li><br><li>pre-integration-test</li><br><li>integration-test</li><br><li>post-integration-test</li><br><li>verify</li><br><li>install &nbsp; &nbsp;：将打好的包安装到本地仓库，供其他项目使用；</li><br><li>deploy &nbsp; &nbsp;：将打好的包安装到远程仓库，供其他项目使用；</li><br></ol><br><strong>1.3 site生命周期</strong><br><ol><br><li>pre-site</li><br><li>site &nbsp; &nbsp;：生成项目的站点文档；</li><br><li>post-site</li><br><li>site-deploy &nbsp; &nbsp;：发布生成的站点文档</li><br></ol>\n\n<h5 id=\"插件-1\"><a href=\"#插件-1\" class=\"headerlink\" title=\"插件\"></a>插件</h5><p>Maven的核心文件很小，主要的任务都是由插件来完成。定位到：%本地仓库%\\org\\apache\\maven\\plugins，可以看到一些下载好的插件：<br><img src=\"http://images.cnitblog.com/i/293735/201407/012038215279940.png\" alt=\"\"><br>具体参考的这篇文章，写作风格真棒，很漂亮的排版。<br><a href=\"http://www.cnblogs.com/luotaoyeah/p/3819001.html\" target=\"_blank\" rel=\"noopener\">Maven入门指南⑦：Maven的生命周期和插件</a></p>\n<h5 id=\"maven-命令\"><a href=\"#maven-命令\" class=\"headerlink\" title=\"maven 命令\"></a>maven 命令</h5><blockquote>\n<p>编译源代码：mvn compile<br>编译测试代码：mvn test-compile<br>运行测试：mvn test (会运行前面的三个命令)<br>打包：mvn package<br>部署到本地：mvn install<br>在远程部署jar：mvn deploy<br>清除产生的项目：mvn clean<br>窥探SuperPom：mvn help:effective-pom<br>maven依赖树：mvn dependency:tree<br>打包的时候过滤test：mvn clean package -Pdev -Dmaven.test.skip=true</p>\n</blockquote>\n<h5 id=\"maven的生命周期\"><a href=\"#maven的生命周期\" class=\"headerlink\" title=\"maven的生命周期\"></a>maven的生命周期</h5><ul>\n<li>构建生命周期<ul>\n<li>clean<ul>\n<li>Pre-clean 做移除准备</li>\n<li>Clean 移除jar</li>\n<li>Post-clean 移除target</li>\n</ul>\n</li>\n<li>default（项目构建真正需要执行的所有步骤：23个阶段，执行某个执行阶段前的阶段都会被执行，避免重复工作）        <ul>\n<li>pre-resource</li>\n<li>compile</li>\n<li>test-compile</li>\n<li>test</li>\n<li>package</li>\n<li>install</li>\n<li>deploy </li>\n</ul>\n</li>\n<li>site （项目所有的资源文件放在一个站点服务器上，用户可以通过站点访问我们的api文档等）<ul>\n<li>Pre-site</li>\n<li>Site</li>\n<li>Post-site</li>\n<li>Site-deploy</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"shapshot和release版本\"><a href=\"#shapshot和release版本\" class=\"headerlink\" title=\"shapshot和release版本\"></a>shapshot和release版本</h5><p>snapshot 快照版会经常更新，maven会实时下载<br>release 稳定版<br>防止版本号的滥用，以及及时的协作更新</p>\n<h5 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h5><p>type:<br>scope:<br>optional:<br>exclusions:<br>依赖特性：依赖传递、<br>依赖冲突：路径优先、声明优先<br>依赖排除：dependencymanagement、execlusion</p>\n<h5 id=\"maven的聚合与继承\"><a href=\"#maven的聚合与继承\" class=\"headerlink\" title=\"maven的聚合与继承\"></a>maven的聚合与继承</h5><p>聚合：使用一个命令同时构建多个模块<br>&lt; modules &gt; &lt; package &gt;pom&lt; &gt;<br>继承： 子模块可以使用父模块的依赖</p>\n<h5 id=\"maven测试\"><a href=\"#maven测试\" class=\"headerlink\" title=\"maven测试\"></a>maven测试</h5><p>快捷键？？？</p>\n<hr>\n<h3 id=\"3-WHY（为什么要使用maven）\"><a href=\"#3-WHY（为什么要使用maven）\" class=\"headerlink\" title=\"3. WHY（为什么要使用maven）\"></a>3. WHY（为什么要使用maven）</h3><p>首先，为什么有maven？构建是程序员每天要做的工作，而且相当长的时间花在了这上面，而maven使这系列的工作完全自动化。 我们一直在寻找避免重复的方法，设计的重复，文档的重复，编码的重复，构建的重复等，maven是跨平台的，最大的消除了构建的重复。</p>\n<p>maven的其他优势：</p>\n<ol>\n<li>maven不仅是构建工具，它还是依赖管理工具和项目管理工具，提供了中央仓库，能够帮我们自动下载构件。</li>\n<li>为了解决的依赖的增多，版本不一致，版本冲突，依赖臃肿等问题，它通过一个坐标系统来精确地定位每一个构件（artifact）。</li>\n<li>还能帮助我们分散在各个角落的项目信息，包括项目描述，开发者列表，版本控制系统，许可证，缺陷管理系统地址。</li>\n<li>maven还为全世界的java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源软件。通过衍生工具(Nexus),我们还能对其进行快速搜索</li>\n<li>maven对于目录结构有要求，约定优于配置，用户在项目间切换就省去了学习成本。</li>\n</ol>\n<p>Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。</p>\n<p>在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。</p>\n<blockquote>\n<p><strong>参考文献：</strong><br><a href=\"http://www.cnblogs.com/luotaoyeah/p/3819001.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/luotaoyeah/p/3819001.html</a> Maven入门指南⑦：Maven的生命周期和插件<br><a href=\"http://ifeve.com/maven-1/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/maven-1/</a> Maven入门指南（一）<br><a href=\"http://ifeve.com/maven-2/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/maven-2/</a> Maven入门指南（二）<br><a href=\"http://blog.csdn.net/nancy_feng/article/details/38148625\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/nancy_feng/article/details/38148625</a> maven学习—–maven的优势</p>\n</blockquote>"},{"toc":true,"title":"单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）","date":"2018-09-05T01:34:05.000Z","_content":"# 单例模式（三种实现方式，抵御反射、反序列化攻击）\n\n单例模式指仅被实例化一次的类。这个设计模式目的是想在整个系统中只能出现这个类的一个实例。\n\n---\n\n## 三种实现方式：饿汉、懒汉、枚举\n\n在Java1.5发行版之前，实现Singleton有两种方法。这两种方法都要把构造器保持为私有的，并导出公有的静态成员，以便允许客户端访问该类的唯一实例。\n### 懒汉式\n**Version 1.0**\n懒汉式最简单的实现，我们称之为1.0版本\n懒汉式实现单例方法与饿汉之间的区别是：实例只有在被调用的时候才会初始化。\n<!--more-->\n```java\n// version1.1\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n1.0版本存在比较严重的问题，因为这个`singleton`是静态的全局变量，所以在多线程下，如果多个线程同时调用getInstance()方法的话，可能会有多个进程通过`(singleton == null)`检查，从而创建多个实例。熟悉多线程的你一定会说——“我们需要线程互斥或同步”，于是，就有了1.1版本\n**Version 1.1**\nen，1.1版本使用Synchronized关键字，看起来没有问题了吧？\nNO！！！如果有多个线程同时通过`(singleton == null)`检查，还是一样会创建多个实例，只是变成了串行创建而已。\n```java\n//Version 1.1\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton== null) {\n            synchronized (Singleton.class) {\n                singleton= new Singleton();\n            }\n        }\n        return singleton;\n    }\n}\n```\n于是我们继续升级，有了版本1.2.\n**Version 1.2**\n经过修改之后的1.2版本确实不会出现上面的问题。\n但是啊，我们每次调用getInstance()方法要进行同步，创建动作只有一次，但是读取操作也被同步了，效率低到令人发指。改！！！\n```java\n// version1.2\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()  {\n        synchronized (Singleton.class) {\n            if (singleton== null) {\n                singleton= new Singleton();\n            }\n        }\n        return singleton;\n    }\n}\n```\n**Version 1.3**\n还得改，嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。\n```java\n// version 1.3\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance() {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：\n1. 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。\n2. 不然，我们就开始同步线程。\n3. 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。\n\n这个版本已经相当漂亮了，但是，如果你认为这个版本大功告成，too young.\n主要在于`singleton = new Singleton()`这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。\n1. 给 singleton 分配内存\n2. 调用 Singleton 的构造函数来初始化成员变量，形成实例\n3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：\n```java\n// version 1.4\npublic class Singleton {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n使用 volatile 有两个功用：\n1. 这个变量不会在多个线程中存在复本，直接从内存读取。\n2. 这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。\n\n但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。\n### 饿汉式\n```java\npublic class HugrySingleton {\n    private volatile static HugrySingleton INSTANCE = new HugrySingleton();\n    private HugrySingleton(){}\n    public static HugrySingleton getINSTANCE(){\n        return INSTANCE;\n    }\n}\n```\n这种方法最大的问题是——当这个类被加载的时候，new Singleton()语句会被执行，无论getINSTANCE()是否被调用都会初始化这个类。于是，**这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。**\n\n好吧，我们还得绕一下：\n下面的这个1.6版是老版《Effective Java》中推荐的方式。\n```java\n// version 1.6\npublic class Singleton {\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton (){}\n    public static final Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n上面这种方式，仍然使用JVM本身机制（类只会被加载一次，在加载类时初始化了静态变量INSTANCE）保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n### 枚举单例\n从Java 1.5发行版本起，实现Singleton还有第三种方法。只需编写一个包含单个元素的枚举类型：\n```java\npublic enum SingletonEnum {\n    SINGLETON_ENUM;\n}\n```\n通过SingletonEnum.SINGLETON_ENUM来访问，比使用getInstance()方法简单多了。\n默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。\n**这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。**\n\n## 克隆、序列化、反射——单例模式防御\n\n使用**饿汉式**和**懒汉式**方法创建的单例，能够解决同步问题，然而很遗憾，这样并不能真正地实现单例，我有可能通过克隆、序列化、反射机制，来击破单例的模式。\n\n克隆，当你的单例类需要继承Cloneable接口时，就可以通过clone方法获取一个新的对象，那么单例防御失败。\n同理，序列化也可以，或者用反射，也可以。\n```java\n//获取构造函数\nConstructor constructor = SingleTon.class.getDeclaredConstructor();\nconstructor.setAccessible(true);\n```\n这样获取到了构造函数，设置可以访问，然后直接newInstance，就可以获取一个新的实例了。\n真正的单例，应当是可以抵御上述攻击的——\n### 一、抵御Clone攻击\n测试的单例模式实现了Cloneable接口，重写克隆方法：\n```java\n/**\n * 防止克隆攻击\n * @return\n* @throws CloneNotSupportedException\n */\n@Override\nprotected Object clone() throws CloneNotSupportedException {\n    return getInstance();\n}\n```\nSo Easy\n测试代码：\n```java\n// version 1.4\npublic class Singleton implements Cloneable {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    //如果注释此方法，下面的输出为false\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return getInstance();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        Singleton instance = getInstance();\n        Singleton singleton1 = (Singleton) instance.clone();\n        System.out.println(instance==singleton1);//true\n    }\n}\n```\n### 二、抵御序列化攻击\n单例类实现Serializable接口，然后重写一个方法：\n```java\n/**\n * 防止序列化攻击\n * @return\n*/\nprivate Object readResolve() {\n    return getInstance();\n}\n```\nSo Easy，比攻击的代码简单多了：\n```java\npublic class Singleton implements Serializable {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n    //如果注释此方法，返回结果为false\n    private Object readResolve(){\n        return getInstance();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {\n        Singleton singleton1 = getInstance();\n        System.out.println(\"序列化攻击被阻止了吗？\");\n        File file = new File(\"serializable.txt\");\n        //序列化\n        FileOutputStream fos = new FileOutputStream(file);\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(singleton1);\n        oos.flush();\n        oos.close();\n        fos.close();\n        //反序列化\n        FileInputStream fis = new FileInputStream(file);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Singleton singleTon3 = (Singleton) ois.readObject();\n        ois.close();\n        fis.close();\n        System.out.println(singleton1 == singleTon3); // true\n    }\n}\n```\n### 三、抵御反射攻击\n这里的思路就是加一个flag，判断构造函数是否第一次被调用。\n```java\nprivate static boolean flag = true;\nprivate SingleTon() {\n    if (flag){\nflag = false;\n        //code\n    }else {\n        throw new RuntimeException(\"对象已存在\");\n    }\n}\n```\n注意，这里的flag必须是private的，而且不能有getter setter函数。\n反射攻击的思路是，获取构造函数，然后获取到flag这个域，之后把这个flag置true，然后用构造函数新建。这里要求flag必须有getter setter，不然无法执行，这就是我们防御的思路。\n代码如下：\n```java\npackage cap.ljf.pattern.singleton;\n\nimport java.beans.IntrospectionException;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n\n\n\n/**\n * @author jifang.liu created on 2018/8/13 21:07\n */\n// version 1.4\npublic class Singleton {\n    private volatile static Singleton singleton = null;\n    private static boolean flag = true;\n    private Singleton(){\n        if (flag){\n            flag = false;\n            //code\n        }else {\n            throw new RuntimeException(\"对象已存在\");\n        }\n    }\n\n    public static boolean isFlag() {\n        return flag;\n    }\n\n    public static void setFlag(boolean flag) {\n        Singleton.flag = flag;\n    }\n\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException, IntrospectionException, InvocationTargetException, IllegalAccessException, InstantiationException {\n        Singleton singleton1 = getInstance();\n        System.out.println(\"反射攻击被阻止了吗\");\n        //获取构造函数\n        Constructor constructor = Singleton.class.getDeclaredConstructor();\n        constructor.setAccessible(true);\n\n        //要求该域必须有getter,setter，否则java.beans.IntrospectionException: Method not found: isFlag\n        PropertyDescriptor descriptor = new PropertyDescriptor(\"flag\", Singleton.class);\n\n        //每次新建一个实例前，将flag设置为true\n        descriptor.getWriteMethod().invoke(Singleton.class, true);\n        Singleton singleTon4 = (Singleton) constructor.newInstance();\n        System.out.println(singleton1 == singleTon4);//false\n    }\n}\n```\n\n至此，我们完成的单例模式的代码如下：\n```java\npublic class SingleTon implements Serializable, Cloneable{\n\n    private static final long serialVersionUID = 1L;\n\n    private static volatile SingleTon singleTon;\n\n    private static boolean flag = true;\n\n    private SingleTon() {\n        if (flag){\nflag = false;\n            //code\n        }else {\n            throw new RuntimeException(\"对象已存在\");\n        }\n    }\n\n    public static SingleTon getInstance(){\n        if (singleTon == null){\n            synchronized (SingleTon.class){\n                if (singleTon == null){\nsingleTon = new SingleTon();\n                }\n            }\n        }\n        return singleTon;\n    }\n\n/**\n     * 防止克隆攻击\n     * @return\n* @throws CloneNotSupportedException\n     */\n@Override\n    protected Object clone() throws CloneNotSupportedException {\n        return getInstance();\n    }\n\n//    public static boolean getFlag() {\n//        return flag;\n//    }\n//\n//    public static void setFlag(boolean flag) {\n//        SingleTon.flag = flag;\n//    }\n\n/**\n     * 防止序列化攻击\n     * @return\n*/\nprivate Object readResolve() {\n        return getInstance();\n    }\n｝\n```\n真是太麻烦了，有没有简单的方法呢？\n那就是使用枚举：\n```java\npublic enum SingleEnum implements Cloneable, Serializable{\nINSTANCE;\n\n    private String name;\n\n    public SingleEnum getInstance(){\n        System.out.println(this == INSTANCE); // true\n        return INSTANCE;\n    }\n\n    public static void main(String[] args) {\n        SingleEnum singleEnum = SingleEnum.INSTANCE;\n        singleEnum.name = \"枚举\";\n        System.out.println(singleEnum.name); // 枚举\n        System.out.println(singleEnum.getInstance());  // true INSTANCE\n    }\n}\n```\n 一个枚举，就算实现双接口，也是无论如何都无法被破坏的。\n攻击代码如下：\n```java\nSystem.out.println(\"枚举实验\");\nSingleEnum singleEnum1 = SingleEnum.INSTANCE;\n\nSystem.out.println(\"直接获取\");\nSingleEnum singleEnum2 = SingleEnum.INSTANCE;\nSystem.out.println(singleEnum1 == singleEnum2); // true\n\nSystem.out.println(\"枚举克隆攻击通过了吗？\");\nSystem.out.println(\"枚举无法克隆\");\n\nSystem.out.println(\"枚举序列化攻击通过了吗？\");\nFile enumTxt = new File(\"enumTest.txt\");\n//序列化\nFileOutputStream fosEnum = new FileOutputStream(enumTxt);\nObjectOutputStream oosEnum = new ObjectOutputStream(fosEnum);\noosEnum.writeObject(singleEnum1);\noosEnum.flush();\noosEnum.close();\nfosEnum.close();\n//反序列化\nFileInputStream fisEnum = new FileInputStream(enumTxt);\nObjectInputStream oisEnum = new ObjectInputStream(fisEnum);\nSingleEnum singleEnum3 = (SingleEnum) oisEnum.readObject();\nfisEnum.close();\noisEnum.close();\nSystem.out.println(singleEnum1 == singleEnum3); // true\n\nSystem.out.println(\"枚举反射攻击通过了吗？\");\nClass enumClass = singleEnum1.getClass();\n/*\njava.lang.InstantiationException\nCaused by: java.lang.NoSuchMethodException: SingleEnum.<init>()\n */\n//stop run\nSingleEnum singleEnum5 = (SingleEnum) enumClass.newInstance();\nSystem.out.println(singleEnum1 == singleEnum5);\n\n//stop run\nConstructor enumConstructor = SingleEnum.class.getConstructor(); // java.lang.NoSuchMethodException\nenumConstructor.setAccessible(true);\n\nSingleEnum singleEnum4 = (SingleEnum) enumConstructor.newInstance();\nSystem.out.println(singleEnum1 == singleEnum4);\n```\n\t\t直接获取：true\n\t\t克隆：枚举无法克隆，没有这样的方法。\n\t\t反射：没有构造函数，会抛出异常。就算你在枚举里加了构造函数，也是一样的。\n\t\t完美。\n\n\n> 参考文献：\n> 1. [深入浅出单实例Singleton设计模式](https://blog.csdn.net/haoel/article/details/4028232)，haoel\n> 2. [克隆、序列化、反射——单例模式防御心得](https://zhuanlan.zhihu.com/p/28491630)，葛尧\n> 3. 《Effective Java第二版》第三条，Joshua Bloch","source":"_posts/单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）.md","raw":"---\ntoc: true\ntitle: 单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）\ndate: 2018-09-05 09:34:05\ntags: [Singleton]\n---\n# 单例模式（三种实现方式，抵御反射、反序列化攻击）\n\n单例模式指仅被实例化一次的类。这个设计模式目的是想在整个系统中只能出现这个类的一个实例。\n\n---\n\n## 三种实现方式：饿汉、懒汉、枚举\n\n在Java1.5发行版之前，实现Singleton有两种方法。这两种方法都要把构造器保持为私有的，并导出公有的静态成员，以便允许客户端访问该类的唯一实例。\n### 懒汉式\n**Version 1.0**\n懒汉式最简单的实现，我们称之为1.0版本\n懒汉式实现单例方法与饿汉之间的区别是：实例只有在被调用的时候才会初始化。\n<!--more-->\n```java\n// version1.1\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n1.0版本存在比较严重的问题，因为这个`singleton`是静态的全局变量，所以在多线程下，如果多个线程同时调用getInstance()方法的话，可能会有多个进程通过`(singleton == null)`检查，从而创建多个实例。熟悉多线程的你一定会说——“我们需要线程互斥或同步”，于是，就有了1.1版本\n**Version 1.1**\nen，1.1版本使用Synchronized关键字，看起来没有问题了吧？\nNO！！！如果有多个线程同时通过`(singleton == null)`检查，还是一样会创建多个实例，只是变成了串行创建而已。\n```java\n//Version 1.1\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton== null) {\n            synchronized (Singleton.class) {\n                singleton= new Singleton();\n            }\n        }\n        return singleton;\n    }\n}\n```\n于是我们继续升级，有了版本1.2.\n**Version 1.2**\n经过修改之后的1.2版本确实不会出现上面的问题。\n但是啊，我们每次调用getInstance()方法要进行同步，创建动作只有一次，但是读取操作也被同步了，效率低到令人发指。改！！！\n```java\n// version1.2\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()  {\n        synchronized (Singleton.class) {\n            if (singleton== null) {\n                singleton= new Singleton();\n            }\n        }\n        return singleton;\n    }\n}\n```\n**Version 1.3**\n还得改，嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。\n```java\n// version 1.3\npublic class Singleton {\n    private static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance() {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：\n1. 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。\n2. 不然，我们就开始同步线程。\n3. 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。\n\n这个版本已经相当漂亮了，但是，如果你认为这个版本大功告成，too young.\n主要在于`singleton = new Singleton()`这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。\n1. 给 singleton 分配内存\n2. 调用 Singleton 的构造函数来初始化成员变量，形成实例\n3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。\n\n对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：\n```java\n// version 1.4\npublic class Singleton {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n使用 volatile 有两个功用：\n1. 这个变量不会在多个线程中存在复本，直接从内存读取。\n2. 这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。\n\n但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。\n### 饿汉式\n```java\npublic class HugrySingleton {\n    private volatile static HugrySingleton INSTANCE = new HugrySingleton();\n    private HugrySingleton(){}\n    public static HugrySingleton getINSTANCE(){\n        return INSTANCE;\n    }\n}\n```\n这种方法最大的问题是——当这个类被加载的时候，new Singleton()语句会被执行，无论getINSTANCE()是否被调用都会初始化这个类。于是，**这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。**\n\n好吧，我们还得绕一下：\n下面的这个1.6版是老版《Effective Java》中推荐的方式。\n```java\n// version 1.6\npublic class Singleton {\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton (){}\n    public static final Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n上面这种方式，仍然使用JVM本身机制（类只会被加载一次，在加载类时初始化了静态变量INSTANCE）保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n### 枚举单例\n从Java 1.5发行版本起，实现Singleton还有第三种方法。只需编写一个包含单个元素的枚举类型：\n```java\npublic enum SingletonEnum {\n    SINGLETON_ENUM;\n}\n```\n通过SingletonEnum.SINGLETON_ENUM来访问，比使用getInstance()方法简单多了。\n默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。\n**这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。**\n\n## 克隆、序列化、反射——单例模式防御\n\n使用**饿汉式**和**懒汉式**方法创建的单例，能够解决同步问题，然而很遗憾，这样并不能真正地实现单例，我有可能通过克隆、序列化、反射机制，来击破单例的模式。\n\n克隆，当你的单例类需要继承Cloneable接口时，就可以通过clone方法获取一个新的对象，那么单例防御失败。\n同理，序列化也可以，或者用反射，也可以。\n```java\n//获取构造函数\nConstructor constructor = SingleTon.class.getDeclaredConstructor();\nconstructor.setAccessible(true);\n```\n这样获取到了构造函数，设置可以访问，然后直接newInstance，就可以获取一个新的实例了。\n真正的单例，应当是可以抵御上述攻击的——\n### 一、抵御Clone攻击\n测试的单例模式实现了Cloneable接口，重写克隆方法：\n```java\n/**\n * 防止克隆攻击\n * @return\n* @throws CloneNotSupportedException\n */\n@Override\nprotected Object clone() throws CloneNotSupportedException {\n    return getInstance();\n}\n```\nSo Easy\n测试代码：\n```java\n// version 1.4\npublic class Singleton implements Cloneable {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    //如果注释此方法，下面的输出为false\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return getInstance();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException {\n        Singleton instance = getInstance();\n        Singleton singleton1 = (Singleton) instance.clone();\n        System.out.println(instance==singleton1);//true\n    }\n}\n```\n### 二、抵御序列化攻击\n单例类实现Serializable接口，然后重写一个方法：\n```java\n/**\n * 防止序列化攻击\n * @return\n*/\nprivate Object readResolve() {\n    return getInstance();\n}\n```\nSo Easy，比攻击的代码简单多了：\n```java\npublic class Singleton implements Serializable {\n    private volatile static Singleton singleton = null;\n    private Singleton(){}\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n    //如果注释此方法，返回结果为false\n    private Object readResolve(){\n        return getInstance();\n    }\n\n    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {\n        Singleton singleton1 = getInstance();\n        System.out.println(\"序列化攻击被阻止了吗？\");\n        File file = new File(\"serializable.txt\");\n        //序列化\n        FileOutputStream fos = new FileOutputStream(file);\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(singleton1);\n        oos.flush();\n        oos.close();\n        fos.close();\n        //反序列化\n        FileInputStream fis = new FileInputStream(file);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Singleton singleTon3 = (Singleton) ois.readObject();\n        ois.close();\n        fis.close();\n        System.out.println(singleton1 == singleTon3); // true\n    }\n}\n```\n### 三、抵御反射攻击\n这里的思路就是加一个flag，判断构造函数是否第一次被调用。\n```java\nprivate static boolean flag = true;\nprivate SingleTon() {\n    if (flag){\nflag = false;\n        //code\n    }else {\n        throw new RuntimeException(\"对象已存在\");\n    }\n}\n```\n注意，这里的flag必须是private的，而且不能有getter setter函数。\n反射攻击的思路是，获取构造函数，然后获取到flag这个域，之后把这个flag置true，然后用构造函数新建。这里要求flag必须有getter setter，不然无法执行，这就是我们防御的思路。\n代码如下：\n```java\npackage cap.ljf.pattern.singleton;\n\nimport java.beans.IntrospectionException;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n\n\n\n/**\n * @author jifang.liu created on 2018/8/13 21:07\n */\n// version 1.4\npublic class Singleton {\n    private volatile static Singleton singleton = null;\n    private static boolean flag = true;\n    private Singleton(){\n        if (flag){\n            flag = false;\n            //code\n        }else {\n            throw new RuntimeException(\"对象已存在\");\n        }\n    }\n\n    public static boolean isFlag() {\n        return flag;\n    }\n\n    public static void setFlag(boolean flag) {\n        Singleton.flag = flag;\n    }\n\n    public static Singleton getInstance()   {\n        if (singleton== null)  {\n            synchronized (Singleton.class) {\n                if (singleton== null)  {\n                    singleton= new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException, IntrospectionException, InvocationTargetException, IllegalAccessException, InstantiationException {\n        Singleton singleton1 = getInstance();\n        System.out.println(\"反射攻击被阻止了吗\");\n        //获取构造函数\n        Constructor constructor = Singleton.class.getDeclaredConstructor();\n        constructor.setAccessible(true);\n\n        //要求该域必须有getter,setter，否则java.beans.IntrospectionException: Method not found: isFlag\n        PropertyDescriptor descriptor = new PropertyDescriptor(\"flag\", Singleton.class);\n\n        //每次新建一个实例前，将flag设置为true\n        descriptor.getWriteMethod().invoke(Singleton.class, true);\n        Singleton singleTon4 = (Singleton) constructor.newInstance();\n        System.out.println(singleton1 == singleTon4);//false\n    }\n}\n```\n\n至此，我们完成的单例模式的代码如下：\n```java\npublic class SingleTon implements Serializable, Cloneable{\n\n    private static final long serialVersionUID = 1L;\n\n    private static volatile SingleTon singleTon;\n\n    private static boolean flag = true;\n\n    private SingleTon() {\n        if (flag){\nflag = false;\n            //code\n        }else {\n            throw new RuntimeException(\"对象已存在\");\n        }\n    }\n\n    public static SingleTon getInstance(){\n        if (singleTon == null){\n            synchronized (SingleTon.class){\n                if (singleTon == null){\nsingleTon = new SingleTon();\n                }\n            }\n        }\n        return singleTon;\n    }\n\n/**\n     * 防止克隆攻击\n     * @return\n* @throws CloneNotSupportedException\n     */\n@Override\n    protected Object clone() throws CloneNotSupportedException {\n        return getInstance();\n    }\n\n//    public static boolean getFlag() {\n//        return flag;\n//    }\n//\n//    public static void setFlag(boolean flag) {\n//        SingleTon.flag = flag;\n//    }\n\n/**\n     * 防止序列化攻击\n     * @return\n*/\nprivate Object readResolve() {\n        return getInstance();\n    }\n｝\n```\n真是太麻烦了，有没有简单的方法呢？\n那就是使用枚举：\n```java\npublic enum SingleEnum implements Cloneable, Serializable{\nINSTANCE;\n\n    private String name;\n\n    public SingleEnum getInstance(){\n        System.out.println(this == INSTANCE); // true\n        return INSTANCE;\n    }\n\n    public static void main(String[] args) {\n        SingleEnum singleEnum = SingleEnum.INSTANCE;\n        singleEnum.name = \"枚举\";\n        System.out.println(singleEnum.name); // 枚举\n        System.out.println(singleEnum.getInstance());  // true INSTANCE\n    }\n}\n```\n 一个枚举，就算实现双接口，也是无论如何都无法被破坏的。\n攻击代码如下：\n```java\nSystem.out.println(\"枚举实验\");\nSingleEnum singleEnum1 = SingleEnum.INSTANCE;\n\nSystem.out.println(\"直接获取\");\nSingleEnum singleEnum2 = SingleEnum.INSTANCE;\nSystem.out.println(singleEnum1 == singleEnum2); // true\n\nSystem.out.println(\"枚举克隆攻击通过了吗？\");\nSystem.out.println(\"枚举无法克隆\");\n\nSystem.out.println(\"枚举序列化攻击通过了吗？\");\nFile enumTxt = new File(\"enumTest.txt\");\n//序列化\nFileOutputStream fosEnum = new FileOutputStream(enumTxt);\nObjectOutputStream oosEnum = new ObjectOutputStream(fosEnum);\noosEnum.writeObject(singleEnum1);\noosEnum.flush();\noosEnum.close();\nfosEnum.close();\n//反序列化\nFileInputStream fisEnum = new FileInputStream(enumTxt);\nObjectInputStream oisEnum = new ObjectInputStream(fisEnum);\nSingleEnum singleEnum3 = (SingleEnum) oisEnum.readObject();\nfisEnum.close();\noisEnum.close();\nSystem.out.println(singleEnum1 == singleEnum3); // true\n\nSystem.out.println(\"枚举反射攻击通过了吗？\");\nClass enumClass = singleEnum1.getClass();\n/*\njava.lang.InstantiationException\nCaused by: java.lang.NoSuchMethodException: SingleEnum.<init>()\n */\n//stop run\nSingleEnum singleEnum5 = (SingleEnum) enumClass.newInstance();\nSystem.out.println(singleEnum1 == singleEnum5);\n\n//stop run\nConstructor enumConstructor = SingleEnum.class.getConstructor(); // java.lang.NoSuchMethodException\nenumConstructor.setAccessible(true);\n\nSingleEnum singleEnum4 = (SingleEnum) enumConstructor.newInstance();\nSystem.out.println(singleEnum1 == singleEnum4);\n```\n\t\t直接获取：true\n\t\t克隆：枚举无法克隆，没有这样的方法。\n\t\t反射：没有构造函数，会抛出异常。就算你在枚举里加了构造函数，也是一样的。\n\t\t完美。\n\n\n> 参考文献：\n> 1. [深入浅出单实例Singleton设计模式](https://blog.csdn.net/haoel/article/details/4028232)，haoel\n> 2. [克隆、序列化、反射——单例模式防御心得](https://zhuanlan.zhihu.com/p/28491630)，葛尧\n> 3. 《Effective Java第二版》第三条，Joshua Bloch","slug":"单例模式（三种实现方式，抵御反射、反序列化、克隆攻击）","published":1,"updated":"2018-09-05T01:38:34.984Z","_id":"cjloh3e6i00466k15mmrhsnwh","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"单例模式（三种实现方式，抵御反射、反序列化攻击）\"><a href=\"#单例模式（三种实现方式，抵御反射、反序列化攻击）\" class=\"headerlink\" title=\"单例模式（三种实现方式，抵御反射、反序列化攻击）\"></a>单例模式（三种实现方式，抵御反射、反序列化攻击）</h1><p>单例模式指仅被实例化一次的类。这个设计模式目的是想在整个系统中只能出现这个类的一个实例。</p>\n<hr>\n<h2 id=\"三种实现方式：饿汉、懒汉、枚举\"><a href=\"#三种实现方式：饿汉、懒汉、枚举\" class=\"headerlink\" title=\"三种实现方式：饿汉、懒汉、枚举\"></a>三种实现方式：饿汉、懒汉、枚举</h2><p>在Java1.5发行版之前，实现Singleton有两种方法。这两种方法都要把构造器保持为私有的，并导出公有的静态成员，以便允许客户端访问该类的唯一实例。</p>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><p><strong>Version 1.0</strong><br>懒汉式最简单的实现，我们称之为1.0版本<br>懒汉式实现单例方法与饿汉之间的区别是：实例只有在被调用的时候才会初始化。<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.0版本存在比较严重的问题，因为这个<code>singleton</code>是静态的全局变量，所以在多线程下，如果多个线程同时调用getInstance()方法的话，可能会有多个进程通过<code>(singleton == null)</code>检查，从而创建多个实例。熟悉多线程的你一定会说——“我们需要线程互斥或同步”，于是，就有了1.1版本<br><strong>Version 1.1</strong><br>en，1.1版本使用Synchronized关键字，看起来没有问题了吧？<br>NO！！！如果有多个线程同时通过<code>(singleton == null)</code>检查，还是一样会创建多个实例，只是变成了串行创建而已。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Version 1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>于是我们继续升级，有了版本1.2.<br><strong>Version 1.2</strong><br>经过修改之后的1.2版本确实不会出现上面的问题。<br>但是啊，我们每次调用getInstance()方法要进行同步，创建动作只有一次，但是读取操作也被同步了，效率低到令人发指。改！！！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version1.2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Version 1.3</strong><br>还得改，嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：</p>\n<ol>\n<li>第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。</li>\n<li>不然，我们就开始同步线程。</li>\n<li>第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。</li>\n</ol>\n<p>这个版本已经相当漂亮了，但是，如果你认为这个版本大功告成，too young.<br>主要在于<code>singleton = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>\n<ol>\n<li>给 singleton 分配内存</li>\n<li>调用 Singleton 的构造函数来初始化成员变量，形成实例</li>\n<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）</li>\n</ol>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n<p>对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 volatile 有两个功用：</p>\n<ol>\n<li>这个变量不会在多个线程中存在复本，直接从内存读取。</li>\n<li>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</li>\n</ol>\n<p>但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。</p>\n<h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HugrySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> HugrySingleton INSTANCE = <span class=\"keyword\">new</span> HugrySingleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HugrySingleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HugrySingleton <span class=\"title\">getINSTANCE</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法最大的问题是——当这个类被加载的时候，new Singleton()语句会被执行，无论getINSTANCE()是否被调用都会初始化这个类。于是，<strong>这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。</strong></p>\n<p>好吧，我们还得绕一下：<br>下面的这个1.6版是老版《Effective Java》中推荐的方式。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.6</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这种方式，仍然使用JVM本身机制（类只会被加载一次，在加载类时初始化了静态变量INSTANCE）保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n<h3 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h3><p>从Java 1.5发行版本起，实现Singleton还有第三种方法。只需编写一个包含单个元素的枚举类型：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonEnum &#123;</span><br><span class=\"line\">    SINGLETON_ENUM;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过SingletonEnum.SINGLETON_ENUM来访问，比使用getInstance()方法简单多了。<br>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。<br><strong>这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。</strong></p>\n<h2 id=\"克隆、序列化、反射——单例模式防御\"><a href=\"#克隆、序列化、反射——单例模式防御\" class=\"headerlink\" title=\"克隆、序列化、反射——单例模式防御\"></a>克隆、序列化、反射——单例模式防御</h2><p>使用<strong>饿汉式</strong>和<strong>懒汉式</strong>方法创建的单例，能够解决同步问题，然而很遗憾，这样并不能真正地实现单例，我有可能通过克隆、序列化、反射机制，来击破单例的模式。</p>\n<p>克隆，当你的单例类需要继承Cloneable接口时，就可以通过clone方法获取一个新的对象，那么单例防御失败。<br>同理，序列化也可以，或者用反射，也可以。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取构造函数</span></span><br><span class=\"line\">Constructor constructor = SingleTon.class.getDeclaredConstructor();</span><br><span class=\"line\">constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样获取到了构造函数，设置可以访问，然后直接newInstance，就可以获取一个新的实例了。<br>真正的单例，应当是可以抵御上述攻击的——</p>\n<h3 id=\"一、抵御Clone攻击\"><a href=\"#一、抵御Clone攻击\" class=\"headerlink\" title=\"一、抵御Clone攻击\"></a>一、抵御Clone攻击</h3><p>测试的单例模式实现了Cloneable接口，重写克隆方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 防止克隆攻击</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>So Easy<br>测试代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果注释此方法，下面的输出为false</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        Singleton instance = getInstance();</span><br><span class=\"line\">        Singleton singleton1 = (Singleton) instance.clone();</span><br><span class=\"line\">        System.out.println(instance==singleton1);<span class=\"comment\">//true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、抵御序列化攻击\"><a href=\"#二、抵御序列化攻击\" class=\"headerlink\" title=\"二、抵御序列化攻击\"></a>二、抵御序列化攻击</h3><p>单例类实现Serializable接口，然后重写一个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 防止序列化攻击</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>So Easy，比攻击的代码简单多了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果注释此方法，返回结果为false</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Singleton singleton1 = getInstance();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"序列化攻击被阻止了吗？\"</span>);</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"serializable.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//序列化</span></span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        ObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(fos);</span><br><span class=\"line\">        oos.writeObject(singleton1);</span><br><span class=\"line\">        oos.flush();</span><br><span class=\"line\">        oos.close();</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">        <span class=\"comment\">//反序列化</span></span><br><span class=\"line\">        FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(fis);</span><br><span class=\"line\">        Singleton singleTon3 = (Singleton) ois.readObject();</span><br><span class=\"line\">        ois.close();</span><br><span class=\"line\">        fis.close();</span><br><span class=\"line\">        System.out.println(singleton1 == singleTon3); <span class=\"comment\">// true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、抵御反射攻击\"><a href=\"#三、抵御反射攻击\" class=\"headerlink\" title=\"三、抵御反射攻击\"></a>三、抵御反射攻击</h3><p>这里的思路就是加一个flag，判断构造函数是否第一次被调用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleTon</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，这里的flag必须是private的，而且不能有getter setter函数。<br>反射攻击的思路是，获取构造函数，然后获取到flag这个域，之后把这个flag置true，然后用构造函数新建。这里要求flag必须有getter setter，不然无法执行，这就是我们防御的思路。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cap.ljf.pattern.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.beans.IntrospectionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.beans.PropertyDescriptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Constructor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> jifang.liu created on 2018/8/13 21:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">            flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//code</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isFlag</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setFlag</span><span class=\"params\">(<span class=\"keyword\">boolean</span> flag)</span> </span>&#123;</span><br><span class=\"line\">        Singleton.flag = flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchMethodException, IntrospectionException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class=\"line\">        Singleton singleton1 = getInstance();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"反射攻击被阻止了吗\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取构造函数</span></span><br><span class=\"line\">        Constructor constructor = Singleton.class.getDeclaredConstructor();</span><br><span class=\"line\">        constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//要求该域必须有getter,setter，否则java.beans.IntrospectionException: Method not found: isFlag</span></span><br><span class=\"line\">        PropertyDescriptor descriptor = <span class=\"keyword\">new</span> PropertyDescriptor(<span class=\"string\">\"flag\"</span>, Singleton.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//每次新建一个实例前，将flag设置为true</span></span><br><span class=\"line\">        descriptor.getWriteMethod().invoke(Singleton.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Singleton singleTon4 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">        System.out.println(singleton1 == singleTon4);<span class=\"comment\">//false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们完成的单例模式的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleTon</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingleTon singleTon;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleTon</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//code</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleTon <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleTon == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingleTon.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleTon == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">singleTon = <span class=\"keyword\">new</span> SingleTon();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleTon;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 防止克隆攻击</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    public static boolean getFlag() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        return flag;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//    public static void setFlag(boolean flag) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        SingleTon.flag = flag;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 防止序列化攻击</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure></p>\n<p>真是太麻烦了，有没有简单的方法呢？<br>那就是使用枚举：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingleEnum implements Cloneable, Serializable&#123;</span><br><span class=\"line\">INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SingleEnum <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span> == INSTANCE); <span class=\"comment\">// true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SingleEnum singleEnum = SingleEnum.INSTANCE;</span><br><span class=\"line\">        singleEnum.name = <span class=\"string\">\"枚举\"</span>;</span><br><span class=\"line\">        System.out.println(singleEnum.name); <span class=\"comment\">// 枚举</span></span><br><span class=\"line\">        System.out.println(singleEnum.getInstance());  <span class=\"comment\">// true INSTANCE</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 一个枚举，就算实现双接口，也是无论如何都无法被破坏的。<br>攻击代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">\"枚举实验\"</span>);</span><br><span class=\"line\">SingleEnum singleEnum1 = SingleEnum.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"直接获取\"</span>);</span><br><span class=\"line\">SingleEnum singleEnum2 = SingleEnum.INSTANCE;</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum2); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举克隆攻击通过了吗？\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举无法克隆\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举序列化攻击通过了吗？\"</span>);</span><br><span class=\"line\">File enumTxt = <span class=\"keyword\">new</span> File(<span class=\"string\">\"enumTest.txt\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//序列化</span></span><br><span class=\"line\">FileOutputStream fosEnum = <span class=\"keyword\">new</span> FileOutputStream(enumTxt);</span><br><span class=\"line\">ObjectOutputStream oosEnum = <span class=\"keyword\">new</span> ObjectOutputStream(fosEnum);</span><br><span class=\"line\">oosEnum.writeObject(singleEnum1);</span><br><span class=\"line\">oosEnum.flush();</span><br><span class=\"line\">oosEnum.close();</span><br><span class=\"line\">fosEnum.close();</span><br><span class=\"line\"><span class=\"comment\">//反序列化</span></span><br><span class=\"line\">FileInputStream fisEnum = <span class=\"keyword\">new</span> FileInputStream(enumTxt);</span><br><span class=\"line\">ObjectInputStream oisEnum = <span class=\"keyword\">new</span> ObjectInputStream(fisEnum);</span><br><span class=\"line\">SingleEnum singleEnum3 = (SingleEnum) oisEnum.readObject();</span><br><span class=\"line\">fisEnum.close();</span><br><span class=\"line\">oisEnum.close();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum3); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举反射攻击通过了吗？\"</span>);</span><br><span class=\"line\">Class enumClass = singleEnum1.getClass();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">java.lang.InstantiationException</span></span><br><span class=\"line\"><span class=\"comment\">Caused by: java.lang.NoSuchMethodException: SingleEnum.&lt;init&gt;()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//stop run</span></span><br><span class=\"line\">SingleEnum singleEnum5 = (SingleEnum) enumClass.newInstance();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum5);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//stop run</span></span><br><span class=\"line\">Constructor enumConstructor = SingleEnum.class.getConstructor(); <span class=\"comment\">// java.lang.NoSuchMethodException</span></span><br><span class=\"line\">enumConstructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">SingleEnum singleEnum4 = (SingleEnum) enumConstructor.newInstance();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum4);</span><br></pre></td></tr></table></figure></p>\n<pre><code>直接获取：true\n克隆：枚举无法克隆，没有这样的方法。\n反射：没有构造函数，会抛出异常。就算你在枚举里加了构造函数，也是一样的。\n完美。\n</code></pre><blockquote>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/4028232\" target=\"_blank\" rel=\"noopener\">深入浅出单实例Singleton设计模式</a>，haoel</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28491630\" target=\"_blank\" rel=\"noopener\">克隆、序列化、反射——单例模式防御心得</a>，葛尧</li>\n<li>《Effective Java第二版》第三条，Joshua Bloch</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"单例模式（三种实现方式，抵御反射、反序列化攻击）\"><a href=\"#单例模式（三种实现方式，抵御反射、反序列化攻击）\" class=\"headerlink\" title=\"单例模式（三种实现方式，抵御反射、反序列化攻击）\"></a>单例模式（三种实现方式，抵御反射、反序列化攻击）</h1><p>单例模式指仅被实例化一次的类。这个设计模式目的是想在整个系统中只能出现这个类的一个实例。</p>\n<hr>\n<h2 id=\"三种实现方式：饿汉、懒汉、枚举\"><a href=\"#三种实现方式：饿汉、懒汉、枚举\" class=\"headerlink\" title=\"三种实现方式：饿汉、懒汉、枚举\"></a>三种实现方式：饿汉、懒汉、枚举</h2><p>在Java1.5发行版之前，实现Singleton有两种方法。这两种方法都要把构造器保持为私有的，并导出公有的静态成员，以便允许客户端访问该类的唯一实例。</p>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><p><strong>Version 1.0</strong><br>懒汉式最简单的实现，我们称之为1.0版本<br>懒汉式实现单例方法与饿汉之间的区别是：实例只有在被调用的时候才会初始化。<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.0版本存在比较严重的问题，因为这个<code>singleton</code>是静态的全局变量，所以在多线程下，如果多个线程同时调用getInstance()方法的话，可能会有多个进程通过<code>(singleton == null)</code>检查，从而创建多个实例。熟悉多线程的你一定会说——“我们需要线程互斥或同步”，于是，就有了1.1版本<br><strong>Version 1.1</strong><br>en，1.1版本使用Synchronized关键字，看起来没有问题了吧？<br>NO！！！如果有多个线程同时通过<code>(singleton == null)</code>检查，还是一样会创建多个实例，只是变成了串行创建而已。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Version 1.1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>于是我们继续升级，有了版本1.2.<br><strong>Version 1.2</strong><br>经过修改之后的1.2版本确实不会出现上面的问题。<br>但是啊，我们每次调用getInstance()方法要进行同步，创建动作只有一次，但是读取操作也被同步了，效率低到令人发指。改！！！<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version1.2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Version 1.3</strong><br>还得改，嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：</p>\n<ol>\n<li>第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。</li>\n<li>不然，我们就开始同步线程。</li>\n<li>第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。</li>\n</ol>\n<p>这个版本已经相当漂亮了，但是，如果你认为这个版本大功告成，too young.<br>主要在于<code>singleton = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>\n<ol>\n<li>给 singleton 分配内存</li>\n<li>调用 Singleton 的构造函数来初始化成员变量，形成实例</li>\n<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）</li>\n</ol>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>\n<p>对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 volatile 有两个功用：</p>\n<ol>\n<li>这个变量不会在多个线程中存在复本，直接从内存读取。</li>\n<li>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</li>\n</ol>\n<p>但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。</p>\n<h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HugrySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> HugrySingleton INSTANCE = <span class=\"keyword\">new</span> HugrySingleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HugrySingleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HugrySingleton <span class=\"title\">getINSTANCE</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法最大的问题是——当这个类被加载的时候，new Singleton()语句会被执行，无论getINSTANCE()是否被调用都会初始化这个类。于是，<strong>这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。</strong></p>\n<p>好吧，我们还得绕一下：<br>下面的这个1.6版是老版《Effective Java》中推荐的方式。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.6</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面这种方式，仍然使用JVM本身机制（类只会被加载一次，在加载类时初始化了静态变量INSTANCE）保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n<h3 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h3><p>从Java 1.5发行版本起，实现Singleton还有第三种方法。只需编写一个包含单个元素的枚举类型：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonEnum &#123;</span><br><span class=\"line\">    SINGLETON_ENUM;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过SingletonEnum.SINGLETON_ENUM来访问，比使用getInstance()方法简单多了。<br>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。<br><strong>这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。</strong></p>\n<h2 id=\"克隆、序列化、反射——单例模式防御\"><a href=\"#克隆、序列化、反射——单例模式防御\" class=\"headerlink\" title=\"克隆、序列化、反射——单例模式防御\"></a>克隆、序列化、反射——单例模式防御</h2><p>使用<strong>饿汉式</strong>和<strong>懒汉式</strong>方法创建的单例，能够解决同步问题，然而很遗憾，这样并不能真正地实现单例，我有可能通过克隆、序列化、反射机制，来击破单例的模式。</p>\n<p>克隆，当你的单例类需要继承Cloneable接口时，就可以通过clone方法获取一个新的对象，那么单例防御失败。<br>同理，序列化也可以，或者用反射，也可以。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取构造函数</span></span><br><span class=\"line\">Constructor constructor = SingleTon.class.getDeclaredConstructor();</span><br><span class=\"line\">constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样获取到了构造函数，设置可以访问，然后直接newInstance，就可以获取一个新的实例了。<br>真正的单例，应当是可以抵御上述攻击的——</p>\n<h3 id=\"一、抵御Clone攻击\"><a href=\"#一、抵御Clone攻击\" class=\"headerlink\" title=\"一、抵御Clone攻击\"></a>一、抵御Clone攻击</h3><p>测试的单例模式实现了Cloneable接口，重写克隆方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 防止克隆攻击</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>So Easy<br>测试代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果注释此方法，下面的输出为false</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        Singleton instance = getInstance();</span><br><span class=\"line\">        Singleton singleton1 = (Singleton) instance.clone();</span><br><span class=\"line\">        System.out.println(instance==singleton1);<span class=\"comment\">//true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二、抵御序列化攻击\"><a href=\"#二、抵御序列化攻击\" class=\"headerlink\" title=\"二、抵御序列化攻击\"></a>二、抵御序列化攻击</h3><p>单例类实现Serializable接口，然后重写一个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 防止序列化攻击</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>So Easy，比攻击的代码简单多了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果注释此方法，返回结果为false</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        Singleton singleton1 = getInstance();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"序列化攻击被阻止了吗？\"</span>);</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"serializable.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//序列化</span></span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        ObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(fos);</span><br><span class=\"line\">        oos.writeObject(singleton1);</span><br><span class=\"line\">        oos.flush();</span><br><span class=\"line\">        oos.close();</span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">        <span class=\"comment\">//反序列化</span></span><br><span class=\"line\">        FileInputStream fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(fis);</span><br><span class=\"line\">        Singleton singleTon3 = (Singleton) ois.readObject();</span><br><span class=\"line\">        ois.close();</span><br><span class=\"line\">        fis.close();</span><br><span class=\"line\">        System.out.println(singleton1 == singleTon3); <span class=\"comment\">// true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三、抵御反射攻击\"><a href=\"#三、抵御反射攻击\" class=\"headerlink\" title=\"三、抵御反射攻击\"></a>三、抵御反射攻击</h3><p>这里的思路就是加一个flag，判断构造函数是否第一次被调用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleTon</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//code</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，这里的flag必须是private的，而且不能有getter setter函数。<br>反射攻击的思路是，获取构造函数，然后获取到flag这个域，之后把这个flag置true，然后用构造函数新建。这里要求flag必须有getter setter，不然无法执行，这就是我们防御的思路。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cap.ljf.pattern.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.beans.IntrospectionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.beans.PropertyDescriptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Constructor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> jifang.liu created on 2018/8/13 21:07</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// version 1.4</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">            flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//code</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isFlag</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setFlag</span><span class=\"params\">(<span class=\"keyword\">boolean</span> flag)</span> </span>&#123;</span><br><span class=\"line\">        Singleton.flag = flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span>   </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton== <span class=\"keyword\">null</span>)  &#123;</span><br><span class=\"line\">                    singleton= <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchMethodException, IntrospectionException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class=\"line\">        Singleton singleton1 = getInstance();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"反射攻击被阻止了吗\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取构造函数</span></span><br><span class=\"line\">        Constructor constructor = Singleton.class.getDeclaredConstructor();</span><br><span class=\"line\">        constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//要求该域必须有getter,setter，否则java.beans.IntrospectionException: Method not found: isFlag</span></span><br><span class=\"line\">        PropertyDescriptor descriptor = <span class=\"keyword\">new</span> PropertyDescriptor(<span class=\"string\">\"flag\"</span>, Singleton.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//每次新建一个实例前，将flag设置为true</span></span><br><span class=\"line\">        descriptor.getWriteMethod().invoke(Singleton.class, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Singleton singleTon4 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">        System.out.println(singleton1 == singleTon4);<span class=\"comment\">//false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们完成的单例模式的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleTon</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingleTon singleTon;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingleTon</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//code</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"对象已存在\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingleTon <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleTon == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingleTon.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleTon == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">singleTon = <span class=\"keyword\">new</span> SingleTon();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleTon;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 防止克隆攻击</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@throws</span> CloneNotSupportedException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    public static boolean getFlag() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        return flag;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//    public static void setFlag(boolean flag) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        SingleTon.flag = flag;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 防止序列化攻击</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure></p>\n<p>真是太麻烦了，有没有简单的方法呢？<br>那就是使用枚举：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingleEnum implements Cloneable, Serializable&#123;</span><br><span class=\"line\">INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SingleEnum <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span> == INSTANCE); <span class=\"comment\">// true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SingleEnum singleEnum = SingleEnum.INSTANCE;</span><br><span class=\"line\">        singleEnum.name = <span class=\"string\">\"枚举\"</span>;</span><br><span class=\"line\">        System.out.println(singleEnum.name); <span class=\"comment\">// 枚举</span></span><br><span class=\"line\">        System.out.println(singleEnum.getInstance());  <span class=\"comment\">// true INSTANCE</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 一个枚举，就算实现双接口，也是无论如何都无法被破坏的。<br>攻击代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">\"枚举实验\"</span>);</span><br><span class=\"line\">SingleEnum singleEnum1 = SingleEnum.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"直接获取\"</span>);</span><br><span class=\"line\">SingleEnum singleEnum2 = SingleEnum.INSTANCE;</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum2); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举克隆攻击通过了吗？\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举无法克隆\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举序列化攻击通过了吗？\"</span>);</span><br><span class=\"line\">File enumTxt = <span class=\"keyword\">new</span> File(<span class=\"string\">\"enumTest.txt\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//序列化</span></span><br><span class=\"line\">FileOutputStream fosEnum = <span class=\"keyword\">new</span> FileOutputStream(enumTxt);</span><br><span class=\"line\">ObjectOutputStream oosEnum = <span class=\"keyword\">new</span> ObjectOutputStream(fosEnum);</span><br><span class=\"line\">oosEnum.writeObject(singleEnum1);</span><br><span class=\"line\">oosEnum.flush();</span><br><span class=\"line\">oosEnum.close();</span><br><span class=\"line\">fosEnum.close();</span><br><span class=\"line\"><span class=\"comment\">//反序列化</span></span><br><span class=\"line\">FileInputStream fisEnum = <span class=\"keyword\">new</span> FileInputStream(enumTxt);</span><br><span class=\"line\">ObjectInputStream oisEnum = <span class=\"keyword\">new</span> ObjectInputStream(fisEnum);</span><br><span class=\"line\">SingleEnum singleEnum3 = (SingleEnum) oisEnum.readObject();</span><br><span class=\"line\">fisEnum.close();</span><br><span class=\"line\">oisEnum.close();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum3); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"枚举反射攻击通过了吗？\"</span>);</span><br><span class=\"line\">Class enumClass = singleEnum1.getClass();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">java.lang.InstantiationException</span></span><br><span class=\"line\"><span class=\"comment\">Caused by: java.lang.NoSuchMethodException: SingleEnum.&lt;init&gt;()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//stop run</span></span><br><span class=\"line\">SingleEnum singleEnum5 = (SingleEnum) enumClass.newInstance();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum5);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//stop run</span></span><br><span class=\"line\">Constructor enumConstructor = SingleEnum.class.getConstructor(); <span class=\"comment\">// java.lang.NoSuchMethodException</span></span><br><span class=\"line\">enumConstructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">SingleEnum singleEnum4 = (SingleEnum) enumConstructor.newInstance();</span><br><span class=\"line\">System.out.println(singleEnum1 == singleEnum4);</span><br></pre></td></tr></table></figure></p>\n<pre><code>直接获取：true\n克隆：枚举无法克隆，没有这样的方法。\n反射：没有构造函数，会抛出异常。就算你在枚举里加了构造函数，也是一样的。\n完美。\n</code></pre><blockquote>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/haoel/article/details/4028232\" target=\"_blank\" rel=\"noopener\">深入浅出单实例Singleton设计模式</a>，haoel</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28491630\" target=\"_blank\" rel=\"noopener\">克隆、序列化、反射——单例模式防御心得</a>，葛尧</li>\n<li>《Effective Java第二版》第三条，Joshua Bloch</li>\n</ol>\n</blockquote>"},{"toc":true,"title":"基于scrapy分布式新闻评论爬虫","date":"2018-03-28T13:00:04.000Z","_content":"\n\n我的毕设主题是：时事新闻评论分析软件的设计与实现。要分析评论，就需要评论数据，于是就写起了爬虫。\n\n<!--more-->\n项目仓库：[NewsCommentsSpider](https://github.com/cap-ljf/NewsCommentsSpider)\n如果感觉对您有帮助的话给个小小的`star`吧，哈哈。\n\n对于爬虫，搜索得到的文章大部分都是python爬虫，“python有天然的爬虫优势”，虽然我也讲不清python爬虫有什么天然的优势，可能在html文件解析、json解析、有大量成熟好用的工具包。于是我开始学习`scrapy`框架，上手很简单，而且官方文档比较详细。\n\n[Scrapy入门教程](http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html)\n\n#### 开发环境\n系统：`Ubuntu16.10`\n开发软件：`Pycharm 2017.3.3 Professinal Edition`\n工具包：\n```\npython 3.5\npip 9.0.1\nscrapy \nbeautifulsoup4 4.5.1\nipython 6.2.1\nlxml 4.1.1\nPyMySQL3 0.5\nredis 2.10.6\nrequests 2.18.4\nScrapy 1.5.0\nscrapy-redis 0.6.8\nselenium 2.48.0 \n```\n### 1. Scrapy入门，搭建NewsCommentsSpider项目\n#### 安装scrapy\n我的系统是`Ubuntu16.10`，使用下列命令：\n`pip install scrapy`\n#### 创建项目\n`scrapy startproject NewsCommentsSpider`\n*下面一段解释来自scrapy中文官网*\n该命令将会创建包含下列内容的`NewsCommentsSpider`目录：\n```\nNewsCommentsSpider/\n    scrapy.cfg\n    NewsCommentsSpider/\n        __init__.py\n        items.py\n        pipelines.py\n        settings.py\n        spiders/\n            __init__.py\n            ...\n```\n这些文件分别是:\n- `scrapy.cfg`: 项目的配置文件\n- `NewsCommentsSpider`/: 该项目的python模块。之后您将在此加入代码。\n- `NewsCommentsSpider/items.py`: 项目中的item文件.\n- `NewsCommentsSpider/pipelines.py`: 项目中的pipelines文件.\n- `NewsCommentsSpider/settings.py`: 项目的设置文件.\n- `NewsCommentsSpider/spiders/`: 放置spider代码的目录.\n\n#### 数据库设计\nOK，到这儿我们就已经成功搭建好了scrapy框架。\n现在来看我毕设的题目：\n```\n题目：基于Python的时事新闻评论分析软件的设计与实现\n主要数据：凤凰网、今日头条、网易新闻、微博四大平台的新闻评论。（一开始我是准备爬知乎和微信公众号的评论的，但是知乎问题的回答一般都很长，而且表达的主观情绪较少，一般都是摆数据讲道理，不太好分析；而微信公众号的评论接口我一直没找到，只好作罢，如果您有关于微信公众号文章评论接口相关的信息或想法，恳求告知：邮箱1579461369@qq.com）\n```\n针对上述需求，我设计了两个表：\n1. 文章表：（**article**）新闻文章或微博信息\n2. 评论表：（**comment**）文章评论相关信息\n\n请看：\n【**article**】\n| Field      |    Type | Null  | Key | Default | Extra |\n| :-------- | --------:| :--: |\n| id  | int(11) |  NO   | PRI |  | auto_increment |\n| keyword  | varchar(20) |  NO   | MUL |  |  |\n| url  | varchar(150) |  NO   |  |  |  |\n| author  | varchar(50) |  YES   |  |  |  |\n| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\n| comment_count  | int(11) |  NO   |  |  |  |\n\n【**comment**】\n| Field      |    Type | Null  | Key | Default | Extra |\n| :-------- | --------:| :--: |\n| id  | int(11) |  NO   | PRI |  | auto_increment |\n| url  | varchar(150) |  NO   | MUL |  |  |\n| author  | varchar(50) |  YES   |  |  |  |\n| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\n| comment  | varchar(1000) |  NO   |  |  |  |\n| praise  | smallint(6) |  YES   |  |  |  |\n\n**SQL语句**\n第一次设计的时候`author`字段长度设计的比较小，导致在测试网易新闻评论爬取的时候出现异常，于是增加了`author`字段的大小。\n```sql\nCREATE DATABASE minsheng;\nUSE minsheng;\nCREATE TABLE article(\n  id INT NOT NULL AUTO_INCREMENT COMMENT '主键',\n  keyword varchar(20) NOT NULL COMMENT '关键词',\n  url VARCHAR(150) NOT NULL UNIQUE COMMENT '文章url',\n  author VARCHAR(20) COMMENT '作者',\n  create_time TIMESTAMP COMMENT '文章创建时间',\n  comment_count int NOT NULL COMMENT '评论数',\n  PRIMARY KEY (id),\n  INDEX idx_keyword (keyword)\n)ENGINE = InnoDB CHARSET = 'utf8' COMMENT '文章表';\nCREATE TABLE comment(\n  id INT NOT NULL AUTO_INCREMENT COMMENT '主键',\n  url VARCHAR(150) NOT NULL COMMENT '文章链接',\n  comment VARCHAR(1000) NOT NULL COMMENT '评论',\n  author VARCHAR(20) COMMENT '评论者',\n  praise SMALLINT COMMENT '点赞数',\n  create_time TIMESTAMP COMMENT '评论时间',\n  PRIMARY KEY (id),\n  INDEX idx_url (url)\n)ENGINE = InnoDB CHARSET = 'utf8mb4' COMMENT '评论表';\nALTER TABLE comment MODIFY COLUMN author VARCHAR(50);\nALTER TABLE article MODIFY COLUMN author VARCHAR(50);\n```\n#### 定义Item\n既然已经有了数据库表，我们就可以知道我们需要那些数据，就可以编写`Item`类。\n```python\nimport scrapy\nfrom scrapy import Field\n\nclass CommentItem(scrapy.Item):\n    # 文章链接\n    url = Field()\n    # 评论内容\n    comment = Field()\n    # 评论者\n    author = Field()\n    # 点赞数\n    praise = Field()\n    # 评论时间\n    create_time = Field()\n```\n#### Item Pipeline，使用Mysql数据库存储数据\n编写你自己的item pipeline很简单，每个item pipiline组件是一个独立的Python类，同时必须实现`process_item`方法。\n这里我们使用`pymysql`包操作mysql数据库。首先在`pipeline`初始化时创建数据库连接，并获取`cursor`。然后在`process_item`方法中执行增删改查操作。最后**关闭连接**，一定要记得关闭连接，否则会产生大量的连接以及游标，最后导致内存泄漏。\n废话少说，上代码：\n```python\n# -*- coding: utf-8 -*-\nimport logging\n\nimport pymysql\nfrom datetime import datetime\n\nfrom NewsCommentsSpider.settings import *\n\n\nclass MySQLPipeline(object):\n    # 定义数据存储方式\n    def __init__(self):\n        try:\n            self.connect = pymysql.connect(\n                host=MYSQL_HOST,\n                db=MYSQL_DBNAME,\n                user=MYSQL_USER,\n                passwd=MYSQL_PASSWD,\n                charset='utf8',\n                use_unicode=True\n            )\n            # 通过cursor执行增删改查\n            self.cursor = self.connect.cursor()\n            logging.debug('mysql conn success!')\n        except Exception as error:\n            logging.error('mysql conn error!:', error)\n\n    def process_item(self, item, spider):\n        try:\n            self.cursor.execute(\n                \"\"\"insert into comment(url, comment, author, praise, create_time)\n                                  value (%s, %s, %s, %s, %s)\"\"\",\n                (item['url'],\n                 item['comment'],\n                 item['author'],\n                 item['praise'],\n                 # item['create_time']\n                 datetime.fromtimestamp(item['create_time'])\n                 )\n            )\n            # 提交sql语句\n            self.connect.commit()\n        except Exception as error:\n            # 异常打印日志\n            logging.error(\"数据库插入异常:\", error)\n\n        return item\n\n    def __del__(self):\n        try:\n            # if self.cursor:\n            #     self.cursor.close()\n            if self.connect:\n                self.connect.close()\n        except Exception as error:\n            logging.error(\"conn or cursor 关闭失败:\", error)\n```\n代码中我注释了这样两段代码\n1. `item['create_time']`，如果直接使用`timestamp`执行`insert`。这里出现异常：\n```bash\nMessage: '数据库插入异常:'\nArguments: (InternalError(InternalError(1292, \"Incorrect datetime value: '1522110959' for column 'create_time' at row 1\"),),)\n```\n我也不知道为什么，python操作mysql插入数据库为什么会出现这种情况，后来我将时间戳改成`datetime`类型就没问题了。\n2. `__del__()`，在这个函数我进行了`cursor`和`connect`的关闭，但是不知道为什么游标一直关不掉，debug信息指示：\n```\nException ignored in: <bound method Cursor.__del__ of <pymysql.cursors.Cursor object at 0x7f702d1c93c8>>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py\", line 41, in __del__\n  File \"/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py\", line 47, in close\nReferenceError: weakly-referenced object no longer exists\n```\n在`stackoverflow`上多次解释说在`__def__`中按顺序关闭，但是我尝试之后还是不行，不过这个`Exception`不影响正常运行。\n\n费老大劲终于写完了`item Pipeline`，但是还有最关键的一步，就是在`settings.py`中添加这个`MySQLPipeline`。\n在`settings.py`中加上下面内容：\n```python\n# mysql配置\nMYSQL_HOST = 'localhost'\nMYSQL_DBNAME = 'minsheng'\nMYSQL_USER = 'root'\nMYSQL_PASSWD = ''\n\nITEM_PIPELINES = {\n    'NewsCommentsSpider.pipelines.MySQLPipeline': 300,\n}\n```\n#### 下载器中间件（Downloader Middleware）\n现在的网站不好爬啊，各个大公司都有丰富的反爬虫手段，我们刚才写的都不是爬虫核心，真正的爬虫核心是解析数据和伪装手段。而伪装手段有：\n1. request header\n2. User-Agent\n3. proxy\n4. cookies\n\n`scrapy`框架提供了`Downloader Middleware`供我们对`request`进行设置。\n上代码：\n【middlewares.py】\n```python\n# -*- coding: utf-8 -*-\nimport random\n\nfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddleware\n# from NewsCommentsSpider.cookies import cookies\nfrom NewsCommentsSpider.user_agent import agents\n\n\nclass UserAgentMiddleware(UserAgentMiddleware):\n    \"\"\" 换User-Agent \"\"\"\n    pass\n    def process_request(self, request, spider):\n        agent = random.choice(agents)\n        request.headers['User-Agent'] = agent\n\n\nclass CookiesMiddleware(object):\n    \"\"\" 四个网站，选择相应cookie \"\"\"\n    # def process_request(self, request, spider):\n    #     if spider.name == 'weibo':\n    #         cookie = random.choice(cookies)\n    #         request.cookies = cookie\n    \n\nclass HeadersMiddleware(object):\n    pass\n    \n\nclass ProxiesMiddleware(object):\n    pass\n```\n【user-agent.py】\n```python\n# encoding=utf-8\n\nagents = [\n\t\"Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; Nexus S Build/GRK39F) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\",\n\t...\n]\n```\n这里就不列出所有内容了\n同理，`cookies.py`和`proxies.py`也是同样的道理。\n\n到这里，“准备工作”就已经都完成了，现在终于到主角`Spider`登场。\n\n#### Spiders\n看一个示例，就拿相对简单的今日头条评论`ToutiaoSpider`来讲解。\n先上代码：\n```python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n@author: cap_ljf\n@time: 18-3-16 上午11:25\n\"\"\"\nimport json\nimport re\n\nfrom scrapy_redis.spiders import RedisSpider\n\nfrom NewsCommentsSpider.items import CommentItem\n\n\nclass ToutiaoSpider(RedisSpider):\n    name = 'toutiao'\n    redis_key = 'toutiao_url'\n\n    '''\n        新闻链接：https://www.toutiao.com/a6533396129860551182/\n        评论接口：https://www.toutiao.com/api/comment/list/?group_id=6533396129860551182&item_id=6533396129860551182\n    '''\n    def __init__(self):\n        self.allowed_domains = ['www.toutiao.com']\n        self.url = 'https://www.toutiao.com/a'\n\n    def parse(self, response):\n        content = json.loads(response.body.decode())\n        id = re.search(r'([0-9]+)', response.url).group(1)\n        url = self.url + str(id)\n        comments = content['data']['comments']\n        for comment in comments:\n            item = CommentItem()\n            item['url'] = url\n            item['comment'] = comment['text']\n            item['author'] = comment['user']['name']\n            item['praise'] = comment['digg_count']\n            item['create_time'] = comment['create_time']\n            yield item\n```\n- `name`：用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。\n- `redis_key`：使用scrapy-redis，必须要有这个字段且唯一，相当于`scrapy`的`start_urls`，包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。\n- `parse()`：是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。\n\n因为我们项目使用了`scrapy-redis`，所以这里的`class`父对象是`RedisSpider`，普通的`xxxSpider`父对象是`Spider`。\n\n得到了`response`对象之后就可使用多种方法解析获取有用的信息了，解析方法有：\n1. beautifulSoup\n2. XPath \n3. re\n\n如果使用`scrapy`，推荐使用[XPath](http://www.w3school.com.cn/xpath/xpath_syntax.asp)，语法很简单，半个小时基本能掌握。\n\n由于解析数据是一个麻烦的事情，而我**刚好**找到了四个网站中的三个的评论接口，它们返回的数据直接是评论的`JSON`数据。可以直接用Python的`dict`解析数据。\n在项目目录下使用命令行执行`scrapy crawl toutiao`，就可以在数据库中看到数据啦。\n不信？悟空，你看（观音指）：\n![Alt text](https://app.yinxiang.com/shard/s15/res/dcd35021-e4af-42dd-856b-712b5c0061bc/1522163039866.png)\n哦哦，因为代码是用的`redis`版本，还有相关`settings.py`没有讲解，所以上面无法执行，可直接去github clone代码下来运行看看效果。如果非要运行起来，看下面`2. Redis，分布式爬虫`\n\n### 2. Redis，分布式爬虫\n第一部分介绍了如何使用scrapy爬取评论。现在我们对代码进行重构，增加`Redis`进行分布式爬虫，增加爬虫效率。\n\n参考：[新浪微博分布式爬虫分享](https://blog.csdn.net/bone_ace/article/details/50904718)\n> 分布式中有一台机充当Master，安装Redis进行任务调度，其余机子充当Slaver只管从Master那里拿任务去爬。原理是：Slaver运行的时候，scrapy遇到Request并不是交给spider去爬，而是统一交给Master机上的Redis数据库，spider要爬的Request也都是从Redis中取来的，而Redis接收到Request后先去重再存入数据库，哪个Slaver要Request了再给它，由此实现任务协同。\n\n#### Redis\n> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\n\n不了解redis的去官网学一下，上手很简单。我的导师某日天是Redis中文翻译者之一。\n[Redis中文官网](http://www.redis.net.cn/tutorial/3501.html)\n\n#### scrapy-redis\nscrapy-redis是一个基于redis的scrapy组件，通过它可以快速实现简单分布式爬虫程序，该组件本质上提供了三大功能：\n- scheduler - 调度器\n- dupefilter - URL去重规则（被调度器使用）\n- pipeline   - 数据持久化\n\n看一下`settings.py`中的`Redis配置`\n```python\n# redis配置\n# 使用scrapy-redis里的调度器组件，不使用默认的调度器\nSCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n# 允许暂停，redis请求记录不丢失\nSCHEDULER_PERSIST = True\n# 使用scrapy-redis里的去重组件，不使用scrapy默认的去重方式\nDUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n# 连接Redis配置\nREDIS_HOST = 'localhost'\nREDIS_PORT = '6379'\nREDIS_DB = 0 # 指定db为0\nREDIS_PASSWD = ''\n```\n\n\n\n### 3. 爬虫技巧之接口的获取\n\n当你了解了基础的爬虫知识之后，阻碍你顺利爬取数据的还有数据源的获取，每一个网站都有不同的架构，有些网站可能想让自己的内容更容易的让搜索引擎引用，同时又不想被恶意的爬虫访问，所以各个网站的后台数据送到前台展示方式都不同。\n\n经过我最近频繁的爬虫，我了解到一个非常重要的规律，那就是**对于文本类型的数据一般都是使用JSON数据格式传输**。但是这个`JSON数据接口`一般都非常隐蔽，比如`凤凰网`的评论展示接口，它使用了回调使用`js`进行处理之后再给到前台展示，所以你第一眼看到的不是整齐的`JSON`数据，而是一对乱糟糟不规律的类html文本。而`今日头条`则非常开放。\n\n\n好了，这一次的分享就到这儿了，分享一个不太哲学的网站[哲学](http://www.mmjpg.com)\n爬取太频繁会封ip哦～","source":"_posts/基于scrapy分布式新闻评论爬虫.md","raw":"---\ntoc: true\ntitle: 基于scrapy分布式新闻评论爬虫\ndate: 2018-03-28 21:00:04\ntags: [爬虫, scrapy, redis, weibo, news163, ifeng, toutiao]\n---\n\n\n我的毕设主题是：时事新闻评论分析软件的设计与实现。要分析评论，就需要评论数据，于是就写起了爬虫。\n\n<!--more-->\n项目仓库：[NewsCommentsSpider](https://github.com/cap-ljf/NewsCommentsSpider)\n如果感觉对您有帮助的话给个小小的`star`吧，哈哈。\n\n对于爬虫，搜索得到的文章大部分都是python爬虫，“python有天然的爬虫优势”，虽然我也讲不清python爬虫有什么天然的优势，可能在html文件解析、json解析、有大量成熟好用的工具包。于是我开始学习`scrapy`框架，上手很简单，而且官方文档比较详细。\n\n[Scrapy入门教程](http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html)\n\n#### 开发环境\n系统：`Ubuntu16.10`\n开发软件：`Pycharm 2017.3.3 Professinal Edition`\n工具包：\n```\npython 3.5\npip 9.0.1\nscrapy \nbeautifulsoup4 4.5.1\nipython 6.2.1\nlxml 4.1.1\nPyMySQL3 0.5\nredis 2.10.6\nrequests 2.18.4\nScrapy 1.5.0\nscrapy-redis 0.6.8\nselenium 2.48.0 \n```\n### 1. Scrapy入门，搭建NewsCommentsSpider项目\n#### 安装scrapy\n我的系统是`Ubuntu16.10`，使用下列命令：\n`pip install scrapy`\n#### 创建项目\n`scrapy startproject NewsCommentsSpider`\n*下面一段解释来自scrapy中文官网*\n该命令将会创建包含下列内容的`NewsCommentsSpider`目录：\n```\nNewsCommentsSpider/\n    scrapy.cfg\n    NewsCommentsSpider/\n        __init__.py\n        items.py\n        pipelines.py\n        settings.py\n        spiders/\n            __init__.py\n            ...\n```\n这些文件分别是:\n- `scrapy.cfg`: 项目的配置文件\n- `NewsCommentsSpider`/: 该项目的python模块。之后您将在此加入代码。\n- `NewsCommentsSpider/items.py`: 项目中的item文件.\n- `NewsCommentsSpider/pipelines.py`: 项目中的pipelines文件.\n- `NewsCommentsSpider/settings.py`: 项目的设置文件.\n- `NewsCommentsSpider/spiders/`: 放置spider代码的目录.\n\n#### 数据库设计\nOK，到这儿我们就已经成功搭建好了scrapy框架。\n现在来看我毕设的题目：\n```\n题目：基于Python的时事新闻评论分析软件的设计与实现\n主要数据：凤凰网、今日头条、网易新闻、微博四大平台的新闻评论。（一开始我是准备爬知乎和微信公众号的评论的，但是知乎问题的回答一般都很长，而且表达的主观情绪较少，一般都是摆数据讲道理，不太好分析；而微信公众号的评论接口我一直没找到，只好作罢，如果您有关于微信公众号文章评论接口相关的信息或想法，恳求告知：邮箱1579461369@qq.com）\n```\n针对上述需求，我设计了两个表：\n1. 文章表：（**article**）新闻文章或微博信息\n2. 评论表：（**comment**）文章评论相关信息\n\n请看：\n【**article**】\n| Field      |    Type | Null  | Key | Default | Extra |\n| :-------- | --------:| :--: |\n| id  | int(11) |  NO   | PRI |  | auto_increment |\n| keyword  | varchar(20) |  NO   | MUL |  |  |\n| url  | varchar(150) |  NO   |  |  |  |\n| author  | varchar(50) |  YES   |  |  |  |\n| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\n| comment_count  | int(11) |  NO   |  |  |  |\n\n【**comment**】\n| Field      |    Type | Null  | Key | Default | Extra |\n| :-------- | --------:| :--: |\n| id  | int(11) |  NO   | PRI |  | auto_increment |\n| url  | varchar(150) |  NO   | MUL |  |  |\n| author  | varchar(50) |  YES   |  |  |  |\n| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\n| comment  | varchar(1000) |  NO   |  |  |  |\n| praise  | smallint(6) |  YES   |  |  |  |\n\n**SQL语句**\n第一次设计的时候`author`字段长度设计的比较小，导致在测试网易新闻评论爬取的时候出现异常，于是增加了`author`字段的大小。\n```sql\nCREATE DATABASE minsheng;\nUSE minsheng;\nCREATE TABLE article(\n  id INT NOT NULL AUTO_INCREMENT COMMENT '主键',\n  keyword varchar(20) NOT NULL COMMENT '关键词',\n  url VARCHAR(150) NOT NULL UNIQUE COMMENT '文章url',\n  author VARCHAR(20) COMMENT '作者',\n  create_time TIMESTAMP COMMENT '文章创建时间',\n  comment_count int NOT NULL COMMENT '评论数',\n  PRIMARY KEY (id),\n  INDEX idx_keyword (keyword)\n)ENGINE = InnoDB CHARSET = 'utf8' COMMENT '文章表';\nCREATE TABLE comment(\n  id INT NOT NULL AUTO_INCREMENT COMMENT '主键',\n  url VARCHAR(150) NOT NULL COMMENT '文章链接',\n  comment VARCHAR(1000) NOT NULL COMMENT '评论',\n  author VARCHAR(20) COMMENT '评论者',\n  praise SMALLINT COMMENT '点赞数',\n  create_time TIMESTAMP COMMENT '评论时间',\n  PRIMARY KEY (id),\n  INDEX idx_url (url)\n)ENGINE = InnoDB CHARSET = 'utf8mb4' COMMENT '评论表';\nALTER TABLE comment MODIFY COLUMN author VARCHAR(50);\nALTER TABLE article MODIFY COLUMN author VARCHAR(50);\n```\n#### 定义Item\n既然已经有了数据库表，我们就可以知道我们需要那些数据，就可以编写`Item`类。\n```python\nimport scrapy\nfrom scrapy import Field\n\nclass CommentItem(scrapy.Item):\n    # 文章链接\n    url = Field()\n    # 评论内容\n    comment = Field()\n    # 评论者\n    author = Field()\n    # 点赞数\n    praise = Field()\n    # 评论时间\n    create_time = Field()\n```\n#### Item Pipeline，使用Mysql数据库存储数据\n编写你自己的item pipeline很简单，每个item pipiline组件是一个独立的Python类，同时必须实现`process_item`方法。\n这里我们使用`pymysql`包操作mysql数据库。首先在`pipeline`初始化时创建数据库连接，并获取`cursor`。然后在`process_item`方法中执行增删改查操作。最后**关闭连接**，一定要记得关闭连接，否则会产生大量的连接以及游标，最后导致内存泄漏。\n废话少说，上代码：\n```python\n# -*- coding: utf-8 -*-\nimport logging\n\nimport pymysql\nfrom datetime import datetime\n\nfrom NewsCommentsSpider.settings import *\n\n\nclass MySQLPipeline(object):\n    # 定义数据存储方式\n    def __init__(self):\n        try:\n            self.connect = pymysql.connect(\n                host=MYSQL_HOST,\n                db=MYSQL_DBNAME,\n                user=MYSQL_USER,\n                passwd=MYSQL_PASSWD,\n                charset='utf8',\n                use_unicode=True\n            )\n            # 通过cursor执行增删改查\n            self.cursor = self.connect.cursor()\n            logging.debug('mysql conn success!')\n        except Exception as error:\n            logging.error('mysql conn error!:', error)\n\n    def process_item(self, item, spider):\n        try:\n            self.cursor.execute(\n                \"\"\"insert into comment(url, comment, author, praise, create_time)\n                                  value (%s, %s, %s, %s, %s)\"\"\",\n                (item['url'],\n                 item['comment'],\n                 item['author'],\n                 item['praise'],\n                 # item['create_time']\n                 datetime.fromtimestamp(item['create_time'])\n                 )\n            )\n            # 提交sql语句\n            self.connect.commit()\n        except Exception as error:\n            # 异常打印日志\n            logging.error(\"数据库插入异常:\", error)\n\n        return item\n\n    def __del__(self):\n        try:\n            # if self.cursor:\n            #     self.cursor.close()\n            if self.connect:\n                self.connect.close()\n        except Exception as error:\n            logging.error(\"conn or cursor 关闭失败:\", error)\n```\n代码中我注释了这样两段代码\n1. `item['create_time']`，如果直接使用`timestamp`执行`insert`。这里出现异常：\n```bash\nMessage: '数据库插入异常:'\nArguments: (InternalError(InternalError(1292, \"Incorrect datetime value: '1522110959' for column 'create_time' at row 1\"),),)\n```\n我也不知道为什么，python操作mysql插入数据库为什么会出现这种情况，后来我将时间戳改成`datetime`类型就没问题了。\n2. `__del__()`，在这个函数我进行了`cursor`和`connect`的关闭，但是不知道为什么游标一直关不掉，debug信息指示：\n```\nException ignored in: <bound method Cursor.__del__ of <pymysql.cursors.Cursor object at 0x7f702d1c93c8>>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py\", line 41, in __del__\n  File \"/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py\", line 47, in close\nReferenceError: weakly-referenced object no longer exists\n```\n在`stackoverflow`上多次解释说在`__def__`中按顺序关闭，但是我尝试之后还是不行，不过这个`Exception`不影响正常运行。\n\n费老大劲终于写完了`item Pipeline`，但是还有最关键的一步，就是在`settings.py`中添加这个`MySQLPipeline`。\n在`settings.py`中加上下面内容：\n```python\n# mysql配置\nMYSQL_HOST = 'localhost'\nMYSQL_DBNAME = 'minsheng'\nMYSQL_USER = 'root'\nMYSQL_PASSWD = ''\n\nITEM_PIPELINES = {\n    'NewsCommentsSpider.pipelines.MySQLPipeline': 300,\n}\n```\n#### 下载器中间件（Downloader Middleware）\n现在的网站不好爬啊，各个大公司都有丰富的反爬虫手段，我们刚才写的都不是爬虫核心，真正的爬虫核心是解析数据和伪装手段。而伪装手段有：\n1. request header\n2. User-Agent\n3. proxy\n4. cookies\n\n`scrapy`框架提供了`Downloader Middleware`供我们对`request`进行设置。\n上代码：\n【middlewares.py】\n```python\n# -*- coding: utf-8 -*-\nimport random\n\nfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddleware\n# from NewsCommentsSpider.cookies import cookies\nfrom NewsCommentsSpider.user_agent import agents\n\n\nclass UserAgentMiddleware(UserAgentMiddleware):\n    \"\"\" 换User-Agent \"\"\"\n    pass\n    def process_request(self, request, spider):\n        agent = random.choice(agents)\n        request.headers['User-Agent'] = agent\n\n\nclass CookiesMiddleware(object):\n    \"\"\" 四个网站，选择相应cookie \"\"\"\n    # def process_request(self, request, spider):\n    #     if spider.name == 'weibo':\n    #         cookie = random.choice(cookies)\n    #         request.cookies = cookie\n    \n\nclass HeadersMiddleware(object):\n    pass\n    \n\nclass ProxiesMiddleware(object):\n    pass\n```\n【user-agent.py】\n```python\n# encoding=utf-8\n\nagents = [\n\t\"Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; Nexus S Build/GRK39F) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\",\n\t...\n]\n```\n这里就不列出所有内容了\n同理，`cookies.py`和`proxies.py`也是同样的道理。\n\n到这里，“准备工作”就已经都完成了，现在终于到主角`Spider`登场。\n\n#### Spiders\n看一个示例，就拿相对简单的今日头条评论`ToutiaoSpider`来讲解。\n先上代码：\n```python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n@author: cap_ljf\n@time: 18-3-16 上午11:25\n\"\"\"\nimport json\nimport re\n\nfrom scrapy_redis.spiders import RedisSpider\n\nfrom NewsCommentsSpider.items import CommentItem\n\n\nclass ToutiaoSpider(RedisSpider):\n    name = 'toutiao'\n    redis_key = 'toutiao_url'\n\n    '''\n        新闻链接：https://www.toutiao.com/a6533396129860551182/\n        评论接口：https://www.toutiao.com/api/comment/list/?group_id=6533396129860551182&item_id=6533396129860551182\n    '''\n    def __init__(self):\n        self.allowed_domains = ['www.toutiao.com']\n        self.url = 'https://www.toutiao.com/a'\n\n    def parse(self, response):\n        content = json.loads(response.body.decode())\n        id = re.search(r'([0-9]+)', response.url).group(1)\n        url = self.url + str(id)\n        comments = content['data']['comments']\n        for comment in comments:\n            item = CommentItem()\n            item['url'] = url\n            item['comment'] = comment['text']\n            item['author'] = comment['user']['name']\n            item['praise'] = comment['digg_count']\n            item['create_time'] = comment['create_time']\n            yield item\n```\n- `name`：用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。\n- `redis_key`：使用scrapy-redis，必须要有这个字段且唯一，相当于`scrapy`的`start_urls`，包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。\n- `parse()`：是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。\n\n因为我们项目使用了`scrapy-redis`，所以这里的`class`父对象是`RedisSpider`，普通的`xxxSpider`父对象是`Spider`。\n\n得到了`response`对象之后就可使用多种方法解析获取有用的信息了，解析方法有：\n1. beautifulSoup\n2. XPath \n3. re\n\n如果使用`scrapy`，推荐使用[XPath](http://www.w3school.com.cn/xpath/xpath_syntax.asp)，语法很简单，半个小时基本能掌握。\n\n由于解析数据是一个麻烦的事情，而我**刚好**找到了四个网站中的三个的评论接口，它们返回的数据直接是评论的`JSON`数据。可以直接用Python的`dict`解析数据。\n在项目目录下使用命令行执行`scrapy crawl toutiao`，就可以在数据库中看到数据啦。\n不信？悟空，你看（观音指）：\n![Alt text](https://app.yinxiang.com/shard/s15/res/dcd35021-e4af-42dd-856b-712b5c0061bc/1522163039866.png)\n哦哦，因为代码是用的`redis`版本，还有相关`settings.py`没有讲解，所以上面无法执行，可直接去github clone代码下来运行看看效果。如果非要运行起来，看下面`2. Redis，分布式爬虫`\n\n### 2. Redis，分布式爬虫\n第一部分介绍了如何使用scrapy爬取评论。现在我们对代码进行重构，增加`Redis`进行分布式爬虫，增加爬虫效率。\n\n参考：[新浪微博分布式爬虫分享](https://blog.csdn.net/bone_ace/article/details/50904718)\n> 分布式中有一台机充当Master，安装Redis进行任务调度，其余机子充当Slaver只管从Master那里拿任务去爬。原理是：Slaver运行的时候，scrapy遇到Request并不是交给spider去爬，而是统一交给Master机上的Redis数据库，spider要爬的Request也都是从Redis中取来的，而Redis接收到Request后先去重再存入数据库，哪个Slaver要Request了再给它，由此实现任务协同。\n\n#### Redis\n> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\n\n不了解redis的去官网学一下，上手很简单。我的导师某日天是Redis中文翻译者之一。\n[Redis中文官网](http://www.redis.net.cn/tutorial/3501.html)\n\n#### scrapy-redis\nscrapy-redis是一个基于redis的scrapy组件，通过它可以快速实现简单分布式爬虫程序，该组件本质上提供了三大功能：\n- scheduler - 调度器\n- dupefilter - URL去重规则（被调度器使用）\n- pipeline   - 数据持久化\n\n看一下`settings.py`中的`Redis配置`\n```python\n# redis配置\n# 使用scrapy-redis里的调度器组件，不使用默认的调度器\nSCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n# 允许暂停，redis请求记录不丢失\nSCHEDULER_PERSIST = True\n# 使用scrapy-redis里的去重组件，不使用scrapy默认的去重方式\nDUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n# 连接Redis配置\nREDIS_HOST = 'localhost'\nREDIS_PORT = '6379'\nREDIS_DB = 0 # 指定db为0\nREDIS_PASSWD = ''\n```\n\n\n\n### 3. 爬虫技巧之接口的获取\n\n当你了解了基础的爬虫知识之后，阻碍你顺利爬取数据的还有数据源的获取，每一个网站都有不同的架构，有些网站可能想让自己的内容更容易的让搜索引擎引用，同时又不想被恶意的爬虫访问，所以各个网站的后台数据送到前台展示方式都不同。\n\n经过我最近频繁的爬虫，我了解到一个非常重要的规律，那就是**对于文本类型的数据一般都是使用JSON数据格式传输**。但是这个`JSON数据接口`一般都非常隐蔽，比如`凤凰网`的评论展示接口，它使用了回调使用`js`进行处理之后再给到前台展示，所以你第一眼看到的不是整齐的`JSON`数据，而是一对乱糟糟不规律的类html文本。而`今日头条`则非常开放。\n\n\n好了，这一次的分享就到这儿了，分享一个不太哲学的网站[哲学](http://www.mmjpg.com)\n爬取太频繁会封ip哦～","slug":"基于scrapy分布式新闻评论爬虫","published":1,"updated":"2018-08-13T14:28:27.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloh3e6k00476k15uq37jsti","content":"<p>我的毕设主题是：时事新闻评论分析软件的设计与实现。要分析评论，就需要评论数据，于是就写起了爬虫。</p>\n<a id=\"more\"></a>\n<p>项目仓库：<a href=\"https://github.com/cap-ljf/NewsCommentsSpider\" target=\"_blank\" rel=\"noopener\">NewsCommentsSpider</a><br>如果感觉对您有帮助的话给个小小的<code>star</code>吧，哈哈。</p>\n<p>对于爬虫，搜索得到的文章大部分都是python爬虫，“python有天然的爬虫优势”，虽然我也讲不清python爬虫有什么天然的优势，可能在html文件解析、json解析、有大量成熟好用的工具包。于是我开始学习<code>scrapy</code>框架，上手很简单，而且官方文档比较详细。</p>\n<p><a href=\"http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">Scrapy入门教程</a></p>\n<h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><p>系统：<code>Ubuntu16.10</code><br>开发软件：<code>Pycharm 2017.3.3 Professinal Edition</code><br>工具包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python 3.5</span><br><span class=\"line\">pip 9.0.1</span><br><span class=\"line\">scrapy </span><br><span class=\"line\">beautifulsoup4 4.5.1</span><br><span class=\"line\">ipython 6.2.1</span><br><span class=\"line\">lxml 4.1.1</span><br><span class=\"line\">PyMySQL3 0.5</span><br><span class=\"line\">redis 2.10.6</span><br><span class=\"line\">requests 2.18.4</span><br><span class=\"line\">Scrapy 1.5.0</span><br><span class=\"line\">scrapy-redis 0.6.8</span><br><span class=\"line\">selenium 2.48.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-Scrapy入门，搭建NewsCommentsSpider项目\"><a href=\"#1-Scrapy入门，搭建NewsCommentsSpider项目\" class=\"headerlink\" title=\"1. Scrapy入门，搭建NewsCommentsSpider项目\"></a>1. Scrapy入门，搭建NewsCommentsSpider项目</h3><h4 id=\"安装scrapy\"><a href=\"#安装scrapy\" class=\"headerlink\" title=\"安装scrapy\"></a>安装scrapy</h4><p>我的系统是<code>Ubuntu16.10</code>，使用下列命令：<br><code>pip install scrapy</code></p>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p><code>scrapy startproject NewsCommentsSpider</code><br><em>下面一段解释来自scrapy中文官网</em><br>该命令将会创建包含下列内容的<code>NewsCommentsSpider</code>目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NewsCommentsSpider/</span><br><span class=\"line\">    scrapy.cfg</span><br><span class=\"line\">    NewsCommentsSpider/</span><br><span class=\"line\">        __init__.py</span><br><span class=\"line\">        items.py</span><br><span class=\"line\">        pipelines.py</span><br><span class=\"line\">        settings.py</span><br><span class=\"line\">        spiders/</span><br><span class=\"line\">            __init__.py</span><br><span class=\"line\">            ...</span><br></pre></td></tr></table></figure></p>\n<p>这些文件分别是:</p>\n<ul>\n<li><code>scrapy.cfg</code>: 项目的配置文件</li>\n<li><code>NewsCommentsSpider</code>/: 该项目的python模块。之后您将在此加入代码。</li>\n<li><code>NewsCommentsSpider/items.py</code>: 项目中的item文件.</li>\n<li><code>NewsCommentsSpider/pipelines.py</code>: 项目中的pipelines文件.</li>\n<li><code>NewsCommentsSpider/settings.py</code>: 项目的设置文件.</li>\n<li><code>NewsCommentsSpider/spiders/</code>: 放置spider代码的目录.</li>\n</ul>\n<h4 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h4><p>OK，到这儿我们就已经成功搭建好了scrapy框架。<br>现在来看我毕设的题目：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目：基于Python的时事新闻评论分析软件的设计与实现</span><br><span class=\"line\">主要数据：凤凰网、今日头条、网易新闻、微博四大平台的新闻评论。（一开始我是准备爬知乎和微信公众号的评论的，但是知乎问题的回答一般都很长，而且表达的主观情绪较少，一般都是摆数据讲道理，不太好分析；而微信公众号的评论接口我一直没找到，只好作罢，如果您有关于微信公众号文章评论接口相关的信息或想法，恳求告知：邮箱1579461369@qq.com）</span><br></pre></td></tr></table></figure></p>\n<p>针对上述需求，我设计了两个表：</p>\n<ol>\n<li>文章表：（<strong>article</strong>）新闻文章或微博信息</li>\n<li>评论表：（<strong>comment</strong>）文章评论相关信息</li>\n</ol>\n<p>请看：<br>【<strong>article</strong>】<br>| Field      |    Type | Null  | Key | Default | Extra |<br>| :——– | ——–:| :–: |<br>| id  | int(11) |  NO   | PRI |  | auto_increment |<br>| keyword  | varchar(20) |  NO   | MUL |  |  |<br>| url  | varchar(150) |  NO   |  |  |  |<br>| author  | varchar(50) |  YES   |  |  |  |<br>| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |<br>| comment_count  | int(11) |  NO   |  |  |  |</p>\n<p>【<strong>comment</strong>】<br>| Field      |    Type | Null  | Key | Default | Extra |<br>| :——– | ——–:| :–: |<br>| id  | int(11) |  NO   | PRI |  | auto_increment |<br>| url  | varchar(150) |  NO   | MUL |  |  |<br>| author  | varchar(50) |  YES   |  |  |  |<br>| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |<br>| comment  | varchar(1000) |  NO   |  |  |  |<br>| praise  | smallint(6) |  YES   |  |  |  |</p>\n<p><strong>SQL语句</strong><br>第一次设计的时候<code>author</code>字段长度设计的比较小，导致在测试网易新闻评论爬取的时候出现异常，于是增加了<code>author</code>字段的大小。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> minsheng;</span><br><span class=\"line\"><span class=\"keyword\">USE</span> minsheng;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> article(</span><br><span class=\"line\">  <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键'</span>,</span><br><span class=\"line\">  keyword <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'关键词'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">url</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">150</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章url'</span>,</span><br><span class=\"line\">  author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'作者'</span>,</span><br><span class=\"line\">  create_time <span class=\"keyword\">TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章创建时间'</span>,</span><br><span class=\"line\">  comment_count <span class=\"built_in\">int</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论数'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">id</span>),</span><br><span class=\"line\">  <span class=\"keyword\">INDEX</span> idx_keyword (keyword)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span> = <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">CHARSET</span> = <span class=\"string\">'utf8'</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章表'</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">comment</span>(</span><br><span class=\"line\">  <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">url</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">150</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章链接'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1000</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论'</span>,</span><br><span class=\"line\">  author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论者'</span>,</span><br><span class=\"line\">  praise <span class=\"built_in\">SMALLINT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'点赞数'</span>,</span><br><span class=\"line\">  create_time <span class=\"keyword\">TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论时间'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">id</span>),</span><br><span class=\"line\">  <span class=\"keyword\">INDEX</span> idx_url (<span class=\"keyword\">url</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span> = <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">CHARSET</span> = <span class=\"string\">'utf8mb4'</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论表'</span>;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">comment</span> <span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> article <span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义Item\"><a href=\"#定义Item\" class=\"headerlink\" title=\"定义Item\"></a>定义Item</h4><p>既然已经有了数据库表，我们就可以知道我们需要那些数据，就可以编写<code>Item</code>类。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> Field</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 文章链接</span></span><br><span class=\"line\">    url = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论内容</span></span><br><span class=\"line\">    comment = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论者</span></span><br><span class=\"line\">    author = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 点赞数</span></span><br><span class=\"line\">    praise = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论时间</span></span><br><span class=\"line\">    create_time = Field()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Item-Pipeline，使用Mysql数据库存储数据\"><a href=\"#Item-Pipeline，使用Mysql数据库存储数据\" class=\"headerlink\" title=\"Item Pipeline，使用Mysql数据库存储数据\"></a>Item Pipeline，使用Mysql数据库存储数据</h4><p>编写你自己的item pipeline很简单，每个item pipiline组件是一个独立的Python类，同时必须实现<code>process_item</code>方法。<br>这里我们使用<code>pymysql</code>包操作mysql数据库。首先在<code>pipeline</code>初始化时创建数据库连接，并获取<code>cursor</code>。然后在<code>process_item</code>方法中执行增删改查操作。最后<strong>关闭连接</strong>，一定要记得关闭连接，否则会产生大量的连接以及游标，最后导致内存泄漏。<br>废话少说，上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.settings <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义数据存储方式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.connect = pymysql.connect(</span><br><span class=\"line\">                host=MYSQL_HOST,</span><br><span class=\"line\">                db=MYSQL_DBNAME,</span><br><span class=\"line\">                user=MYSQL_USER,</span><br><span class=\"line\">                passwd=MYSQL_PASSWD,</span><br><span class=\"line\">                charset=<span class=\"string\">'utf8'</span>,</span><br><span class=\"line\">                use_unicode=<span class=\"keyword\">True</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"comment\"># 通过cursor执行增删改查</span></span><br><span class=\"line\">            self.cursor = self.connect.cursor()</span><br><span class=\"line\">            logging.debug(<span class=\"string\">'mysql conn success!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            logging.error(<span class=\"string\">'mysql conn error!:'</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.cursor.execute(</span><br><span class=\"line\">                <span class=\"string\">\"\"\"insert into comment(url, comment, author, praise, create_time)</span></span><br><span class=\"line\"><span class=\"string\">                                  value (%s, %s, %s, %s, %s)\"\"\"</span>,</span><br><span class=\"line\">                (item[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'author'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'praise'</span>],</span><br><span class=\"line\">                 <span class=\"comment\"># item['create_time']</span></span><br><span class=\"line\">                 datetime.fromtimestamp(item[<span class=\"string\">'create_time'</span>])</span><br><span class=\"line\">                 )</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"comment\"># 提交sql语句</span></span><br><span class=\"line\">            self.connect.commit()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            <span class=\"comment\"># 异常打印日志</span></span><br><span class=\"line\">            logging.error(<span class=\"string\">\"数据库插入异常:\"</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__del__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"comment\"># if self.cursor:</span></span><br><span class=\"line\">            <span class=\"comment\">#     self.cursor.close()</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.connect:</span><br><span class=\"line\">                self.connect.close()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            logging.error(<span class=\"string\">\"conn or cursor 关闭失败:\"</span>, error)</span><br></pre></td></tr></table></figure></p>\n<p>代码中我注释了这样两段代码</p>\n<ol>\n<li><code>item[&#39;create_time&#39;]</code>，如果直接使用<code>timestamp</code>执行<code>insert</code>。这里出现异常：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message: <span class=\"string\">'数据库插入异常:'</span></span><br><span class=\"line\">Arguments: (InternalError(InternalError(1292, <span class=\"string\">\"Incorrect datetime value: '1522110959' for column 'create_time' at row 1\"</span>),),)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我也不知道为什么，python操作mysql插入数据库为什么会出现这种情况，后来我将时间戳改成<code>datetime</code>类型就没问题了。</p>\n<ol>\n<li><code>__del__()</code>，在这个函数我进行了<code>cursor</code>和<code>connect</code>的关闭，但是不知道为什么游标一直关不掉，debug信息指示：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception ignored in: &lt;bound method Cursor.__del__ of &lt;pymysql.cursors.Cursor object at 0x7f702d1c93c8&gt;&gt;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py&quot;, line 41, in __del__</span><br><span class=\"line\">  File &quot;/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py&quot;, line 47, in close</span><br><span class=\"line\">ReferenceError: weakly-referenced object no longer exists</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在<code>stackoverflow</code>上多次解释说在<code>__def__</code>中按顺序关闭，但是我尝试之后还是不行，不过这个<code>Exception</code>不影响正常运行。</p>\n<p>费老大劲终于写完了<code>item Pipeline</code>，但是还有最关键的一步，就是在<code>settings.py</code>中添加这个<code>MySQLPipeline</code>。<br>在<code>settings.py</code>中加上下面内容：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysql配置</span></span><br><span class=\"line\">MYSQL_HOST = <span class=\"string\">'localhost'</span></span><br><span class=\"line\">MYSQL_DBNAME = <span class=\"string\">'minsheng'</span></span><br><span class=\"line\">MYSQL_USER = <span class=\"string\">'root'</span></span><br><span class=\"line\">MYSQL_PASSWD = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">    <span class=\"string\">'NewsCommentsSpider.pipelines.MySQLPipeline'</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"下载器中间件（Downloader-Middleware）\"><a href=\"#下载器中间件（Downloader-Middleware）\" class=\"headerlink\" title=\"下载器中间件（Downloader Middleware）\"></a>下载器中间件（Downloader Middleware）</h4><p>现在的网站不好爬啊，各个大公司都有丰富的反爬虫手段，我们刚才写的都不是爬虫核心，真正的爬虫核心是解析数据和伪装手段。而伪装手段有：</p>\n<ol>\n<li>request header</li>\n<li>User-Agent</li>\n<li>proxy</li>\n<li>cookies</li>\n</ol>\n<p><code>scrapy</code>框架提供了<code>Downloader Middleware</code>供我们对<code>request</code>进行设置。<br>上代码：<br>【middlewares.py】<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.downloadermiddlewares.useragent <span class=\"keyword\">import</span> UserAgentMiddleware</span><br><span class=\"line\"><span class=\"comment\"># from NewsCommentsSpider.cookies import cookies</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.user_agent <span class=\"keyword\">import</span> agents</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAgentMiddleware</span><span class=\"params\">(UserAgentMiddleware)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" 换User-Agent \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        agent = random.choice(agents)</span><br><span class=\"line\">        request.headers[<span class=\"string\">'User-Agent'</span>] = agent</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CookiesMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" 四个网站，选择相应cookie \"\"\"</span></span><br><span class=\"line\">    <span class=\"comment\"># def process_request(self, request, spider):</span></span><br><span class=\"line\">    <span class=\"comment\">#     if spider.name == 'weibo':</span></span><br><span class=\"line\">    <span class=\"comment\">#         cookie = random.choice(cookies)</span></span><br><span class=\"line\">    <span class=\"comment\">#         request.cookies = cookie</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeadersMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxiesMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>【user-agent.py】<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># encoding=utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\">agents = [</span><br><span class=\"line\">\t<span class=\"string\">\"Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; Nexus S Build/GRK39F) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\"</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这里就不列出所有内容了<br>同理，<code>cookies.py</code>和<code>proxies.py</code>也是同样的道理。</p>\n<p>到这里，“准备工作”就已经都完成了，现在终于到主角<code>Spider</code>登场。</p>\n<h4 id=\"Spiders\"><a href=\"#Spiders\" class=\"headerlink\" title=\"Spiders\"></a>Spiders</h4><p>看一个示例，就拿相对简单的今日头条评论<code>ToutiaoSpider</code>来讲解。<br>先上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">@author: cap_ljf</span></span><br><span class=\"line\"><span class=\"string\">@time: 18-3-16 上午11:25</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy_redis.spiders <span class=\"keyword\">import</span> RedisSpider</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.items <span class=\"keyword\">import</span> CommentItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToutiaoSpider</span><span class=\"params\">(RedisSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'toutiao'</span></span><br><span class=\"line\">    redis_key = <span class=\"string\">'toutiao_url'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        新闻链接：https://www.toutiao.com/a6533396129860551182/</span></span><br><span class=\"line\"><span class=\"string\">        评论接口：https://www.toutiao.com/api/comment/list/?group_id=6533396129860551182&amp;item_id=6533396129860551182</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.allowed_domains = [<span class=\"string\">'www.toutiao.com'</span>]</span><br><span class=\"line\">        self.url = <span class=\"string\">'https://www.toutiao.com/a'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        content = json.loads(response.body.decode())</span><br><span class=\"line\">        id = re.search(<span class=\"string\">r'([0-9]+)'</span>, response.url).group(<span class=\"number\">1</span>)</span><br><span class=\"line\">        url = self.url + str(id)</span><br><span class=\"line\">        comments = content[<span class=\"string\">'data'</span>][<span class=\"string\">'comments'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> comment <span class=\"keyword\">in</span> comments:</span><br><span class=\"line\">            item = CommentItem()</span><br><span class=\"line\">            item[<span class=\"string\">'url'</span>] = url</span><br><span class=\"line\">            item[<span class=\"string\">'comment'</span>] = comment[<span class=\"string\">'text'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'author'</span>] = comment[<span class=\"string\">'user'</span>][<span class=\"string\">'name'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'praise'</span>] = comment[<span class=\"string\">'digg_count'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'create_time'</span>] = comment[<span class=\"string\">'create_time'</span>]</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>name</code>：用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li>\n<li><code>redis_key</code>：使用scrapy-redis，必须要有这个字段且唯一，相当于<code>scrapy</code>的<code>start_urls</code>，包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li>\n<li><code>parse()</code>：是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>\n</ul>\n<p>因为我们项目使用了<code>scrapy-redis</code>，所以这里的<code>class</code>父对象是<code>RedisSpider</code>，普通的<code>xxxSpider</code>父对象是<code>Spider</code>。</p>\n<p>得到了<code>response</code>对象之后就可使用多种方法解析获取有用的信息了，解析方法有：</p>\n<ol>\n<li>beautifulSoup</li>\n<li>XPath </li>\n<li>re</li>\n</ol>\n<p>如果使用<code>scrapy</code>，推荐使用<a href=\"http://www.w3school.com.cn/xpath/xpath_syntax.asp\" target=\"_blank\" rel=\"noopener\">XPath</a>，语法很简单，半个小时基本能掌握。</p>\n<p>由于解析数据是一个麻烦的事情，而我<strong>刚好</strong>找到了四个网站中的三个的评论接口，它们返回的数据直接是评论的<code>JSON</code>数据。可以直接用Python的<code>dict</code>解析数据。<br>在项目目录下使用命令行执行<code>scrapy crawl toutiao</code>，就可以在数据库中看到数据啦。<br>不信？悟空，你看（观音指）：<br><img src=\"https://app.yinxiang.com/shard/s15/res/dcd35021-e4af-42dd-856b-712b5c0061bc/1522163039866.png\" alt=\"Alt text\"><br>哦哦，因为代码是用的<code>redis</code>版本，还有相关<code>settings.py</code>没有讲解，所以上面无法执行，可直接去github clone代码下来运行看看效果。如果非要运行起来，看下面<code>2. Redis，分布式爬虫</code></p>\n<h3 id=\"2-Redis，分布式爬虫\"><a href=\"#2-Redis，分布式爬虫\" class=\"headerlink\" title=\"2. Redis，分布式爬虫\"></a>2. Redis，分布式爬虫</h3><p>第一部分介绍了如何使用scrapy爬取评论。现在我们对代码进行重构，增加<code>Redis</code>进行分布式爬虫，增加爬虫效率。</p>\n<p>参考：<a href=\"https://blog.csdn.net/bone_ace/article/details/50904718\" target=\"_blank\" rel=\"noopener\">新浪微博分布式爬虫分享</a></p>\n<blockquote>\n<p>分布式中有一台机充当Master，安装Redis进行任务调度，其余机子充当Slaver只管从Master那里拿任务去爬。原理是：Slaver运行的时候，scrapy遇到Request并不是交给spider去爬，而是统一交给Master机上的Redis数据库，spider要爬的Request也都是从Redis中取来的，而Redis接收到Request后先去重再存入数据库，哪个Slaver要Request了再给它，由此实现任务协同。</p>\n</blockquote>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><blockquote>\n<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n</blockquote>\n<p>不了解redis的去官网学一下，上手很简单。我的导师某日天是Redis中文翻译者之一。<br><a href=\"http://www.redis.net.cn/tutorial/3501.html\" target=\"_blank\" rel=\"noopener\">Redis中文官网</a></p>\n<h4 id=\"scrapy-redis\"><a href=\"#scrapy-redis\" class=\"headerlink\" title=\"scrapy-redis\"></a>scrapy-redis</h4><p>scrapy-redis是一个基于redis的scrapy组件，通过它可以快速实现简单分布式爬虫程序，该组件本质上提供了三大功能：</p>\n<ul>\n<li>scheduler - 调度器</li>\n<li>dupefilter - URL去重规则（被调度器使用）</li>\n<li>pipeline   - 数据持久化</li>\n</ul>\n<p>看一下<code>settings.py</code>中的<code>Redis配置</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis配置</span></span><br><span class=\"line\"><span class=\"comment\"># 使用scrapy-redis里的调度器组件，不使用默认的调度器</span></span><br><span class=\"line\">SCHEDULER = <span class=\"string\">\"scrapy_redis.scheduler.Scheduler\"</span></span><br><span class=\"line\"><span class=\"comment\"># 允许暂停，redis请求记录不丢失</span></span><br><span class=\"line\">SCHEDULER_PERSIST = <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"comment\"># 使用scrapy-redis里的去重组件，不使用scrapy默认的去重方式</span></span><br><span class=\"line\">DUPEFILTER_CLASS = <span class=\"string\">\"scrapy_redis.dupefilter.RFPDupeFilter\"</span></span><br><span class=\"line\"><span class=\"comment\"># 连接Redis配置</span></span><br><span class=\"line\">REDIS_HOST = <span class=\"string\">'localhost'</span></span><br><span class=\"line\">REDIS_PORT = <span class=\"string\">'6379'</span></span><br><span class=\"line\">REDIS_DB = <span class=\"number\">0</span> <span class=\"comment\"># 指定db为0</span></span><br><span class=\"line\">REDIS_PASSWD = <span class=\"string\">''</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-爬虫技巧之接口的获取\"><a href=\"#3-爬虫技巧之接口的获取\" class=\"headerlink\" title=\"3. 爬虫技巧之接口的获取\"></a>3. 爬虫技巧之接口的获取</h3><p>当你了解了基础的爬虫知识之后，阻碍你顺利爬取数据的还有数据源的获取，每一个网站都有不同的架构，有些网站可能想让自己的内容更容易的让搜索引擎引用，同时又不想被恶意的爬虫访问，所以各个网站的后台数据送到前台展示方式都不同。</p>\n<p>经过我最近频繁的爬虫，我了解到一个非常重要的规律，那就是<strong>对于文本类型的数据一般都是使用JSON数据格式传输</strong>。但是这个<code>JSON数据接口</code>一般都非常隐蔽，比如<code>凤凰网</code>的评论展示接口，它使用了回调使用<code>js</code>进行处理之后再给到前台展示，所以你第一眼看到的不是整齐的<code>JSON</code>数据，而是一对乱糟糟不规律的类html文本。而<code>今日头条</code>则非常开放。</p>\n<p>好了，这一次的分享就到这儿了，分享一个不太哲学的网站<a href=\"http://www.mmjpg.com\" target=\"_blank\" rel=\"noopener\">哲学</a><br>爬取太频繁会封ip哦～</p>\n","site":{"data":{}},"excerpt":"<p>我的毕设主题是：时事新闻评论分析软件的设计与实现。要分析评论，就需要评论数据，于是就写起了爬虫。</p>","more":"<p>项目仓库：<a href=\"https://github.com/cap-ljf/NewsCommentsSpider\" target=\"_blank\" rel=\"noopener\">NewsCommentsSpider</a><br>如果感觉对您有帮助的话给个小小的<code>star</code>吧，哈哈。</p>\n<p>对于爬虫，搜索得到的文章大部分都是python爬虫，“python有天然的爬虫优势”，虽然我也讲不清python爬虫有什么天然的优势，可能在html文件解析、json解析、有大量成熟好用的工具包。于是我开始学习<code>scrapy</code>框架，上手很简单，而且官方文档比较详细。</p>\n<p><a href=\"http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">Scrapy入门教程</a></p>\n<h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><p>系统：<code>Ubuntu16.10</code><br>开发软件：<code>Pycharm 2017.3.3 Professinal Edition</code><br>工具包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python 3.5</span><br><span class=\"line\">pip 9.0.1</span><br><span class=\"line\">scrapy </span><br><span class=\"line\">beautifulsoup4 4.5.1</span><br><span class=\"line\">ipython 6.2.1</span><br><span class=\"line\">lxml 4.1.1</span><br><span class=\"line\">PyMySQL3 0.5</span><br><span class=\"line\">redis 2.10.6</span><br><span class=\"line\">requests 2.18.4</span><br><span class=\"line\">Scrapy 1.5.0</span><br><span class=\"line\">scrapy-redis 0.6.8</span><br><span class=\"line\">selenium 2.48.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-Scrapy入门，搭建NewsCommentsSpider项目\"><a href=\"#1-Scrapy入门，搭建NewsCommentsSpider项目\" class=\"headerlink\" title=\"1. Scrapy入门，搭建NewsCommentsSpider项目\"></a>1. Scrapy入门，搭建NewsCommentsSpider项目</h3><h4 id=\"安装scrapy\"><a href=\"#安装scrapy\" class=\"headerlink\" title=\"安装scrapy\"></a>安装scrapy</h4><p>我的系统是<code>Ubuntu16.10</code>，使用下列命令：<br><code>pip install scrapy</code></p>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p><code>scrapy startproject NewsCommentsSpider</code><br><em>下面一段解释来自scrapy中文官网</em><br>该命令将会创建包含下列内容的<code>NewsCommentsSpider</code>目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NewsCommentsSpider/</span><br><span class=\"line\">    scrapy.cfg</span><br><span class=\"line\">    NewsCommentsSpider/</span><br><span class=\"line\">        __init__.py</span><br><span class=\"line\">        items.py</span><br><span class=\"line\">        pipelines.py</span><br><span class=\"line\">        settings.py</span><br><span class=\"line\">        spiders/</span><br><span class=\"line\">            __init__.py</span><br><span class=\"line\">            ...</span><br></pre></td></tr></table></figure></p>\n<p>这些文件分别是:</p>\n<ul>\n<li><code>scrapy.cfg</code>: 项目的配置文件</li>\n<li><code>NewsCommentsSpider</code>/: 该项目的python模块。之后您将在此加入代码。</li>\n<li><code>NewsCommentsSpider/items.py</code>: 项目中的item文件.</li>\n<li><code>NewsCommentsSpider/pipelines.py</code>: 项目中的pipelines文件.</li>\n<li><code>NewsCommentsSpider/settings.py</code>: 项目的设置文件.</li>\n<li><code>NewsCommentsSpider/spiders/</code>: 放置spider代码的目录.</li>\n</ul>\n<h4 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h4><p>OK，到这儿我们就已经成功搭建好了scrapy框架。<br>现在来看我毕设的题目：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">题目：基于Python的时事新闻评论分析软件的设计与实现</span><br><span class=\"line\">主要数据：凤凰网、今日头条、网易新闻、微博四大平台的新闻评论。（一开始我是准备爬知乎和微信公众号的评论的，但是知乎问题的回答一般都很长，而且表达的主观情绪较少，一般都是摆数据讲道理，不太好分析；而微信公众号的评论接口我一直没找到，只好作罢，如果您有关于微信公众号文章评论接口相关的信息或想法，恳求告知：邮箱1579461369@qq.com）</span><br></pre></td></tr></table></figure></p>\n<p>针对上述需求，我设计了两个表：</p>\n<ol>\n<li>文章表：（<strong>article</strong>）新闻文章或微博信息</li>\n<li>评论表：（<strong>comment</strong>）文章评论相关信息</li>\n</ol>\n<p>请看：<br>【<strong>article</strong>】<br>| Field      |    Type | Null  | Key | Default | Extra |<br>| :——– | ——–:| :–: |<br>| id  | int(11) |  NO   | PRI |  | auto_increment |<br>| keyword  | varchar(20) |  NO   | MUL |  |  |<br>| url  | varchar(150) |  NO   |  |  |  |<br>| author  | varchar(50) |  YES   |  |  |  |<br>| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |<br>| comment_count  | int(11) |  NO   |  |  |  |</p>\n<p>【<strong>comment</strong>】<br>| Field      |    Type | Null  | Key | Default | Extra |<br>| :——– | ——–:| :–: |<br>| id  | int(11) |  NO   | PRI |  | auto_increment |<br>| url  | varchar(150) |  NO   | MUL |  |  |<br>| author  | varchar(50) |  YES   |  |  |  |<br>| create_time  | int(11) |  NO   |  | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |<br>| comment  | varchar(1000) |  NO   |  |  |  |<br>| praise  | smallint(6) |  YES   |  |  |  |</p>\n<p><strong>SQL语句</strong><br>第一次设计的时候<code>author</code>字段长度设计的比较小，导致在测试网易新闻评论爬取的时候出现异常，于是增加了<code>author</code>字段的大小。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> minsheng;</span><br><span class=\"line\"><span class=\"keyword\">USE</span> minsheng;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> article(</span><br><span class=\"line\">  <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键'</span>,</span><br><span class=\"line\">  keyword <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'关键词'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">url</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">150</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章url'</span>,</span><br><span class=\"line\">  author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'作者'</span>,</span><br><span class=\"line\">  create_time <span class=\"keyword\">TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章创建时间'</span>,</span><br><span class=\"line\">  comment_count <span class=\"built_in\">int</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论数'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">id</span>),</span><br><span class=\"line\">  <span class=\"keyword\">INDEX</span> idx_keyword (keyword)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span> = <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">CHARSET</span> = <span class=\"string\">'utf8'</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章表'</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">comment</span>(</span><br><span class=\"line\">  <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">url</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">150</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章链接'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1000</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论'</span>,</span><br><span class=\"line\">  author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论者'</span>,</span><br><span class=\"line\">  praise <span class=\"built_in\">SMALLINT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'点赞数'</span>,</span><br><span class=\"line\">  create_time <span class=\"keyword\">TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论时间'</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"keyword\">id</span>),</span><br><span class=\"line\">  <span class=\"keyword\">INDEX</span> idx_url (<span class=\"keyword\">url</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span> = <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">CHARSET</span> = <span class=\"string\">'utf8mb4'</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'评论表'</span>;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">comment</span> <span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> article <span class=\"keyword\">MODIFY</span> <span class=\"keyword\">COLUMN</span> author <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义Item\"><a href=\"#定义Item\" class=\"headerlink\" title=\"定义Item\"></a>定义Item</h4><p>既然已经有了数据库表，我们就可以知道我们需要那些数据，就可以编写<code>Item</code>类。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> Field</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 文章链接</span></span><br><span class=\"line\">    url = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论内容</span></span><br><span class=\"line\">    comment = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论者</span></span><br><span class=\"line\">    author = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 点赞数</span></span><br><span class=\"line\">    praise = Field()</span><br><span class=\"line\">    <span class=\"comment\"># 评论时间</span></span><br><span class=\"line\">    create_time = Field()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Item-Pipeline，使用Mysql数据库存储数据\"><a href=\"#Item-Pipeline，使用Mysql数据库存储数据\" class=\"headerlink\" title=\"Item Pipeline，使用Mysql数据库存储数据\"></a>Item Pipeline，使用Mysql数据库存储数据</h4><p>编写你自己的item pipeline很简单，每个item pipiline组件是一个独立的Python类，同时必须实现<code>process_item</code>方法。<br>这里我们使用<code>pymysql</code>包操作mysql数据库。首先在<code>pipeline</code>初始化时创建数据库连接，并获取<code>cursor</code>。然后在<code>process_item</code>方法中执行增删改查操作。最后<strong>关闭连接</strong>，一定要记得关闭连接，否则会产生大量的连接以及游标，最后导致内存泄漏。<br>废话少说，上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.settings <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义数据存储方式</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.connect = pymysql.connect(</span><br><span class=\"line\">                host=MYSQL_HOST,</span><br><span class=\"line\">                db=MYSQL_DBNAME,</span><br><span class=\"line\">                user=MYSQL_USER,</span><br><span class=\"line\">                passwd=MYSQL_PASSWD,</span><br><span class=\"line\">                charset=<span class=\"string\">'utf8'</span>,</span><br><span class=\"line\">                use_unicode=<span class=\"keyword\">True</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"comment\"># 通过cursor执行增删改查</span></span><br><span class=\"line\">            self.cursor = self.connect.cursor()</span><br><span class=\"line\">            logging.debug(<span class=\"string\">'mysql conn success!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            logging.error(<span class=\"string\">'mysql conn error!:'</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            self.cursor.execute(</span><br><span class=\"line\">                <span class=\"string\">\"\"\"insert into comment(url, comment, author, praise, create_time)</span></span><br><span class=\"line\"><span class=\"string\">                                  value (%s, %s, %s, %s, %s)\"\"\"</span>,</span><br><span class=\"line\">                (item[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'comment'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'author'</span>],</span><br><span class=\"line\">                 item[<span class=\"string\">'praise'</span>],</span><br><span class=\"line\">                 <span class=\"comment\"># item['create_time']</span></span><br><span class=\"line\">                 datetime.fromtimestamp(item[<span class=\"string\">'create_time'</span>])</span><br><span class=\"line\">                 )</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"comment\"># 提交sql语句</span></span><br><span class=\"line\">            self.connect.commit()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            <span class=\"comment\"># 异常打印日志</span></span><br><span class=\"line\">            logging.error(<span class=\"string\">\"数据库插入异常:\"</span>, error)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__del__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"comment\"># if self.cursor:</span></span><br><span class=\"line\">            <span class=\"comment\">#     self.cursor.close()</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.connect:</span><br><span class=\"line\">                self.connect.close()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> error:</span><br><span class=\"line\">            logging.error(<span class=\"string\">\"conn or cursor 关闭失败:\"</span>, error)</span><br></pre></td></tr></table></figure></p>\n<p>代码中我注释了这样两段代码</p>\n<ol>\n<li><code>item[&#39;create_time&#39;]</code>，如果直接使用<code>timestamp</code>执行<code>insert</code>。这里出现异常：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message: <span class=\"string\">'数据库插入异常:'</span></span><br><span class=\"line\">Arguments: (InternalError(InternalError(1292, <span class=\"string\">\"Incorrect datetime value: '1522110959' for column 'create_time' at row 1\"</span>),),)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我也不知道为什么，python操作mysql插入数据库为什么会出现这种情况，后来我将时间戳改成<code>datetime</code>类型就没问题了。</p>\n<ol>\n<li><code>__del__()</code>，在这个函数我进行了<code>cursor</code>和<code>connect</code>的关闭，但是不知道为什么游标一直关不掉，debug信息指示：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception ignored in: &lt;bound method Cursor.__del__ of &lt;pymysql.cursors.Cursor object at 0x7f702d1c93c8&gt;&gt;</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py&quot;, line 41, in __del__</span><br><span class=\"line\">  File &quot;/usr/local/lib/python3.5/dist-packages/PyMySQL3-0.5-py3.5.egg/pymysql/cursors.py&quot;, line 47, in close</span><br><span class=\"line\">ReferenceError: weakly-referenced object no longer exists</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在<code>stackoverflow</code>上多次解释说在<code>__def__</code>中按顺序关闭，但是我尝试之后还是不行，不过这个<code>Exception</code>不影响正常运行。</p>\n<p>费老大劲终于写完了<code>item Pipeline</code>，但是还有最关键的一步，就是在<code>settings.py</code>中添加这个<code>MySQLPipeline</code>。<br>在<code>settings.py</code>中加上下面内容：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysql配置</span></span><br><span class=\"line\">MYSQL_HOST = <span class=\"string\">'localhost'</span></span><br><span class=\"line\">MYSQL_DBNAME = <span class=\"string\">'minsheng'</span></span><br><span class=\"line\">MYSQL_USER = <span class=\"string\">'root'</span></span><br><span class=\"line\">MYSQL_PASSWD = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">    <span class=\"string\">'NewsCommentsSpider.pipelines.MySQLPipeline'</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"下载器中间件（Downloader-Middleware）\"><a href=\"#下载器中间件（Downloader-Middleware）\" class=\"headerlink\" title=\"下载器中间件（Downloader Middleware）\"></a>下载器中间件（Downloader Middleware）</h4><p>现在的网站不好爬啊，各个大公司都有丰富的反爬虫手段，我们刚才写的都不是爬虫核心，真正的爬虫核心是解析数据和伪装手段。而伪装手段有：</p>\n<ol>\n<li>request header</li>\n<li>User-Agent</li>\n<li>proxy</li>\n<li>cookies</li>\n</ol>\n<p><code>scrapy</code>框架提供了<code>Downloader Middleware</code>供我们对<code>request</code>进行设置。<br>上代码：<br>【middlewares.py】<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.downloadermiddlewares.useragent <span class=\"keyword\">import</span> UserAgentMiddleware</span><br><span class=\"line\"><span class=\"comment\"># from NewsCommentsSpider.cookies import cookies</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.user_agent <span class=\"keyword\">import</span> agents</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAgentMiddleware</span><span class=\"params\">(UserAgentMiddleware)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" 换User-Agent \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        agent = random.choice(agents)</span><br><span class=\"line\">        request.headers[<span class=\"string\">'User-Agent'</span>] = agent</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CookiesMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\" 四个网站，选择相应cookie \"\"\"</span></span><br><span class=\"line\">    <span class=\"comment\"># def process_request(self, request, spider):</span></span><br><span class=\"line\">    <span class=\"comment\">#     if spider.name == 'weibo':</span></span><br><span class=\"line\">    <span class=\"comment\">#         cookie = random.choice(cookies)</span></span><br><span class=\"line\">    <span class=\"comment\">#         request.cookies = cookie</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeadersMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxiesMiddleware</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>【user-agent.py】<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># encoding=utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\">agents = [</span><br><span class=\"line\">\t<span class=\"string\">\"Mozilla/5.0 (Linux; U; Android 2.3.6; en-us; Nexus S Build/GRK39F) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\"</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>这里就不列出所有内容了<br>同理，<code>cookies.py</code>和<code>proxies.py</code>也是同样的道理。</p>\n<p>到这里，“准备工作”就已经都完成了，现在终于到主角<code>Spider</code>登场。</p>\n<h4 id=\"Spiders\"><a href=\"#Spiders\" class=\"headerlink\" title=\"Spiders\"></a>Spiders</h4><p>看一个示例，就拿相对简单的今日头条评论<code>ToutiaoSpider</code>来讲解。<br>先上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">@author: cap_ljf</span></span><br><span class=\"line\"><span class=\"string\">@time: 18-3-16 上午11:25</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy_redis.spiders <span class=\"keyword\">import</span> RedisSpider</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> NewsCommentsSpider.items <span class=\"keyword\">import</span> CommentItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToutiaoSpider</span><span class=\"params\">(RedisSpider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'toutiao'</span></span><br><span class=\"line\">    redis_key = <span class=\"string\">'toutiao_url'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        新闻链接：https://www.toutiao.com/a6533396129860551182/</span></span><br><span class=\"line\"><span class=\"string\">        评论接口：https://www.toutiao.com/api/comment/list/?group_id=6533396129860551182&amp;item_id=6533396129860551182</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.allowed_domains = [<span class=\"string\">'www.toutiao.com'</span>]</span><br><span class=\"line\">        self.url = <span class=\"string\">'https://www.toutiao.com/a'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        content = json.loads(response.body.decode())</span><br><span class=\"line\">        id = re.search(<span class=\"string\">r'([0-9]+)'</span>, response.url).group(<span class=\"number\">1</span>)</span><br><span class=\"line\">        url = self.url + str(id)</span><br><span class=\"line\">        comments = content[<span class=\"string\">'data'</span>][<span class=\"string\">'comments'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> comment <span class=\"keyword\">in</span> comments:</span><br><span class=\"line\">            item = CommentItem()</span><br><span class=\"line\">            item[<span class=\"string\">'url'</span>] = url</span><br><span class=\"line\">            item[<span class=\"string\">'comment'</span>] = comment[<span class=\"string\">'text'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'author'</span>] = comment[<span class=\"string\">'user'</span>][<span class=\"string\">'name'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'praise'</span>] = comment[<span class=\"string\">'digg_count'</span>]</span><br><span class=\"line\">            item[<span class=\"string\">'create_time'</span>] = comment[<span class=\"string\">'create_time'</span>]</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>name</code>：用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li>\n<li><code>redis_key</code>：使用scrapy-redis，必须要有这个字段且唯一，相当于<code>scrapy</code>的<code>start_urls</code>，包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li>\n<li><code>parse()</code>：是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>\n</ul>\n<p>因为我们项目使用了<code>scrapy-redis</code>，所以这里的<code>class</code>父对象是<code>RedisSpider</code>，普通的<code>xxxSpider</code>父对象是<code>Spider</code>。</p>\n<p>得到了<code>response</code>对象之后就可使用多种方法解析获取有用的信息了，解析方法有：</p>\n<ol>\n<li>beautifulSoup</li>\n<li>XPath </li>\n<li>re</li>\n</ol>\n<p>如果使用<code>scrapy</code>，推荐使用<a href=\"http://www.w3school.com.cn/xpath/xpath_syntax.asp\" target=\"_blank\" rel=\"noopener\">XPath</a>，语法很简单，半个小时基本能掌握。</p>\n<p>由于解析数据是一个麻烦的事情，而我<strong>刚好</strong>找到了四个网站中的三个的评论接口，它们返回的数据直接是评论的<code>JSON</code>数据。可以直接用Python的<code>dict</code>解析数据。<br>在项目目录下使用命令行执行<code>scrapy crawl toutiao</code>，就可以在数据库中看到数据啦。<br>不信？悟空，你看（观音指）：<br><img src=\"https://app.yinxiang.com/shard/s15/res/dcd35021-e4af-42dd-856b-712b5c0061bc/1522163039866.png\" alt=\"Alt text\"><br>哦哦，因为代码是用的<code>redis</code>版本，还有相关<code>settings.py</code>没有讲解，所以上面无法执行，可直接去github clone代码下来运行看看效果。如果非要运行起来，看下面<code>2. Redis，分布式爬虫</code></p>\n<h3 id=\"2-Redis，分布式爬虫\"><a href=\"#2-Redis，分布式爬虫\" class=\"headerlink\" title=\"2. Redis，分布式爬虫\"></a>2. Redis，分布式爬虫</h3><p>第一部分介绍了如何使用scrapy爬取评论。现在我们对代码进行重构，增加<code>Redis</code>进行分布式爬虫，增加爬虫效率。</p>\n<p>参考：<a href=\"https://blog.csdn.net/bone_ace/article/details/50904718\" target=\"_blank\" rel=\"noopener\">新浪微博分布式爬虫分享</a></p>\n<blockquote>\n<p>分布式中有一台机充当Master，安装Redis进行任务调度，其余机子充当Slaver只管从Master那里拿任务去爬。原理是：Slaver运行的时候，scrapy遇到Request并不是交给spider去爬，而是统一交给Master机上的Redis数据库，spider要爬的Request也都是从Redis中取来的，而Redis接收到Request后先去重再存入数据库，哪个Slaver要Request了再给它，由此实现任务协同。</p>\n</blockquote>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><blockquote>\n<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n</blockquote>\n<p>不了解redis的去官网学一下，上手很简单。我的导师某日天是Redis中文翻译者之一。<br><a href=\"http://www.redis.net.cn/tutorial/3501.html\" target=\"_blank\" rel=\"noopener\">Redis中文官网</a></p>\n<h4 id=\"scrapy-redis\"><a href=\"#scrapy-redis\" class=\"headerlink\" title=\"scrapy-redis\"></a>scrapy-redis</h4><p>scrapy-redis是一个基于redis的scrapy组件，通过它可以快速实现简单分布式爬虫程序，该组件本质上提供了三大功能：</p>\n<ul>\n<li>scheduler - 调度器</li>\n<li>dupefilter - URL去重规则（被调度器使用）</li>\n<li>pipeline   - 数据持久化</li>\n</ul>\n<p>看一下<code>settings.py</code>中的<code>Redis配置</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis配置</span></span><br><span class=\"line\"><span class=\"comment\"># 使用scrapy-redis里的调度器组件，不使用默认的调度器</span></span><br><span class=\"line\">SCHEDULER = <span class=\"string\">\"scrapy_redis.scheduler.Scheduler\"</span></span><br><span class=\"line\"><span class=\"comment\"># 允许暂停，redis请求记录不丢失</span></span><br><span class=\"line\">SCHEDULER_PERSIST = <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"comment\"># 使用scrapy-redis里的去重组件，不使用scrapy默认的去重方式</span></span><br><span class=\"line\">DUPEFILTER_CLASS = <span class=\"string\">\"scrapy_redis.dupefilter.RFPDupeFilter\"</span></span><br><span class=\"line\"><span class=\"comment\"># 连接Redis配置</span></span><br><span class=\"line\">REDIS_HOST = <span class=\"string\">'localhost'</span></span><br><span class=\"line\">REDIS_PORT = <span class=\"string\">'6379'</span></span><br><span class=\"line\">REDIS_DB = <span class=\"number\">0</span> <span class=\"comment\"># 指定db为0</span></span><br><span class=\"line\">REDIS_PASSWD = <span class=\"string\">''</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-爬虫技巧之接口的获取\"><a href=\"#3-爬虫技巧之接口的获取\" class=\"headerlink\" title=\"3. 爬虫技巧之接口的获取\"></a>3. 爬虫技巧之接口的获取</h3><p>当你了解了基础的爬虫知识之后，阻碍你顺利爬取数据的还有数据源的获取，每一个网站都有不同的架构，有些网站可能想让自己的内容更容易的让搜索引擎引用，同时又不想被恶意的爬虫访问，所以各个网站的后台数据送到前台展示方式都不同。</p>\n<p>经过我最近频繁的爬虫，我了解到一个非常重要的规律，那就是<strong>对于文本类型的数据一般都是使用JSON数据格式传输</strong>。但是这个<code>JSON数据接口</code>一般都非常隐蔽，比如<code>凤凰网</code>的评论展示接口，它使用了回调使用<code>js</code>进行处理之后再给到前台展示，所以你第一眼看到的不是整齐的<code>JSON</code>数据，而是一对乱糟糟不规律的类html文本。而<code>今日头条</code>则非常开放。</p>\n<p>好了，这一次的分享就到这儿了，分享一个不太哲学的网站<a href=\"http://www.mmjpg.com\" target=\"_blank\" rel=\"noopener\">哲学</a><br>爬取太频繁会封ip哦～</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjloh3e3m00006k15vmpbmexx","tag_id":"cjloh3e3u00026k157o4md1s6","_id":"cjloh3e44000b6k15lh1u08zg"},{"post_id":"cjloh3e3m00006k15vmpbmexx","tag_id":"cjloh3e4000066k1587io07k7","_id":"cjloh3e46000d6k15b3j5jzov"},{"post_id":"cjloh3e3w00036k153d09n04m","tag_id":"cjloh3e4300096k157n0v4srv","_id":"cjloh3e4d000j6k152vhiklqp"},{"post_id":"cjloh3e3w00036k153d09n04m","tag_id":"cjloh3e47000e6k15ocxdq4sx","_id":"cjloh3e4f000l6k15lauwrnm8"},{"post_id":"cjloh3e3x00046k15wlpjykg1","tag_id":"cjloh3e4b000h6k155cc244qh","_id":"cjloh3e4h000o6k15xxbqrong"},{"post_id":"cjloh3e3z00056k15jdq6jrxv","tag_id":"cjloh3e4g000n6k159sg9z0bg","_id":"cjloh3e4n000w6k15k69didh2"},{"post_id":"cjloh3e3z00056k15jdq6jrxv","tag_id":"cjloh3e4k000r6k15o01xieas","_id":"cjloh3e4o000y6k15vdq28hpa"},{"post_id":"cjloh3e4000076k15oous8xqq","tag_id":"cjloh3e4m000u6k150mfzf99d","_id":"cjloh3e4p00106k15x36ybfq0"},{"post_id":"cjloh3e43000a6k15fz0twzyz","tag_id":"cjloh3e4p000z6k15ecok4r2y","_id":"cjloh3e4q00136k15g4bz3oz5"},{"post_id":"cjloh3e43000a6k15fz0twzyz","tag_id":"cjloh3e4p00116k152svjq64y","_id":"cjloh3e4q00146k159cguet9c"},{"post_id":"cjloh3e45000c6k154olstacu","tag_id":"cjloh3e4q00126k15udhp6snu","_id":"cjloh3e4s00176k153urbin3a"},{"post_id":"cjloh3e45000c6k154olstacu","tag_id":"cjloh3e4q00156k15k038tw5v","_id":"cjloh3e4t00186k15zxosq5oq"},{"post_id":"cjloh3e47000f6k15xe65mq0u","tag_id":"cjloh3e4q00126k15udhp6snu","_id":"cjloh3e4u001c6k15i78899jc"},{"post_id":"cjloh3e47000f6k15xe65mq0u","tag_id":"cjloh3e4q00156k15k038tw5v","_id":"cjloh3e4v001d6k1519oc35n7"},{"post_id":"cjloh3e47000f6k15xe65mq0u","tag_id":"cjloh3e4t001a6k157356x35m","_id":"cjloh3e4v001f6k15qqlvup1c"},{"post_id":"cjloh3e4a000g6k15feat1z3i","tag_id":"cjloh3e4u001b6k15xqy4hq7x","_id":"cjloh3e4w001h6k15ga2lz4p6"},{"post_id":"cjloh3e4a000g6k15feat1z3i","tag_id":"cjloh3e4v001e6k15r2oq7np1","_id":"cjloh3e4w001i6k15k1vfz3x6"},{"post_id":"cjloh3e4c000i6k153ajwrqqn","tag_id":"cjloh3e4v001g6k1595x239b3","_id":"cjloh3e4x001m6k158p9b8t6w"},{"post_id":"cjloh3e4c000i6k153ajwrqqn","tag_id":"cjloh3e4w001j6k15xua60gx3","_id":"cjloh3e4y001n6k150icldt83"},{"post_id":"cjloh3e4c000i6k153ajwrqqn","tag_id":"cjloh3e4x001k6k154mievnr7","_id":"cjloh3e4y001p6k15fclel193"},{"post_id":"cjloh3e4e000k6k15uxljqr3m","tag_id":"cjloh3e4v001g6k1595x239b3","_id":"cjloh3e4z001r6k15rdnl1ruo"},{"post_id":"cjloh3e4e000k6k15uxljqr3m","tag_id":"cjloh3e4y001o6k15bjqn82mv","_id":"cjloh3e4z001s6k15p2d10q7g"},{"post_id":"cjloh3e4f000m6k15289oqonh","tag_id":"cjloh3e4y001q6k15a7ggwvny","_id":"cjloh3e50001v6k15qnz57jc5"},{"post_id":"cjloh3e4f000m6k15289oqonh","tag_id":"cjloh3e4z001t6k15z23e39v4","_id":"cjloh3e50001w6k154xkq8lo9"},{"post_id":"cjloh3e4h000p6k15a5xs17y7","tag_id":"cjloh3e4z001u6k153bzpko8w","_id":"cjloh3e51001z6k153n4teays"},{"post_id":"cjloh3e4h000p6k15a5xs17y7","tag_id":"cjloh3e50001x6k158kpxh5i1","_id":"cjloh3e5100206k15mpba2noq"},{"post_id":"cjloh3e4j000q6k15iu8euxgu","tag_id":"cjloh3e50001y6k150lbv1yzz","_id":"cjloh3e5200226k15s6p41os1"},{"post_id":"cjloh3e4l000s6k15fxpfb6yf","tag_id":"cjloh3e5100216k15njoinw5m","_id":"cjloh3e5400256k15k5x2bp0n"},{"post_id":"cjloh3e4l000s6k15fxpfb6yf","tag_id":"cjloh3e4z001u6k153bzpko8w","_id":"cjloh3e5400266k1526oy2c2s"},{"post_id":"cjloh3e4l000t6k159btquu62","tag_id":"cjloh3e4z001u6k153bzpko8w","_id":"cjloh3e5500296k15xlgx1gyy"},{"post_id":"cjloh3e4l000t6k159btquu62","tag_id":"cjloh3e5400276k15owk0fa5m","_id":"cjloh3e55002a6k15bjzqva6x"},{"post_id":"cjloh3e4n000v6k15v48voov1","tag_id":"cjloh3e5400286k15rzl2zjml","_id":"cjloh3e56002c6k15d8k5w83h"},{"post_id":"cjloh3e4o000x6k15kdzwo5rx","tag_id":"cjloh3e55002b6k15pb4hdq62","_id":"cjloh3e56002d6k15xshixn7v"},{"post_id":"cjloh3e5e002e6k1583kc95o4","tag_id":"cjloh3e5g002g6k15e8eabr85","_id":"cjloh3e5k002l6k15e79s2oxj"},{"post_id":"cjloh3e5l002m6k155er0bqng","tag_id":"cjloh3e4x001k6k154mievnr7","_id":"cjloh3e5o002p6k15vvv1um2c"},{"post_id":"cjloh3e5m002n6k15j2excd34","tag_id":"cjloh3e4v001g6k1595x239b3","_id":"cjloh3e5p002r6k155vfn8cmm"},{"post_id":"cjloh3e5f002f6k15g6ydtl3o","tag_id":"cjloh3e5k002k6k150kh92mha","_id":"cjloh3e5s002v6k150wwqv9hc"},{"post_id":"cjloh3e5f002f6k15g6ydtl3o","tag_id":"cjloh3e5n002o6k150a3xrbl4","_id":"cjloh3e5t002x6k152ze803v2"},{"post_id":"cjloh3e5r002u6k15m23xgvlk","tag_id":"cjloh3e5n002o6k150a3xrbl4","_id":"cjloh3e5v00306k15ggbp68ne"},{"post_id":"cjloh3e5h002h6k15l5pjmrpi","tag_id":"cjloh3e5q002t6k150itmljqd","_id":"cjloh3e5w00326k15zfmszrd2"},{"post_id":"cjloh3e5i002i6k15ln30bj2n","tag_id":"cjloh3e5t002y6k15up74b78j","_id":"cjloh3e5z00366k15xhj3e3sx"},{"post_id":"cjloh3e5i002i6k15ln30bj2n","tag_id":"cjloh3e5y00346k15bc8up5qs","_id":"cjloh3e5z00376k15kdbgqabj"},{"post_id":"cjloh3e5j002j6k159iymfdyi","tag_id":"cjloh3e5k002k6k150kh92mha","_id":"cjloh3e60003a6k1564ah5pb3"},{"post_id":"cjloh3e5j002j6k159iymfdyi","tag_id":"cjloh3e5z00386k15uug2wy5j","_id":"cjloh3e60003b6k154wb28dat"},{"post_id":"cjloh3e5o002q6k15yftm7u1d","tag_id":"cjloh3e4v001g6k1595x239b3","_id":"cjloh3e61003d6k15lmlsre4c"},{"post_id":"cjloh3e5o002q6k15yftm7u1d","tag_id":"cjloh3e6000396k15jpc8hdtw","_id":"cjloh3e61003e6k150l72py7e"},{"post_id":"cjloh3e5p002s6k1572avkobh","tag_id":"cjloh3e60003c6k15qfome1wd","_id":"cjloh3e61003g6k15o08qh549"},{"post_id":"cjloh3e5s002w6k15tznmo4o7","tag_id":"cjloh3e61003f6k15tuwkri5f","_id":"cjloh3e62003j6k154vvkpbyx"},{"post_id":"cjloh3e5s002w6k15tznmo4o7","tag_id":"cjloh3e62003h6k15xngrqfz5","_id":"cjloh3e63003k6k15wfou7r25"},{"post_id":"cjloh3e5u002z6k15ru9i8gea","tag_id":"cjloh3e62003i6k15rhmdqx7w","_id":"cjloh3e64003q6k15c0r2ill8"},{"post_id":"cjloh3e5u002z6k15ru9i8gea","tag_id":"cjloh3e63003l6k15voh3lo0m","_id":"cjloh3e64003r6k15h14fjdbj"},{"post_id":"cjloh3e5u002z6k15ru9i8gea","tag_id":"cjloh3e63003m6k15c28uzy9p","_id":"cjloh3e65003t6k15zch2j9ws"},{"post_id":"cjloh3e5u002z6k15ru9i8gea","tag_id":"cjloh3e63003n6k15lm6udz7a","_id":"cjloh3e65003u6k15zy9c39hl"},{"post_id":"cjloh3e5u002z6k15ru9i8gea","tag_id":"cjloh3e64003o6k158xpms9e1","_id":"cjloh3e65003w6k15m7awqe50"},{"post_id":"cjloh3e5w00316k1559piqoab","tag_id":"cjloh3e64003p6k156s0sjpp2","_id":"cjloh3e66003y6k15xzwwx14f"},{"post_id":"cjloh3e5w00316k1559piqoab","tag_id":"cjloh3e65003s6k15lb6scmpz","_id":"cjloh3e66003z6k158w8q8amg"},{"post_id":"cjloh3e5w00316k1559piqoab","tag_id":"cjloh3e65003v6k15uery4cq0","_id":"cjloh3e6600406k15nr0h7p9d"},{"post_id":"cjloh3e5x00336k15iuaga48a","tag_id":"cjloh3e4q00126k15udhp6snu","_id":"cjloh3e6700416k151ghhf1rt"},{"post_id":"cjloh3e5x00336k15iuaga48a","tag_id":"cjloh3e66003x6k15luhv14ia","_id":"cjloh3e6700426k15oft19e5z"},{"post_id":"cjloh3e6g00436k158sjrsqm9","tag_id":"cjloh3e6i00456k15wcy98jwh","_id":"cjloh3e6m004b6k15slak1xlo"},{"post_id":"cjloh3e6g00436k158sjrsqm9","tag_id":"cjloh3e6l00486k15szw2b8zg","_id":"cjloh3e6n004c6k155jiswrcg"},{"post_id":"cjloh3e6g00436k158sjrsqm9","tag_id":"cjloh3e6m00496k15jeyqu0td","_id":"cjloh3e6n004e6k15yeqkynhy"},{"post_id":"cjloh3e6h00446k156j99wkhu","tag_id":"cjloh3e6m004a6k15ducg93cz","_id":"cjloh3e6n004f6k15rxe0289l"},{"post_id":"cjloh3e6i00466k15mmrhsnwh","tag_id":"cjloh3e6n004d6k15ojc48xul","_id":"cjloh3e6o004h6k15hp2jjzhb"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e4u001b6k15xqy4hq7x","_id":"cjloh3e6r004m6k15zkkjlnfy"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e6o004g6k15ixvgpsg2","_id":"cjloh3e6r004n6k15si1k3t44"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e4p000z6k15ecok4r2y","_id":"cjloh3e6r004o6k15i185wviz"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e6p004i6k15a56ghjoj","_id":"cjloh3e6r004p6k15qp6sa2ga"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e6p004j6k15f3yim9sk","_id":"cjloh3e6s004q6k15cizm8kuk"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e6q004k6k1547s71ytb","_id":"cjloh3e6s004r6k151g633lxc"},{"post_id":"cjloh3e6k00476k15uq37jsti","tag_id":"cjloh3e6q004l6k15end3mox1","_id":"cjloh3e6s004s6k15fk30crup"}],"Tag":[{"name":"2017","_id":"cjloh3e3u00026k157o4md1s6"},{"name":"总结","_id":"cjloh3e4000066k1587io07k7"},{"name":"Hexo","_id":"cjloh3e4300096k157n0v4srv"},{"name":"seo","_id":"cjloh3e47000e6k15ocxdq4sx"},{"name":"并发","_id":"cjloh3e4b000h6k155cc244qh"},{"name":"jvm","_id":"cjloh3e4g000n6k159sg9z0bg"},{"name":"java虚拟机","_id":"cjloh3e4k000r6k15o01xieas"},{"name":"泛型","_id":"cjloh3e4m000u6k150mfzf99d"},{"name":"redis","_id":"cjloh3e4p000z6k15ecok4r2y"},{"name":"spring data redis","_id":"cjloh3e4p00116k152svjq64y"},{"name":"java","_id":"cjloh3e4q00126k15udhp6snu"},{"name":"I/O","_id":"cjloh3e4q00156k15k038tw5v"},{"name":"流","_id":"cjloh3e4t001a6k157356x35m"},{"name":"爬虫","_id":"cjloh3e4u001b6k15xqy4hq7x"},{"name":"新浪微博","_id":"cjloh3e4v001e6k15r2oq7np1"},{"name":"Spring","_id":"cjloh3e4v001g6k1595x239b3"},{"name":"web","_id":"cjloh3e4w001j6k15xua60gx3"},{"name":"Spring MVC","_id":"cjloh3e4x001k6k154mievnr7"},{"name":"DI","_id":"cjloh3e4y001o6k15bjqn82mv"},{"name":"随笔","_id":"cjloh3e4y001q6k15a7ggwvny"},{"name":"读书","_id":"cjloh3e4z001t6k15z23e39v4"},{"name":"面经","_id":"cjloh3e4z001u6k153bzpko8w"},{"name":"京东","_id":"cjloh3e50001x6k158kpxh5i1"},{"name":"健身","_id":"cjloh3e50001y6k150lbv1yzz"},{"name":"华为","_id":"cjloh3e5100216k15njoinw5m"},{"name":"qunar","_id":"cjloh3e5400276k15owk0fa5m"},{"name":"杂谈","_id":"cjloh3e5400286k15rzl2zjml"},{"name":"music","_id":"cjloh3e55002b6k15pb4hdq62"},{"name":"JSON","_id":"cjloh3e5g002g6k15e8eabr85"},{"name":"JDBC","_id":"cjloh3e5k002k6k150kh92mha"},{"name":"事务","_id":"cjloh3e5n002o6k150a3xrbl4"},{"name":"注解","_id":"cjloh3e5q002t6k150itmljqd"},{"name":"transient","_id":"cjloh3e5t002y6k15up74b78j"},{"name":"序列化","_id":"cjloh3e5y00346k15bc8up5qs"},{"name":"DataSource","_id":"cjloh3e5z00386k15uug2wy5j"},{"name":"aop","_id":"cjloh3e6000396k15jpc8hdtw"},{"name":"提问的智慧","_id":"cjloh3e60003c6k15qfome1wd"},{"name":"算法","_id":"cjloh3e61003f6k15tuwkri5f"},{"name":"动态规划","_id":"cjloh3e62003h6k15xngrqfz5"},{"name":"字符编码","_id":"cjloh3e62003i6k15rhmdqx7w"},{"name":"字符集","_id":"cjloh3e63003l6k15voh3lo0m"},{"name":"UTF-8","_id":"cjloh3e63003m6k15c28uzy9p"},{"name":"UTF-16","_id":"cjloh3e63003n6k15lm6udz7a"},{"name":"Unicode","_id":"cjloh3e64003o6k158xpms9e1"},{"name":"linux","_id":"cjloh3e64003p6k156s0sjpp2"},{"name":"yum","_id":"cjloh3e65003s6k15lb6scmpz"},{"name":"apt","_id":"cjloh3e65003v6k15uery4cq0"},{"name":"正则表达式","_id":"cjloh3e66003x6k15luhv14ia"},{"name":"Java网络编程","_id":"cjloh3e6i00456k15wcy98jwh"},{"name":"socket","_id":"cjloh3e6l00486k15szw2b8zg"},{"name":"JavaMail","_id":"cjloh3e6m00496k15jeyqu0td"},{"name":"maven","_id":"cjloh3e6m004a6k15ducg93cz"},{"name":"Singleton","_id":"cjloh3e6n004d6k15ojc48xul"},{"name":"scrapy","_id":"cjloh3e6o004g6k15ixvgpsg2"},{"name":"weibo","_id":"cjloh3e6p004i6k15a56ghjoj"},{"name":"news163","_id":"cjloh3e6p004j6k15f3yim9sk"},{"name":"ifeng","_id":"cjloh3e6q004k6k1547s71ytb"},{"name":"toutiao","_id":"cjloh3e6q004l6k15end3mox1"}]}}